// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * generate_unused_types
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod golem {
    pub mod tts {
        /// Core types and error handling for universal text-to-speech
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum QuotaUnit {
                Characters,
                Requests,
                Seconds,
                Credits,
            }
            impl ::core::fmt::Debug for QuotaUnit {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        QuotaUnit::Characters => {
                            f.debug_tuple("QuotaUnit::Characters").finish()
                        }
                        QuotaUnit::Requests => {
                            f.debug_tuple("QuotaUnit::Requests").finish()
                        }
                        QuotaUnit::Seconds => {
                            f.debug_tuple("QuotaUnit::Seconds").finish()
                        }
                        QuotaUnit::Credits => {
                            f.debug_tuple("QuotaUnit::Credits").finish()
                        }
                    }
                }
            }
            impl QuotaUnit {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> QuotaUnit {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => QuotaUnit::Characters,
                        1 => QuotaUnit::Requests,
                        2 => QuotaUnit::Seconds,
                        3 => QuotaUnit::Credits,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct QuotaInfo {
                pub used: u32,
                pub limit: u32,
                pub reset_time: u64,
                pub unit: QuotaUnit,
            }
            impl ::core::fmt::Debug for QuotaInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("QuotaInfo")
                        .field("used", &self.used)
                        .field("limit", &self.limit)
                        .field("reset-time", &self.reset_time)
                        .field("unit", &self.unit)
                        .finish()
                }
            }
            /// Comprehensive error types covering all TTS operations
            #[derive(Clone)]
            pub enum TtsError {
                /// Input validation errors
                InvalidText(_rt::String),
                TextTooLong(u32),
                InvalidSsml(_rt::String),
                UnsupportedLanguage(_rt::String),
                /// Voice and model errors
                VoiceNotFound(_rt::String),
                ModelNotFound(_rt::String),
                VoiceUnavailable(_rt::String),
                /// Authentication and authorization
                Unauthorized(_rt::String),
                AccessDenied(_rt::String),
                /// Resource and quota limits
                QuotaExceeded(QuotaInfo),
                RateLimited(u32),
                InsufficientCredits,
                /// Operation errors
                SynthesisFailed(_rt::String),
                UnsupportedOperation(_rt::String),
                InvalidConfiguration(_rt::String),
                /// Service errors
                ServiceUnavailable(_rt::String),
                NetworkError(_rt::String),
                InternalError(_rt::String),
                /// Storage errors (for async operations)
                InvalidStorageLocation(_rt::String),
                StorageAccessDenied(_rt::String),
            }
            impl ::core::fmt::Debug for TtsError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TtsError::InvalidText(e) => {
                            f.debug_tuple("TtsError::InvalidText").field(e).finish()
                        }
                        TtsError::TextTooLong(e) => {
                            f.debug_tuple("TtsError::TextTooLong").field(e).finish()
                        }
                        TtsError::InvalidSsml(e) => {
                            f.debug_tuple("TtsError::InvalidSsml").field(e).finish()
                        }
                        TtsError::UnsupportedLanguage(e) => {
                            f.debug_tuple("TtsError::UnsupportedLanguage")
                                .field(e)
                                .finish()
                        }
                        TtsError::VoiceNotFound(e) => {
                            f.debug_tuple("TtsError::VoiceNotFound").field(e).finish()
                        }
                        TtsError::ModelNotFound(e) => {
                            f.debug_tuple("TtsError::ModelNotFound").field(e).finish()
                        }
                        TtsError::VoiceUnavailable(e) => {
                            f.debug_tuple("TtsError::VoiceUnavailable").field(e).finish()
                        }
                        TtsError::Unauthorized(e) => {
                            f.debug_tuple("TtsError::Unauthorized").field(e).finish()
                        }
                        TtsError::AccessDenied(e) => {
                            f.debug_tuple("TtsError::AccessDenied").field(e).finish()
                        }
                        TtsError::QuotaExceeded(e) => {
                            f.debug_tuple("TtsError::QuotaExceeded").field(e).finish()
                        }
                        TtsError::RateLimited(e) => {
                            f.debug_tuple("TtsError::RateLimited").field(e).finish()
                        }
                        TtsError::InsufficientCredits => {
                            f.debug_tuple("TtsError::InsufficientCredits").finish()
                        }
                        TtsError::SynthesisFailed(e) => {
                            f.debug_tuple("TtsError::SynthesisFailed").field(e).finish()
                        }
                        TtsError::UnsupportedOperation(e) => {
                            f.debug_tuple("TtsError::UnsupportedOperation")
                                .field(e)
                                .finish()
                        }
                        TtsError::InvalidConfiguration(e) => {
                            f.debug_tuple("TtsError::InvalidConfiguration")
                                .field(e)
                                .finish()
                        }
                        TtsError::ServiceUnavailable(e) => {
                            f.debug_tuple("TtsError::ServiceUnavailable")
                                .field(e)
                                .finish()
                        }
                        TtsError::NetworkError(e) => {
                            f.debug_tuple("TtsError::NetworkError").field(e).finish()
                        }
                        TtsError::InternalError(e) => {
                            f.debug_tuple("TtsError::InternalError").field(e).finish()
                        }
                        TtsError::InvalidStorageLocation(e) => {
                            f.debug_tuple("TtsError::InvalidStorageLocation")
                                .field(e)
                                .finish()
                        }
                        TtsError::StorageAccessDenied(e) => {
                            f.debug_tuple("TtsError::StorageAccessDenied")
                                .field(e)
                                .finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for TtsError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for TtsError {}
            /// Language identification using BCP 47 codes
            pub type LanguageCode = _rt::String;
            /// Voice gender classification
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum VoiceGender {
                Male,
                Female,
                Neutral,
            }
            impl ::core::fmt::Debug for VoiceGender {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        VoiceGender::Male => f.debug_tuple("VoiceGender::Male").finish(),
                        VoiceGender::Female => {
                            f.debug_tuple("VoiceGender::Female").finish()
                        }
                        VoiceGender::Neutral => {
                            f.debug_tuple("VoiceGender::Neutral").finish()
                        }
                    }
                }
            }
            impl VoiceGender {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> VoiceGender {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => VoiceGender::Male,
                        1 => VoiceGender::Female,
                        2 => VoiceGender::Neutral,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Voice quality tiers
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum VoiceQuality {
                Standard,
                Premium,
                Neural,
                Studio,
            }
            impl ::core::fmt::Debug for VoiceQuality {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        VoiceQuality::Standard => {
                            f.debug_tuple("VoiceQuality::Standard").finish()
                        }
                        VoiceQuality::Premium => {
                            f.debug_tuple("VoiceQuality::Premium").finish()
                        }
                        VoiceQuality::Neural => {
                            f.debug_tuple("VoiceQuality::Neural").finish()
                        }
                        VoiceQuality::Studio => {
                            f.debug_tuple("VoiceQuality::Studio").finish()
                        }
                    }
                }
            }
            impl VoiceQuality {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> VoiceQuality {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => VoiceQuality::Standard,
                        1 => VoiceQuality::Premium,
                        2 => VoiceQuality::Neural,
                        3 => VoiceQuality::Studio,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Text input types
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum TextType {
                Plain,
                Ssml,
            }
            impl ::core::fmt::Debug for TextType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TextType::Plain => f.debug_tuple("TextType::Plain").finish(),
                        TextType::Ssml => f.debug_tuple("TextType::Ssml").finish(),
                    }
                }
            }
            impl TextType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> TextType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => TextType::Plain,
                        1 => TextType::Ssml,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Audio output formats
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum AudioFormat {
                Mp3,
                Wav,
                Pcm,
                OggOpus,
                Aac,
                Flac,
                Mulaw,
                Alaw,
            }
            impl ::core::fmt::Debug for AudioFormat {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AudioFormat::Mp3 => f.debug_tuple("AudioFormat::Mp3").finish(),
                        AudioFormat::Wav => f.debug_tuple("AudioFormat::Wav").finish(),
                        AudioFormat::Pcm => f.debug_tuple("AudioFormat::Pcm").finish(),
                        AudioFormat::OggOpus => {
                            f.debug_tuple("AudioFormat::OggOpus").finish()
                        }
                        AudioFormat::Aac => f.debug_tuple("AudioFormat::Aac").finish(),
                        AudioFormat::Flac => f.debug_tuple("AudioFormat::Flac").finish(),
                        AudioFormat::Mulaw => {
                            f.debug_tuple("AudioFormat::Mulaw").finish()
                        }
                        AudioFormat::Alaw => f.debug_tuple("AudioFormat::Alaw").finish(),
                    }
                }
            }
            impl AudioFormat {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> AudioFormat {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => AudioFormat::Mp3,
                        1 => AudioFormat::Wav,
                        2 => AudioFormat::Pcm,
                        3 => AudioFormat::OggOpus,
                        4 => AudioFormat::Aac,
                        5 => AudioFormat::Flac,
                        6 => AudioFormat::Mulaw,
                        7 => AudioFormat::Alaw,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Audio quality settings
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct AudioConfig {
                pub format: AudioFormat,
                pub sample_rate: Option<u32>,
                pub bit_rate: Option<u32>,
                pub channels: Option<u8>,
            }
            impl ::core::fmt::Debug for AudioConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AudioConfig")
                        .field("format", &self.format)
                        .field("sample-rate", &self.sample_rate)
                        .field("bit-rate", &self.bit_rate)
                        .field("channels", &self.channels)
                        .finish()
                }
            }
            /// Voice synthesis parameters
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct VoiceSettings {
                /// Speaking rate (0.25 to 4.0, default 1.0)
                pub speed: Option<f32>,
                /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)
                pub pitch: Option<f32>,
                /// Volume gain in dB (-96.0 to 16.0, default 0.0)
                pub volume: Option<f32>,
                /// Voice stability (0.0 to 1.0, provider-specific)
                pub stability: Option<f32>,
                /// Similarity to original (0.0 to 1.0, provider-specific)
                pub similarity: Option<f32>,
                /// Style exaggeration (0.0 to 1.0, provider-specific)
                pub style: Option<f32>,
            }
            impl ::core::fmt::Debug for VoiceSettings {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("VoiceSettings")
                        .field("speed", &self.speed)
                        .field("pitch", &self.pitch)
                        .field("volume", &self.volume)
                        .field("stability", &self.stability)
                        .field("similarity", &self.similarity)
                        .field("style", &self.style)
                        .finish()
                }
            }
            wit_bindgen_rt::bitflags::bitflags! {
                #[doc = " Audio effects and device optimization"] #[derive(PartialEq, Eq,
                PartialOrd, Ord, Hash, Debug, Clone, Copy)] pub struct AudioEffects : u8
                { const TELEPHONE_QUALITY = 1 << 0; const HEADPHONE_OPTIMIZED = 1 << 1;
                const SPEAKER_OPTIMIZED = 1 << 2; const CAR_AUDIO_OPTIMIZED = 1 << 3;
                const NOISE_REDUCTION = 1 << 4; const BASS_BOOST = 1 << 5; const
                TREBLE_BOOST = 1 << 6; }
            }
            /// Input text with metadata
            #[derive(Clone)]
            pub struct TextInput {
                pub content: _rt::String,
                pub text_type: TextType,
                pub language: Option<LanguageCode>,
            }
            impl ::core::fmt::Debug for TextInput {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TextInput")
                        .field("content", &self.content)
                        .field("text-type", &self.text_type)
                        .field("language", &self.language)
                        .finish()
                }
            }
            /// Metadata about synthesized audio
            #[derive(Clone)]
            pub struct SynthesisMetadata {
                pub duration_seconds: f32,
                pub character_count: u32,
                pub word_count: u32,
                pub audio_size_bytes: u32,
                pub request_id: _rt::String,
                pub provider_info: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for SynthesisMetadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SynthesisMetadata")
                        .field("duration-seconds", &self.duration_seconds)
                        .field("character-count", &self.character_count)
                        .field("word-count", &self.word_count)
                        .field("audio-size-bytes", &self.audio_size_bytes)
                        .field("request-id", &self.request_id)
                        .field("provider-info", &self.provider_info)
                        .finish()
                }
            }
            /// Complete synthesis result
            #[derive(Clone)]
            pub struct SynthesisResult {
                pub audio_data: _rt::Vec<u8>,
                pub metadata: SynthesisMetadata,
            }
            impl ::core::fmt::Debug for SynthesisResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SynthesisResult")
                        .field("audio-data", &self.audio_data)
                        .field("metadata", &self.metadata)
                        .finish()
                }
            }
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum TimingMarkType {
                Word,
                Sentence,
                Paragraph,
                SsmlMark,
                Viseme,
            }
            impl ::core::fmt::Debug for TimingMarkType {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TimingMarkType::Word => {
                            f.debug_tuple("TimingMarkType::Word").finish()
                        }
                        TimingMarkType::Sentence => {
                            f.debug_tuple("TimingMarkType::Sentence").finish()
                        }
                        TimingMarkType::Paragraph => {
                            f.debug_tuple("TimingMarkType::Paragraph").finish()
                        }
                        TimingMarkType::SsmlMark => {
                            f.debug_tuple("TimingMarkType::SsmlMark").finish()
                        }
                        TimingMarkType::Viseme => {
                            f.debug_tuple("TimingMarkType::Viseme").finish()
                        }
                    }
                }
            }
            impl TimingMarkType {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> TimingMarkType {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => TimingMarkType::Word,
                        1 => TimingMarkType::Sentence,
                        2 => TimingMarkType::Paragraph,
                        3 => TimingMarkType::SsmlMark,
                        4 => TimingMarkType::Viseme,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Timing and synchronization information
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct TimingInfo {
                pub start_time_seconds: f32,
                pub end_time_seconds: Option<f32>,
                pub text_offset: Option<u32>,
                pub mark_type: Option<TimingMarkType>,
            }
            impl ::core::fmt::Debug for TimingInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("TimingInfo")
                        .field("start-time-seconds", &self.start_time_seconds)
                        .field("end-time-seconds", &self.end_time_seconds)
                        .field("text-offset", &self.text_offset)
                        .field("mark-type", &self.mark_type)
                        .finish()
                }
            }
            /// Streaming audio chunk
            #[derive(Clone)]
            pub struct AudioChunk {
                pub data: _rt::Vec<u8>,
                pub sequence_number: u32,
                pub is_final: bool,
                pub timing_info: Option<TimingInfo>,
            }
            impl ::core::fmt::Debug for AudioChunk {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("AudioChunk")
                        .field("data", &self.data)
                        .field("sequence-number", &self.sequence_number)
                        .field("is-final", &self.is_final)
                        .field("timing-info", &self.timing_info)
                        .finish()
                }
            }
        }
    }
}
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod golem {
        pub mod tts {
            /// Voice discovery and management
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod voices {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TtsError = super::super::super::super::golem::tts::types::TtsError;
                pub type LanguageCode = super::super::super::super::golem::tts::types::LanguageCode;
                pub type VoiceGender = super::super::super::super::golem::tts::types::VoiceGender;
                pub type VoiceQuality = super::super::super::super::golem::tts::types::VoiceQuality;
                pub type VoiceSettings = super::super::super::super::golem::tts::types::VoiceSettings;
                pub type AudioFormat = super::super::super::super::golem::tts::types::AudioFormat;
                /// Represents a voice that can be used for speech synthesis
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Voice {
                    handle: _rt::Resource<Voice>,
                }
                type _VoiceRep<T> = Option<T>;
                impl Voice {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Voice`.
                    pub fn new<T: GuestVoice>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceRep<T> = Some(val);
                        let ptr: *mut _VoiceRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoice>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoice>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoice>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _VoiceRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestVoice>(&self) -> *mut _VoiceRep<T> {
                        Voice::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Voice`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Voice>,
                }
                impl<'a> VoiceBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoice>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceRep<T> {
                        Voice::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Voice {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]voice"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                /// Voice search and filtering
                #[derive(Clone)]
                pub struct VoiceFilter {
                    pub language: Option<LanguageCode>,
                    pub gender: Option<VoiceGender>,
                    pub quality: Option<VoiceQuality>,
                    pub supports_ssml: Option<bool>,
                    pub provider: Option<_rt::String>,
                    pub search_query: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceFilter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceFilter")
                            .field("language", &self.language)
                            .field("gender", &self.gender)
                            .field("quality", &self.quality)
                            .field("supports-ssml", &self.supports_ssml)
                            .field("provider", &self.provider)
                            .field("search-query", &self.search_query)
                            .finish()
                    }
                }
                /// Detailed voice information
                #[derive(Clone)]
                pub struct VoiceInfo {
                    pub id: _rt::String,
                    pub name: _rt::String,
                    pub language: LanguageCode,
                    pub additional_languages: _rt::Vec<LanguageCode>,
                    pub gender: VoiceGender,
                    pub quality: VoiceQuality,
                    pub description: Option<_rt::String>,
                    pub provider: _rt::String,
                    pub sample_rate: u32,
                    pub is_custom: bool,
                    pub is_cloned: bool,
                    pub preview_url: Option<_rt::String>,
                    pub use_cases: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceInfo")
                            .field("id", &self.id)
                            .field("name", &self.name)
                            .field("language", &self.language)
                            .field("additional-languages", &self.additional_languages)
                            .field("gender", &self.gender)
                            .field("quality", &self.quality)
                            .field("description", &self.description)
                            .field("provider", &self.provider)
                            .field("sample-rate", &self.sample_rate)
                            .field("is-custom", &self.is_custom)
                            .field("is-cloned", &self.is_cloned)
                            .field("preview-url", &self.preview_url)
                            .field("use-cases", &self.use_cases)
                            .finish()
                    }
                }
                /// Resource-based iterator for voice results
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceResults {
                    handle: _rt::Resource<VoiceResults>,
                }
                type _VoiceResultsRep<T> = Option<T>;
                impl VoiceResults {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `VoiceResults`.
                    pub fn new<T: GuestVoiceResults>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceResultsRep<T> = Some(val);
                        let ptr: *mut _VoiceResultsRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoiceResults>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoiceResults>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoiceResults>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _VoiceResultsRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestVoiceResults>(&self) -> *mut _VoiceResultsRep<T> {
                        VoiceResults::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`VoiceResults`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceResultsBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a VoiceResults>,
                }
                impl<'a> VoiceResultsBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoiceResults>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceResultsRep<T> {
                        VoiceResults::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for VoiceResults {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]voice-results"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[derive(Clone)]
                pub struct LanguageInfo {
                    pub code: LanguageCode,
                    pub name: _rt::String,
                    pub native_name: _rt::String,
                    pub voice_count: u32,
                }
                impl ::core::fmt::Debug for LanguageInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LanguageInfo")
                            .field("code", &self.code)
                            .field("name", &self.name)
                            .field("native-name", &self.native_name)
                            .field("voice-count", &self.voice_count)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_id_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_id(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_id<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_name_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_name(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_name<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_provider_id_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_provider_id(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_provider_id<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_language_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_language(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_language<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_additional_languages_cabi<
                    T: GuestVoice,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_additional_languages(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec3 = result0;
                    let len3 = vec3.len();
                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec3.len() * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result3 = if layout3.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = result3;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_additional_languages<
                    T: GuestVoice,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base4 = l0;
                    let len4 = l1;
                    for i in 0..len4 {
                        let base = base4
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                        }
                    }
                    _rt::cabi_dealloc(
                        base4,
                        len4 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_gender_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_gender(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_quality_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_quality(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_description_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_description(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_description<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l2 = *arg0
                                .add(2 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_supports_ssml_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::supports_ssml(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_sample_rates_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_sample_rates(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_sample_rates<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 4, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_supported_formats_cabi<
                    T: GuestVoice,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_supported_formats(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec2.len() * 1,
                        1,
                    );
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 1);
                        {
                            *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                        }
                    }
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_supported_formats<
                    T: GuestVoice,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_update_settings_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                    arg1: i32,
                    arg2: f32,
                    arg3: i32,
                    arg4: f32,
                    arg5: i32,
                    arg6: f32,
                    arg7: i32,
                    arg8: f32,
                    arg9: i32,
                    arg10: f32,
                    arg11: i32,
                    arg12: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::update_settings(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                        super::super::super::super::golem::tts::types::VoiceSettings {
                            speed: match arg1 {
                                0 => None,
                                1 => {
                                    let e = arg2;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            pitch: match arg3 {
                                0 => None,
                                1 => {
                                    let e = arg4;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            volume: match arg5 {
                                0 => None,
                                1 => {
                                    let e = arg6;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            stability: match arg7 {
                                0 => None,
                                1 => {
                                    let e = arg8;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            similarity: match arg9 {
                                0 => None,
                                1 => {
                                    let e = arg10;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            style: match arg11 {
                                0 => None,
                                1 => {
                                    let e = arg12;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_update_settings<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_delete_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::delete(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_delete<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_clone_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::clone(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr1.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_clone<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_preview_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result1 = T::preview(
                        unsafe { VoiceBorrow::lift(arg0 as u32 as usize) }.get(),
                        _rt::string_lift(bytes0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_preview<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_has_more_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::has_more(
                        unsafe { VoiceResultsBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_get_next_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_next(
                        unsafe { VoiceResultsBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec13 = e;
                            let len13 = vec13.len();
                            let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec13.len()
                                    * (8 + 19 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result13 = if layout13.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout13);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec13.into_iter().enumerate() {
                                let base = result13
                                    .add(i * (8 + 19 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let VoiceInfo {
                                        id: id2,
                                        name: name2,
                                        language: language2,
                                        additional_languages: additional_languages2,
                                        gender: gender2,
                                        quality: quality2,
                                        description: description2,
                                        provider: provider2,
                                        sample_rate: sample_rate2,
                                        is_custom: is_custom2,
                                        is_cloned: is_cloned2,
                                        preview_url: preview_url2,
                                        use_cases: use_cases2,
                                    } = e;
                                    let vec3 = (id2.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                    let vec4 = (name2.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = (language2.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec7 = additional_languages2;
                                    let len7 = vec7.len();
                                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec7.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result7 = if layout7.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout7);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec7.into_iter().enumerate() {
                                        let base = result7
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec6 = (e.into_bytes()).into_boxed_slice();
                                            let ptr6 = vec6.as_ptr().cast::<u8>();
                                            let len6 = vec6.len();
                                            ::core::mem::forget(vec6);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len6;
                                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result7;
                                    *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (gender2.clone() as i32) as u8;
                                    *base
                                        .add(1 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (quality2.clone() as i32) as u8;
                                    match description2 {
                                        Some(e) => {
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec8 = (e.into_bytes()).into_boxed_slice();
                                            let ptr8 = vec8.as_ptr().cast::<u8>();
                                            let len8 = vec8.len();
                                            ::core::mem::forget(vec8);
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len8;
                                            *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr8.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec9 = (provider2.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr9.cast_mut();
                                    *base
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(sample_rate2);
                                    *base
                                        .add(4 + 14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_custom2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base
                                        .add(5 + 14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_cloned2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match preview_url2 {
                                        Some(e) => {
                                            *base
                                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec10 = (e.into_bytes()).into_boxed_slice();
                                            let ptr10 = vec10.as_ptr().cast::<u8>();
                                            let len10 = vec10.len();
                                            ::core::mem::forget(vec10);
                                            *base
                                                .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len10;
                                            *base
                                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr10.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec12 = use_cases2;
                                    let len12 = vec12.len();
                                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec12.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result12 = if layout12.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout12);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec12.into_iter().enumerate() {
                                        let base = result12
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec11 = (e.into_bytes()).into_boxed_slice();
                                            let ptr11 = vec11.as_ptr().cast::<u8>();
                                            let len11 = vec11.len();
                                            ::core::mem::forget(vec11);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len11;
                                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *base
                                        .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result12;
                                }
                            }
                            *ptr1
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len13;
                            *ptr1.add(8).cast::<*mut u8>() = result13;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V31;
                            match e {
                                V31::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V31::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V31::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V31::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V31::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V31::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V31::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V31::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V31::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used22,
                                        limit: limit22,
                                        reset_time: reset_time22,
                                        unit: unit22,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used22);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit22);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time22);
                                    *ptr1.add(32).cast::<u8>() = (unit22.clone() as i32) as u8;
                                }
                                V31::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V31::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V31::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V31::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V31::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len26;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V31::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V31::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len28;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V31::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len29;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V31::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len30;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_results_get_next<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base27 = l1;
                            let len27 = l2;
                            for i in 0..len27 {
                                let base = base27
                                    .add(i * (8 + 19 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                    let l9 = *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base13 = l9;
                                    let len13 = l10;
                                    for i in 0..len13 {
                                        let base = base13
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l11 = *base.add(0).cast::<*mut u8>();
                                            let l12 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l11, l12, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base13,
                                        len13 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let l14 = i32::from(
                                        *base
                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l14 {
                                        0 => {}
                                        _ => {
                                            let l15 = *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l16 = *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l15, l16, 1);
                                        }
                                    }
                                    let l17 = *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l18 = *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                    let l19 = i32::from(
                                        *base
                                            .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l19 {
                                        0 => {}
                                        _ => {
                                            let l20 = *base
                                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l21 = *base
                                                .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l20, l21, 1);
                                        }
                                    }
                                    let l22 = *base
                                        .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l23 = *base
                                        .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base26 = l22;
                                    let len26 = l23;
                                    for i in 0..len26 {
                                        let base = base26
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l24 = *base.add(0).cast::<*mut u8>();
                                            let l25 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l24, l25, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base26,
                                        len26 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                            _rt::cabi_dealloc(
                                base27,
                                len27 * (8 + 19 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l28 = i32::from(*arg0.add(8).cast::<u8>());
                            match l28 {
                                0 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                1 => {}
                                2 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                3 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                4 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                5 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                6 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                7 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                8 => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l45 = *arg0.add(16).cast::<*mut u8>();
                                    let l46 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l45, l46, 1);
                                }
                                13 => {
                                    let l47 = *arg0.add(16).cast::<*mut u8>();
                                    let l48 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l47, l48, 1);
                                }
                                14 => {
                                    let l49 = *arg0.add(16).cast::<*mut u8>();
                                    let l50 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l49, l50, 1);
                                }
                                15 => {
                                    let l51 = *arg0.add(16).cast::<*mut u8>();
                                    let l52 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l51, l52, 1);
                                }
                                16 => {
                                    let l53 = *arg0.add(16).cast::<*mut u8>();
                                    let l54 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l53, l54, 1);
                                }
                                17 => {
                                    let l55 = *arg0.add(16).cast::<*mut u8>();
                                    let l56 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l55, l56, 1);
                                }
                                18 => {
                                    let l57 = *arg0.add(16).cast::<*mut u8>();
                                    let l58 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l57, l58, 1);
                                }
                                _ => {
                                    let l59 = *arg0.add(16).cast::<*mut u8>();
                                    let l60 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l59, l60, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_get_total_count_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_total_count(
                        unsafe { VoiceResultsBorrow::lift(arg0 as u32 as usize) }.get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(4).cast::<i32>() = _rt::as_i32(e);
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_list_voices_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: *mut u8,
                    arg12: usize,
                    arg13: i32,
                    arg14: *mut u8,
                    arg15: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result3 = T::list_voices(
                        match arg0 {
                            0 => None,
                            1 => {
                                let e = VoiceFilter {
                                    language: match arg1 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len0 = arg3;
                                                let bytes0 = _rt::Vec::from_raw_parts(
                                                    arg2.cast(),
                                                    len0,
                                                    len0,
                                                );
                                                _rt::string_lift(bytes0)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    gender: match arg4 {
                                        0 => None,
                                        1 => {
                                            let e = super::super::super::super::golem::tts::types::VoiceGender::_lift(
                                                arg5 as u8,
                                            );
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    quality: match arg6 {
                                        0 => None,
                                        1 => {
                                            let e = super::super::super::super::golem::tts::types::VoiceQuality::_lift(
                                                arg7 as u8,
                                            );
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    supports_ssml: match arg8 {
                                        0 => None,
                                        1 => {
                                            let e = _rt::bool_lift(arg9 as u8);
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    provider: match arg10 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len1 = arg12;
                                                let bytes1 = _rt::Vec::from_raw_parts(
                                                    arg11.cast(),
                                                    len1,
                                                    len1,
                                                );
                                                _rt::string_lift(bytes1)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    search_query: match arg13 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len2 = arg15;
                                                let bytes2 = _rt::Vec::from_raw_parts(
                                                    arg14.cast(),
                                                    len2,
                                                    len2,
                                                );
                                                _rt::string_lift(bytes2)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr4.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr4.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr4.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr4.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr4.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr4.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr4.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr4.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr4.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr4.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr4.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr4.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr4.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_list_voices<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::get_voice(_rt::string_lift(bytes0));
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr2.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_search_voices_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = i32::from(
                        *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result22 = T::search_voices(
                        _rt::string_lift(bytes2),
                        match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = i32::from(
                                        *arg0
                                            .add(3 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l8 = i32::from(
                                        *arg0
                                            .add(6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l10 = i32::from(
                                        *arg0
                                            .add(2 + 6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l12 = i32::from(
                                        *arg0
                                            .add(4 + 6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l14 = i32::from(
                                        *arg0
                                            .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l18 = i32::from(
                                        *arg0
                                            .add(8 + 9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    VoiceFilter {
                                        language: match l4 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l5 = *arg0
                                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l6 = *arg0
                                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len7 = l6;
                                                    let bytes7 = _rt::Vec::from_raw_parts(
                                                        l5.cast(),
                                                        len7,
                                                        len7,
                                                    );
                                                    _rt::string_lift(bytes7)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        gender: match l8 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l9 = i32::from(
                                                        *arg0
                                                            .add(1 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceGender::_lift(
                                                        l9 as u8,
                                                    )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        quality: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(
                                                        *arg0
                                                            .add(3 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceQuality::_lift(
                                                        l11 as u8,
                                                    )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        supports_ssml: match l12 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l13 = i32::from(
                                                        *arg0
                                                            .add(5 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l13 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        provider: match l14 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l15 = *arg0
                                                        .add(8 + 7 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l16 = *arg0
                                                        .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len17 = l16;
                                                    let bytes17 = _rt::Vec::from_raw_parts(
                                                        l15.cast(),
                                                        len17,
                                                        len17,
                                                    );
                                                    _rt::string_lift(bytes17)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        search_query: match l18 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l19 = *arg0
                                                        .add(8 + 10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l20 = *arg0
                                                        .add(8 + 11 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len21 = l20;
                                                    let bytes21 = _rt::Vec::from_raw_parts(
                                                        l19.cast(),
                                                        len21,
                                                        len21,
                                                    );
                                                    _rt::string_lift(bytes21)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        8 + 12 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr23 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result22 {
                        Ok(e) => {
                            *ptr23.add(0).cast::<u8>() = (0i32) as u8;
                            let vec35 = e;
                            let len35 = vec35.len();
                            let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec35.len()
                                    * (8 + 19 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result35 = if layout35.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout35);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec35.into_iter().enumerate() {
                                let base = result35
                                    .add(i * (8 + 19 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let VoiceInfo {
                                        id: id24,
                                        name: name24,
                                        language: language24,
                                        additional_languages: additional_languages24,
                                        gender: gender24,
                                        quality: quality24,
                                        description: description24,
                                        provider: provider24,
                                        sample_rate: sample_rate24,
                                        is_custom: is_custom24,
                                        is_cloned: is_cloned24,
                                        preview_url: preview_url24,
                                        use_cases: use_cases24,
                                    } = e;
                                    let vec25 = (id24.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *base.add(0).cast::<*mut u8>() = ptr25.cast_mut();
                                    let vec26 = (name24.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len26;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr26.cast_mut();
                                    let vec27 = (language24.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr27.cast_mut();
                                    let vec29 = additional_languages24;
                                    let len29 = vec29.len();
                                    let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec29.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result29 = if layout29.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout29);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec29.into_iter().enumerate() {
                                        let base = result29
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec28 = (e.into_bytes()).into_boxed_slice();
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            ::core::mem::forget(vec28);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len28;
                                            *base.add(0).cast::<*mut u8>() = ptr28.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len29;
                                    *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result29;
                                    *base
                                        .add(8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (gender24.clone() as i32) as u8;
                                    *base
                                        .add(1 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (quality24.clone() as i32) as u8;
                                    match description24 {
                                        Some(e) => {
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec30 = (e.into_bytes()).into_boxed_slice();
                                            let ptr30 = vec30.as_ptr().cast::<u8>();
                                            let len30 = vec30.len();
                                            ::core::mem::forget(vec30);
                                            *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len30;
                                            *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr30.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(9 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec31 = (provider24.into_bytes()).into_boxed_slice();
                                    let ptr31 = vec31.as_ptr().cast::<u8>();
                                    let len31 = vec31.len();
                                    ::core::mem::forget(vec31);
                                    *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len31;
                                    *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr31.cast_mut();
                                    *base
                                        .add(14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(sample_rate24);
                                    *base
                                        .add(4 + 14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_custom24 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base
                                        .add(5 + 14 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_cloned24 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match preview_url24 {
                                        Some(e) => {
                                            *base
                                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec32 = (e.into_bytes()).into_boxed_slice();
                                            let ptr32 = vec32.as_ptr().cast::<u8>();
                                            let len32 = vec32.len();
                                            ::core::mem::forget(vec32);
                                            *base
                                                .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len32;
                                            *base
                                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr32.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec34 = use_cases24;
                                    let len34 = vec34.len();
                                    let layout34 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec34.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let result34 = if layout34.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout34).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout34);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec34.into_iter().enumerate() {
                                        let base = result34
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let vec33 = (e.into_bytes()).into_boxed_slice();
                                            let ptr33 = vec33.as_ptr().cast::<u8>();
                                            let len33 = vec33.len();
                                            ::core::mem::forget(vec33);
                                            *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len33;
                                            *base.add(0).cast::<*mut u8>() = ptr33.cast_mut();
                                        }
                                    }
                                    *base
                                        .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len34;
                                    *base
                                        .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = result34;
                                }
                            }
                            *ptr23
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len35;
                            *ptr23.add(8).cast::<*mut u8>() = result35;
                        }
                        Err(e) => {
                            *ptr23.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V53;
                            match e {
                                V53::InvalidText(e) => {
                                    *ptr23.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec36 = (e.into_bytes()).into_boxed_slice();
                                    let ptr36 = vec36.as_ptr().cast::<u8>();
                                    let len36 = vec36.len();
                                    ::core::mem::forget(vec36);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len36;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr36.cast_mut();
                                }
                                V53::TextTooLong(e) => {
                                    *ptr23.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V53::InvalidSsml(e) => {
                                    *ptr23.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec37 = (e.into_bytes()).into_boxed_slice();
                                    let ptr37 = vec37.as_ptr().cast::<u8>();
                                    let len37 = vec37.len();
                                    ::core::mem::forget(vec37);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len37;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr37.cast_mut();
                                }
                                V53::UnsupportedLanguage(e) => {
                                    *ptr23.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec38 = (e.into_bytes()).into_boxed_slice();
                                    let ptr38 = vec38.as_ptr().cast::<u8>();
                                    let len38 = vec38.len();
                                    ::core::mem::forget(vec38);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len38;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr38.cast_mut();
                                }
                                V53::VoiceNotFound(e) => {
                                    *ptr23.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec39 = (e.into_bytes()).into_boxed_slice();
                                    let ptr39 = vec39.as_ptr().cast::<u8>();
                                    let len39 = vec39.len();
                                    ::core::mem::forget(vec39);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len39;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr39.cast_mut();
                                }
                                V53::ModelNotFound(e) => {
                                    *ptr23.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec40 = (e.into_bytes()).into_boxed_slice();
                                    let ptr40 = vec40.as_ptr().cast::<u8>();
                                    let len40 = vec40.len();
                                    ::core::mem::forget(vec40);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len40;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr40.cast_mut();
                                }
                                V53::VoiceUnavailable(e) => {
                                    *ptr23.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec41 = (e.into_bytes()).into_boxed_slice();
                                    let ptr41 = vec41.as_ptr().cast::<u8>();
                                    let len41 = vec41.len();
                                    ::core::mem::forget(vec41);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len41;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr41.cast_mut();
                                }
                                V53::Unauthorized(e) => {
                                    *ptr23.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec42 = (e.into_bytes()).into_boxed_slice();
                                    let ptr42 = vec42.as_ptr().cast::<u8>();
                                    let len42 = vec42.len();
                                    ::core::mem::forget(vec42);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len42;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr42.cast_mut();
                                }
                                V53::AccessDenied(e) => {
                                    *ptr23.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec43 = (e.into_bytes()).into_boxed_slice();
                                    let ptr43 = vec43.as_ptr().cast::<u8>();
                                    let len43 = vec43.len();
                                    ::core::mem::forget(vec43);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len43;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr43.cast_mut();
                                }
                                V53::QuotaExceeded(e) => {
                                    *ptr23.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used44,
                                        limit: limit44,
                                        reset_time: reset_time44,
                                        unit: unit44,
                                    } = e;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(used44);
                                    *ptr23.add(20).cast::<i32>() = _rt::as_i32(limit44);
                                    *ptr23.add(24).cast::<i64>() = _rt::as_i64(reset_time44);
                                    *ptr23.add(32).cast::<u8>() = (unit44.clone() as i32) as u8;
                                }
                                V53::RateLimited(e) => {
                                    *ptr23.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V53::InsufficientCredits => {
                                    *ptr23.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V53::SynthesisFailed(e) => {
                                    *ptr23.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec45 = (e.into_bytes()).into_boxed_slice();
                                    let ptr45 = vec45.as_ptr().cast::<u8>();
                                    let len45 = vec45.len();
                                    ::core::mem::forget(vec45);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len45;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr45.cast_mut();
                                }
                                V53::UnsupportedOperation(e) => {
                                    *ptr23.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec46 = (e.into_bytes()).into_boxed_slice();
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    ::core::mem::forget(vec46);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len46;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr46.cast_mut();
                                }
                                V53::InvalidConfiguration(e) => {
                                    *ptr23.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                    let len47 = vec47.len();
                                    ::core::mem::forget(vec47);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len47;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr47.cast_mut();
                                }
                                V53::ServiceUnavailable(e) => {
                                    *ptr23.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec48 = (e.into_bytes()).into_boxed_slice();
                                    let ptr48 = vec48.as_ptr().cast::<u8>();
                                    let len48 = vec48.len();
                                    ::core::mem::forget(vec48);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len48;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr48.cast_mut();
                                }
                                V53::NetworkError(e) => {
                                    *ptr23.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec49 = (e.into_bytes()).into_boxed_slice();
                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                    let len49 = vec49.len();
                                    ::core::mem::forget(vec49);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len49;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr49.cast_mut();
                                }
                                V53::InternalError(e) => {
                                    *ptr23.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec50 = (e.into_bytes()).into_boxed_slice();
                                    let ptr50 = vec50.as_ptr().cast::<u8>();
                                    let len50 = vec50.len();
                                    ::core::mem::forget(vec50);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len50;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr50.cast_mut();
                                }
                                V53::InvalidStorageLocation(e) => {
                                    *ptr23.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec51 = (e.into_bytes()).into_boxed_slice();
                                    let ptr51 = vec51.as_ptr().cast::<u8>();
                                    let len51 = vec51.len();
                                    ::core::mem::forget(vec51);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len51;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr51.cast_mut();
                                }
                                V53::StorageAccessDenied(e) => {
                                    *ptr23.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec52 = (e.into_bytes()).into_boxed_slice();
                                    let ptr52 = vec52.as_ptr().cast::<u8>();
                                    let len52 = vec52.len();
                                    ::core::mem::forget(vec52);
                                    *ptr23
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len52;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr52.cast_mut();
                                }
                            }
                        }
                    };
                    ptr23
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_search_voices<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base27 = l1;
                            let len27 = l2;
                            for i in 0..len27 {
                                let base = base27
                                    .add(i * (8 + 19 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                    let l9 = *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l10 = *base
                                        .add(7 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base13 = l9;
                                    let len13 = l10;
                                    for i in 0..len13 {
                                        let base = base13
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l11 = *base.add(0).cast::<*mut u8>();
                                            let l12 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l11, l12, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base13,
                                        len13 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    let l14 = i32::from(
                                        *base
                                            .add(9 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l14 {
                                        0 => {}
                                        _ => {
                                            let l15 = *base
                                                .add(10 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l16 = *base
                                                .add(11 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l15, l16, 1);
                                        }
                                    }
                                    let l17 = *base
                                        .add(12 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l18 = *base
                                        .add(13 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                    let l19 = i32::from(
                                        *base
                                            .add(8 + 14 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l19 {
                                        0 => {}
                                        _ => {
                                            let l20 = *base
                                                .add(8 + 15 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l21 = *base
                                                .add(8 + 16 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l20, l21, 1);
                                        }
                                    }
                                    let l22 = *base
                                        .add(8 + 17 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l23 = *base
                                        .add(8 + 18 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base26 = l22;
                                    let len26 = l23;
                                    for i in 0..len26 {
                                        let base = base26
                                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                        {
                                            let l24 = *base.add(0).cast::<*mut u8>();
                                            let l25 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l24, l25, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(
                                        base26,
                                        len26 * (2 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                }
                            }
                            _rt::cabi_dealloc(
                                base27,
                                len27 * (8 + 19 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l28 = i32::from(*arg0.add(8).cast::<u8>());
                            match l28 {
                                0 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                1 => {}
                                2 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                3 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                4 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                5 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                6 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                7 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                8 => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l45 = *arg0.add(16).cast::<*mut u8>();
                                    let l46 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l45, l46, 1);
                                }
                                13 => {
                                    let l47 = *arg0.add(16).cast::<*mut u8>();
                                    let l48 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l47, l48, 1);
                                }
                                14 => {
                                    let l49 = *arg0.add(16).cast::<*mut u8>();
                                    let l50 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l49, l50, 1);
                                }
                                15 => {
                                    let l51 = *arg0.add(16).cast::<*mut u8>();
                                    let l52 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l51, l52, 1);
                                }
                                16 => {
                                    let l53 = *arg0.add(16).cast::<*mut u8>();
                                    let l54 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l53, l54, 1);
                                }
                                17 => {
                                    let l55 = *arg0.add(16).cast::<*mut u8>();
                                    let l56 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l55, l56, 1);
                                }
                                18 => {
                                    let l57 = *arg0.add(16).cast::<*mut u8>();
                                    let l58 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l57, l58, 1);
                                }
                                _ => {
                                    let l59 = *arg0.add(16).cast::<*mut u8>();
                                    let l60 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l59, l60, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_list_languages_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::list_languages();
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec6 = e;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * (7 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6
                                    .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let LanguageInfo {
                                        code: code2,
                                        name: name2,
                                        native_name: native_name2,
                                        voice_count: voice_count2,
                                    } = e;
                                    let vec3 = (code2.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                    let vec4 = (name2.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = (native_name2.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr5.cast_mut();
                                    *base
                                        .add(6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(voice_count2);
                                }
                            }
                            *ptr1
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr1.add(8).cast::<*mut u8>() = result6;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V24;
                            match e {
                                V24::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V24::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V24::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V24::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V24::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V24::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V24::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V24::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V24::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V24::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used15,
                                        limit: limit15,
                                        reset_time: reset_time15,
                                        unit: unit15,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used15);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit15);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time15);
                                    *ptr1.add(32).cast::<u8>() = (unit15.clone() as i32) as u8;
                                }
                                V24::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V24::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V24::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V24::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V24::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V24::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V24::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V24::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V24::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V24::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_list_languages<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base9 = l1;
                            let len9 = l2;
                            for i in 0..len9 {
                                let base = base9
                                    .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l6 = *base
                                        .add(3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base
                                        .add(4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *base
                                        .add(5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base9,
                                len9 * (7 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l10 = i32::from(*arg0.add(8).cast::<u8>());
                            match l10 {
                                0 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                1 => {}
                                2 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                3 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                4 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                5 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                6 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                7 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                8 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                13 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                14 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                15 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                16 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                17 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                18 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                _ => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    type Voice: GuestVoice;
                    type VoiceResults: GuestVoiceResults;
                    /// List available voices with filtering and pagination
                    fn list_voices(
                        filter: Option<VoiceFilter>,
                    ) -> Result<VoiceResults, TtsError>;
                    /// Get specific voice by ID
                    fn get_voice(voice_id: _rt::String) -> Result<Voice, TtsError>;
                    /// Search voices by characteristics
                    fn search_voices(
                        query: _rt::String,
                        filter: Option<VoiceFilter>,
                    ) -> Result<_rt::Vec<VoiceInfo>, TtsError>;
                    /// Get supported languages
                    fn list_languages() -> Result<_rt::Vec<LanguageInfo>, TtsError>;
                }
                pub trait GuestVoice: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]voice"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]voice"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Get voice identification
                    fn get_id(&self) -> _rt::String;
                    fn get_name(&self) -> _rt::String;
                    fn get_provider_id(&self) -> Option<_rt::String>;
                    /// Get voice characteristics
                    fn get_language(&self) -> LanguageCode;
                    fn get_additional_languages(&self) -> _rt::Vec<LanguageCode>;
                    fn get_gender(&self) -> VoiceGender;
                    fn get_quality(&self) -> VoiceQuality;
                    fn get_description(&self) -> Option<_rt::String>;
                    /// Voice capabilities
                    fn supports_ssml(&self) -> bool;
                    fn get_sample_rates(&self) -> _rt::Vec<u32>;
                    fn get_supported_formats(&self) -> _rt::Vec<AudioFormat>;
                    /// Voice management (may return unsupported-operation)
                    fn update_settings(
                        &self,
                        settings: VoiceSettings,
                    ) -> Result<(), TtsError>;
                    fn delete(&self) -> Result<(), TtsError>;
                    fn clone(&self) -> Result<Voice, TtsError>;
                    /// Preview voice with sample text
                    fn preview(
                        &self,
                        text: _rt::String,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                }
                pub trait GuestVoiceResults: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]voice-results"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]voice-results"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Check if more voices are available
                    fn has_more(&self) -> bool;
                    /// Get next batch of voices
                    fn get_next(&self) -> Result<_rt::Vec<VoiceInfo>, TtsError>;
                    /// Get total count if available
                    fn get_total_count(&self) -> Option<u32>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_voices_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-id")] unsafe extern "C"
                        fn export_method_voice_get_id(arg0 : * mut u8,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_method_voice_get_id_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-id")] unsafe
                        extern "C" fn _post_return_method_voice_get_id(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_id::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-name")] unsafe extern
                        "C" fn export_method_voice_get_name(arg0 : * mut u8,) -> * mut u8
                        { unsafe { $($path_to_types)*::
                        _export_method_voice_get_name_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-name")]
                        unsafe extern "C" fn _post_return_method_voice_get_name(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_name::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-provider-id")] unsafe
                        extern "C" fn export_method_voice_get_provider_id(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_provider_id_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-provider-id")]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_provider_id(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_provider_id::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-language")] unsafe
                        extern "C" fn export_method_voice_get_language(arg0 : * mut u8,)
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_language_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-language")]
                        unsafe extern "C" fn _post_return_method_voice_get_language(arg0
                        : * mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_language::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-additional-languages")]
                        unsafe extern "C" fn
                        export_method_voice_get_additional_languages(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_additional_languages_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-additional-languages")]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_additional_languages(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_additional_languages::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-gender")] unsafe extern
                        "C" fn export_method_voice_get_gender(arg0 : * mut u8,) -> i32 {
                        unsafe { $($path_to_types)*::
                        _export_method_voice_get_gender_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-quality")] unsafe
                        extern "C" fn export_method_voice_get_quality(arg0 : * mut u8,)
                        -> i32 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_quality_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-description")] unsafe
                        extern "C" fn export_method_voice_get_description(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_description_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-description")]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_description(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_description::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.supports-ssml")] unsafe
                        extern "C" fn export_method_voice_supports_ssml(arg0 : * mut u8,)
                        -> i32 { unsafe { $($path_to_types)*::
                        _export_method_voice_supports_ssml_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-sample-rates")] unsafe
                        extern "C" fn export_method_voice_get_sample_rates(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_sample_rates_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-sample-rates")]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_sample_rates(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_sample_rates::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-supported-formats")]
                        unsafe extern "C" fn
                        export_method_voice_get_supported_formats(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_get_supported_formats_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-supported-formats")]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_supported_formats(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_voice_get_supported_formats::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.update-settings")] unsafe
                        extern "C" fn export_method_voice_update_settings(arg0 : * mut
                        u8, arg1 : i32, arg2 : f32, arg3 : i32, arg4 : f32, arg5 : i32,
                        arg6 : f32, arg7 : i32, arg8 : f32, arg9 : i32, arg10 : f32,
                        arg11 : i32, arg12 : f32,) -> * mut u8 { unsafe {
                        $($path_to_types)*::
                        _export_method_voice_update_settings_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.update-settings")]
                        unsafe extern "C" fn
                        _post_return_method_voice_update_settings(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_update_settings::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } } #[unsafe
                        (export_name = "golem:tts/voices@1.0.0#[method]voice.delete")]
                        unsafe extern "C" fn export_method_voice_delete(arg0 : * mut u8,)
                        -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_delete_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.delete")] unsafe
                        extern "C" fn _post_return_method_voice_delete(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_voice_delete::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.clone")] unsafe extern "C"
                        fn export_method_voice_clone(arg0 : * mut u8,) -> * mut u8 {
                        unsafe { $($path_to_types)*::
                        _export_method_voice_clone_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.clone")] unsafe
                        extern "C" fn _post_return_method_voice_clone(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_clone::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[method]voice.preview")] unsafe extern
                        "C" fn export_method_voice_preview(arg0 : * mut u8, arg1 : * mut
                        u8, arg2 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_preview_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0, arg1, arg2) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.preview")] unsafe
                        extern "C" fn _post_return_method_voice_preview(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_voice_preview::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.has-more")] unsafe
                        extern "C" fn export_method_voice_results_has_more(arg0 : * mut
                        u8,) -> i32 { unsafe { $($path_to_types)*::
                        _export_method_voice_results_has_more_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.get-next")] unsafe
                        extern "C" fn export_method_voice_results_get_next(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_results_get_next_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice-results.get-next")]
                        unsafe extern "C" fn
                        _post_return_method_voice_results_get_next(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_voice_results_get_next::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.get-total-count")]
                        unsafe extern "C" fn
                        export_method_voice_results_get_total_count(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_results_get_total_count_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) } } #[unsafe
                        (export_name = "golem:tts/voices@1.0.0#list-voices")] unsafe
                        extern "C" fn export_list_voices(arg0 : i32, arg1 : i32, arg2 : *
                        mut u8, arg3 : usize, arg4 : i32, arg5 : i32, arg6 : i32, arg7 :
                        i32, arg8 : i32, arg9 : i32, arg10 : i32, arg11 : * mut u8, arg12
                        : usize, arg13 : i32, arg14 : * mut u8, arg15 : usize,) -> * mut
                        u8 { unsafe { $($path_to_types)*:: _export_list_voices_cabi::<$ty
                        > (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9,
                        arg10, arg11, arg12, arg13, arg14, arg15) } } #[unsafe
                        (export_name = "cabi_post_golem:tts/voices@1.0.0#list-voices")]
                        unsafe extern "C" fn _post_return_list_voices(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_list_voices::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#get-voice")] unsafe extern "C" fn
                        export_get_voice(arg0 : * mut u8, arg1 : usize,) -> * mut u8 {
                        unsafe { $($path_to_types)*:: _export_get_voice_cabi::<$ty >
                        (arg0, arg1) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#get-voice")] unsafe extern "C"
                        fn _post_return_get_voice(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_get_voice::<$ty > (arg0) } }
                        #[unsafe (export_name = "golem:tts/voices@1.0.0#search-voices")]
                        unsafe extern "C" fn export_search_voices(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_search_voices_cabi::<$ty > (arg0) } } #[unsafe
                        (export_name = "cabi_post_golem:tts/voices@1.0.0#search-voices")]
                        unsafe extern "C" fn _post_return_search_voices(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*:: __post_return_search_voices::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#list-languages")] unsafe extern "C" fn
                        export_list_languages() -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_list_languages_cabi::<$ty > () } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/voices@1.0.0#list-languages")] unsafe extern
                        "C" fn _post_return_list_languages(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_list_languages::<$ty > (arg0)
                        } } const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[dtor]voice")] #[allow(non_snake_case)]
                        unsafe extern "C" fn dtor(rep : * mut u8) { unsafe {
                        $($path_to_types)*:: Voice::dtor::< <$ty as $($path_to_types)*::
                        Guest >::Voice > (rep) } } }; const _ : () = { #[doc(hidden)]
                        #[unsafe (export_name =
                        "golem:tts/voices@1.0.0#[dtor]voice-results")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: VoiceResults::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (rep) } } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_voices_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 40],
                );
            }
            /// Core text-to-speech synthesis operations
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod synthesis {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TextInput = super::super::super::super::golem::tts::types::TextInput;
                pub type AudioConfig = super::super::super::super::golem::tts::types::AudioConfig;
                pub type VoiceSettings = super::super::super::super::golem::tts::types::VoiceSettings;
                pub type AudioEffects = super::super::super::super::golem::tts::types::AudioEffects;
                pub type SynthesisResult = super::super::super::super::golem::tts::types::SynthesisResult;
                pub type TtsError = super::super::super::super::golem::tts::types::TtsError;
                pub type TimingInfo = super::super::super::super::golem::tts::types::TimingInfo;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                /// Context for better synthesis quality
                #[derive(Clone)]
                pub struct SynthesisContext {
                    pub previous_text: Option<_rt::String>,
                    pub next_text: Option<_rt::String>,
                    pub topic: Option<_rt::String>,
                    pub emotion: Option<_rt::String>,
                    pub speaking_style: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for SynthesisContext {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisContext")
                            .field("previous-text", &self.previous_text)
                            .field("next-text", &self.next_text)
                            .field("topic", &self.topic)
                            .field("emotion", &self.emotion)
                            .field("speaking-style", &self.speaking_style)
                            .finish()
                    }
                }
                /// Synthesis configuration options
                #[derive(Clone)]
                pub struct SynthesisOptions {
                    pub audio_config: Option<AudioConfig>,
                    pub voice_settings: Option<VoiceSettings>,
                    pub audio_effects: Option<AudioEffects>,
                    pub enable_timing: Option<bool>,
                    pub enable_word_timing: Option<bool>,
                    pub seed: Option<u32>,
                    pub model_version: Option<_rt::String>,
                    pub context: Option<SynthesisContext>,
                }
                impl ::core::fmt::Debug for SynthesisOptions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisOptions")
                            .field("audio-config", &self.audio_config)
                            .field("voice-settings", &self.voice_settings)
                            .field("audio-effects", &self.audio_effects)
                            .field("enable-timing", &self.enable_timing)
                            .field("enable-word-timing", &self.enable_word_timing)
                            .field("seed", &self.seed)
                            .field("model-version", &self.model_version)
                            .field("context", &self.context)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct ValidationResult {
                    pub is_valid: bool,
                    pub character_count: u32,
                    pub estimated_duration: Option<f32>,
                    pub warnings: _rt::Vec<_rt::String>,
                    pub errors: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for ValidationResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ValidationResult")
                            .field("is-valid", &self.is_valid)
                            .field("character-count", &self.character_count)
                            .field("estimated-duration", &self.estimated_duration)
                            .field("warnings", &self.warnings)
                            .field("errors", &self.errors)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = i32::from(
                        *arg0.add(2 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l4 = i32::from(
                        *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let l8 = *arg0
                        .add(6 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l9 = i32::from(
                        *arg0.add(7 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result64 = T::synthesize(
                        super::super::super::super::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes2),
                            text_type: super::super::super::super::golem::tts::types::TextType::_lift(
                                l3 as u8,
                            ),
                            language: match l4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l5 = *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<*mut u8>();
                                        let l6 = *arg0
                                            .add(5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        unsafe { VoiceBorrow::lift(l8 as u32 as usize) },
                        match l9 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l10 = i32::from(
                                        *arg0
                                            .add(8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l18 = i32::from(
                                        *arg0
                                            .add(28 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l31 = i32::from(
                                        *arg0
                                            .add(80 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l33 = i32::from(
                                        *arg0
                                            .add(82 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l35 = i32::from(
                                        *arg0
                                            .add(84 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l37 = i32::from(
                                        *arg0
                                            .add(88 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l39 = i32::from(
                                        *arg0
                                            .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l43 = i32::from(
                                        *arg0
                                            .add(96 + 11 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    SynthesisOptions {
                                        audio_config: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(
                                                        *arg0
                                                            .add(4 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l12 = i32::from(
                                                        *arg0
                                                            .add(8 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l14 = i32::from(
                                                        *arg0
                                                            .add(16 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l16 = i32::from(
                                                        *arg0
                                                            .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::golem::tts::types::AudioFormat::_lift(
                                                            l11 as u8,
                                                        ),
                                                        sample_rate: match l12 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l13 = *arg0
                                                                        .add(12 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l13 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l14 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l15 = *arg0
                                                                        .add(20 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l15 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l16 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l17 = i32::from(
                                                                        *arg0
                                                                            .add(25 + 8 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>(),
                                                                    );
                                                                    l17 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l18 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l19 = i32::from(
                                                        *arg0
                                                            .add(32 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l21 = i32::from(
                                                        *arg0
                                                            .add(40 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l23 = i32::from(
                                                        *arg0
                                                            .add(48 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l25 = i32::from(
                                                        *arg0
                                                            .add(56 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l27 = i32::from(
                                                        *arg0
                                                            .add(64 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l29 = i32::from(
                                                        *arg0
                                                            .add(72 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceSettings {
                                                        speed: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0
                                                                        .add(36 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0
                                                                        .add(44 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l23 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l24 = *arg0
                                                                        .add(52 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l24
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l25 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l26 = *arg0
                                                                        .add(60 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l26
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l27 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l28 = *arg0
                                                                        .add(68 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l28
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l29 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l30 = *arg0
                                                                        .add(76 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l30
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l31 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l32 = i32::from(
                                                        *arg0
                                                            .add(81 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioEffects::empty()
                                                        | super::super::super::super::golem::tts::types::AudioEffects::from_bits_retain(
                                                            ((l32 as u8) << 0) as _,
                                                        )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l33 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l34 = i32::from(
                                                        *arg0
                                                            .add(83 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l34 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l35 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l36 = i32::from(
                                                        *arg0
                                                            .add(85 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l36 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l37 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l38 = *arg0
                                                        .add(92 + 8 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l38 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l39 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l40 = *arg0
                                                        .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l41 = *arg0
                                                        .add(96 + 10 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len42 = l41;
                                                    let bytes42 = _rt::Vec::from_raw_parts(
                                                        l40.cast(),
                                                        len42,
                                                        len42,
                                                    );
                                                    _rt::string_lift(bytes42)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l43 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l44 = i32::from(
                                                        *arg0
                                                            .add(96 + 12 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l48 = i32::from(
                                                        *arg0
                                                            .add(96 + 15 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l52 = i32::from(
                                                        *arg0
                                                            .add(96 + 18 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l56 = i32::from(
                                                        *arg0
                                                            .add(96 + 21 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l60 = i32::from(
                                                        *arg0
                                                            .add(96 + 24 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    SynthesisContext {
                                                        previous_text: match l44 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l45 = *arg0
                                                                        .add(96 + 13 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l46 = *arg0
                                                                        .add(96 + 14 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len47 = l46;
                                                                    let bytes47 = _rt::Vec::from_raw_parts(
                                                                        l45.cast(),
                                                                        len47,
                                                                        len47,
                                                                    );
                                                                    _rt::string_lift(bytes47)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l48 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l49 = *arg0
                                                                        .add(96 + 16 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l50 = *arg0
                                                                        .add(96 + 17 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len51 = l50;
                                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                                        l49.cast(),
                                                                        len51,
                                                                        len51,
                                                                    );
                                                                    _rt::string_lift(bytes51)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l52 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l53 = *arg0
                                                                        .add(96 + 19 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l54 = *arg0
                                                                        .add(96 + 20 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len55 = l54;
                                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                                        l53.cast(),
                                                                        len55,
                                                                        len55,
                                                                    );
                                                                    _rt::string_lift(bytes55)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l56 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l57 = *arg0
                                                                        .add(96 + 22 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l58 = *arg0
                                                                        .add(96 + 23 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len59 = l58;
                                                                    let bytes59 = _rt::Vec::from_raw_parts(
                                                                        l57.cast(),
                                                                        len59,
                                                                        len59,
                                                                    );
                                                                    _rt::string_lift(bytes59)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l60 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l61 = *arg0
                                                                        .add(96 + 25 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l62 = *arg0
                                                                        .add(96 + 26 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len63 = l62;
                                                                    let bytes63 = _rt::Vec::from_raw_parts(
                                                                        l61.cast(),
                                                                        len63,
                                                                        len63,
                                                                    );
                                                                    _rt::string_lift(bytes63)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        96 + 27 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr65 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result64 {
                        Ok(e) => {
                            *ptr65.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::golem::tts::types::SynthesisResult {
                                audio_data: audio_data66,
                                metadata: metadata66,
                            } = e;
                            let vec67 = (audio_data66).into_boxed_slice();
                            let ptr67 = vec67.as_ptr().cast::<u8>();
                            let len67 = vec67.len();
                            ::core::mem::forget(vec67);
                            *ptr65
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len67;
                            *ptr65.add(8).cast::<*mut u8>() = ptr67.cast_mut();
                            let super::super::super::super::golem::tts::types::SynthesisMetadata {
                                duration_seconds: duration_seconds68,
                                character_count: character_count68,
                                word_count: word_count68,
                                audio_size_bytes: audio_size_bytes68,
                                request_id: request_id68,
                                provider_info: provider_info68,
                            } = metadata66;
                            *ptr65
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<f32>() = _rt::as_f32(duration_seconds68);
                            *ptr65
                                .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(character_count68);
                            *ptr65
                                .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(word_count68);
                            *ptr65
                                .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(audio_size_bytes68);
                            let vec69 = (request_id68.into_bytes()).into_boxed_slice();
                            let ptr69 = vec69.as_ptr().cast::<u8>();
                            let len69 = vec69.len();
                            ::core::mem::forget(vec69);
                            *ptr65
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len69;
                            *ptr65
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr69.cast_mut();
                            match provider_info68 {
                                Some(e) => {
                                    *ptr65
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec70 = (e.into_bytes()).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *ptr65
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len70;
                                    *ptr65
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr70.cast_mut();
                                }
                                None => {
                                    *ptr65
                                        .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr65.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V88;
                            match e {
                                V88::InvalidText(e) => {
                                    *ptr65.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec71 = (e.into_bytes()).into_boxed_slice();
                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                    let len71 = vec71.len();
                                    ::core::mem::forget(vec71);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len71;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr71.cast_mut();
                                }
                                V88::TextTooLong(e) => {
                                    *ptr65.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr65.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V88::InvalidSsml(e) => {
                                    *ptr65.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec72 = (e.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len72;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr72.cast_mut();
                                }
                                V88::UnsupportedLanguage(e) => {
                                    *ptr65.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len73;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                V88::VoiceNotFound(e) => {
                                    *ptr65.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len74;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                                V88::ModelNotFound(e) => {
                                    *ptr65.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len75;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr75.cast_mut();
                                }
                                V88::VoiceUnavailable(e) => {
                                    *ptr65.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec76 = (e.into_bytes()).into_boxed_slice();
                                    let ptr76 = vec76.as_ptr().cast::<u8>();
                                    let len76 = vec76.len();
                                    ::core::mem::forget(vec76);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len76;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr76.cast_mut();
                                }
                                V88::Unauthorized(e) => {
                                    *ptr65.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec77 = (e.into_bytes()).into_boxed_slice();
                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                    let len77 = vec77.len();
                                    ::core::mem::forget(vec77);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len77;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr77.cast_mut();
                                }
                                V88::AccessDenied(e) => {
                                    *ptr65.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec78 = (e.into_bytes()).into_boxed_slice();
                                    let ptr78 = vec78.as_ptr().cast::<u8>();
                                    let len78 = vec78.len();
                                    ::core::mem::forget(vec78);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len78;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr78.cast_mut();
                                }
                                V88::QuotaExceeded(e) => {
                                    *ptr65.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used79,
                                        limit: limit79,
                                        reset_time: reset_time79,
                                        unit: unit79,
                                    } = e;
                                    *ptr65.add(16).cast::<i32>() = _rt::as_i32(used79);
                                    *ptr65.add(20).cast::<i32>() = _rt::as_i32(limit79);
                                    *ptr65.add(24).cast::<i64>() = _rt::as_i64(reset_time79);
                                    *ptr65.add(32).cast::<u8>() = (unit79.clone() as i32) as u8;
                                }
                                V88::RateLimited(e) => {
                                    *ptr65.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr65.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V88::InsufficientCredits => {
                                    *ptr65.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V88::SynthesisFailed(e) => {
                                    *ptr65.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec80 = (e.into_bytes()).into_boxed_slice();
                                    let ptr80 = vec80.as_ptr().cast::<u8>();
                                    let len80 = vec80.len();
                                    ::core::mem::forget(vec80);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len80;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr80.cast_mut();
                                }
                                V88::UnsupportedOperation(e) => {
                                    *ptr65.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec81 = (e.into_bytes()).into_boxed_slice();
                                    let ptr81 = vec81.as_ptr().cast::<u8>();
                                    let len81 = vec81.len();
                                    ::core::mem::forget(vec81);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len81;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr81.cast_mut();
                                }
                                V88::InvalidConfiguration(e) => {
                                    *ptr65.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec82 = (e.into_bytes()).into_boxed_slice();
                                    let ptr82 = vec82.as_ptr().cast::<u8>();
                                    let len82 = vec82.len();
                                    ::core::mem::forget(vec82);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len82;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr82.cast_mut();
                                }
                                V88::ServiceUnavailable(e) => {
                                    *ptr65.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec83 = (e.into_bytes()).into_boxed_slice();
                                    let ptr83 = vec83.as_ptr().cast::<u8>();
                                    let len83 = vec83.len();
                                    ::core::mem::forget(vec83);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len83;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr83.cast_mut();
                                }
                                V88::NetworkError(e) => {
                                    *ptr65.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec84 = (e.into_bytes()).into_boxed_slice();
                                    let ptr84 = vec84.as_ptr().cast::<u8>();
                                    let len84 = vec84.len();
                                    ::core::mem::forget(vec84);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len84;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr84.cast_mut();
                                }
                                V88::InternalError(e) => {
                                    *ptr65.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec85 = (e.into_bytes()).into_boxed_slice();
                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                    let len85 = vec85.len();
                                    ::core::mem::forget(vec85);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len85;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr85.cast_mut();
                                }
                                V88::InvalidStorageLocation(e) => {
                                    *ptr65.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec86 = (e.into_bytes()).into_boxed_slice();
                                    let ptr86 = vec86.as_ptr().cast::<u8>();
                                    let len86 = vec86.len();
                                    ::core::mem::forget(vec86);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len86;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr86.cast_mut();
                                }
                                V88::StorageAccessDenied(e) => {
                                    *ptr65.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec87 = (e.into_bytes()).into_boxed_slice();
                                    let ptr87 = vec87.as_ptr().cast::<u8>();
                                    let len87 = vec87.len();
                                    ::core::mem::forget(vec87);
                                    *ptr65
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len87;
                                    *ptr65.add(16).cast::<*mut u8>() = ptr87.cast_mut();
                                }
                            }
                        }
                    };
                    ptr65
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                            let l4 = *arg0
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l5 = *arg0
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                            let l6 = i32::from(
                                *arg0
                                    .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l6 {
                                0 => {}
                                _ => {
                                    let l7 = *arg0
                                        .add(24 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                        }
                        _ => {
                            let l9 = i32::from(*arg0.add(8).cast::<u8>());
                            match l9 {
                                0 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                1 => {}
                                2 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                3 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                4 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                5 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                6 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                7 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                8 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                13 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                14 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                15 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                16 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                17 => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                                18 => {
                                    let l38 = *arg0.add(16).cast::<*mut u8>();
                                    let l39 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l38, l39, 1);
                                }
                                _ => {
                                    let l40 = *arg0.add(16).cast::<*mut u8>();
                                    let l41 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l40, l41, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_batch_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    let base10 = l0;
                    let len10 = l1;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len4 = l3;
                            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                            let l5 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l6 = i32::from(
                                *base
                                    .add(3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            super::super::super::super::golem::tts::types::TextInput {
                                content: _rt::string_lift(bytes4),
                                text_type: super::super::super::super::golem::tts::types::TextType::_lift(
                                    l5 as u8,
                                ),
                                language: match l6 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l7 = *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l8 = *base
                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                l7.cast(),
                                                len9,
                                                len9,
                                            );
                                            _rt::string_lift(bytes9)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                            }
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (6 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let l11 = *arg0
                        .add(2 * ::core::mem::size_of::<*const u8>())
                        .cast::<i32>();
                    let l12 = i32::from(
                        *arg0.add(3 * ::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result67 = T::synthesize_batch(
                        result10,
                        unsafe { VoiceBorrow::lift(l11 as u32 as usize) },
                        match l12 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l13 = i32::from(
                                        *arg0
                                            .add(4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l21 = i32::from(
                                        *arg0
                                            .add(28 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l34 = i32::from(
                                        *arg0
                                            .add(80 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l36 = i32::from(
                                        *arg0
                                            .add(82 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l38 = i32::from(
                                        *arg0
                                            .add(84 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l40 = i32::from(
                                        *arg0
                                            .add(88 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l42 = i32::from(
                                        *arg0
                                            .add(96 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l46 = i32::from(
                                        *arg0
                                            .add(96 + 7 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    SynthesisOptions {
                                        audio_config: match l13 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l14 = i32::from(
                                                        *arg0
                                                            .add(4 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l15 = i32::from(
                                                        *arg0
                                                            .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l17 = i32::from(
                                                        *arg0
                                                            .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l19 = i32::from(
                                                        *arg0
                                                            .add(24 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::golem::tts::types::AudioFormat::_lift(
                                                            l14 as u8,
                                                        ),
                                                        sample_rate: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0
                                                                        .add(12 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l16 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0
                                                                        .add(20 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l18 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = i32::from(
                                                                        *arg0
                                                                            .add(25 + 4 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>(),
                                                                    );
                                                                    l20 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l21 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l22 = i32::from(
                                                        *arg0
                                                            .add(32 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l24 = i32::from(
                                                        *arg0
                                                            .add(40 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l26 = i32::from(
                                                        *arg0
                                                            .add(48 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l28 = i32::from(
                                                        *arg0
                                                            .add(56 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l30 = i32::from(
                                                        *arg0
                                                            .add(64 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l32 = i32::from(
                                                        *arg0
                                                            .add(72 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceSettings {
                                                        speed: match l22 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l23 = *arg0
                                                                        .add(36 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l23
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l24 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l25 = *arg0
                                                                        .add(44 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l25
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l26 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l27 = *arg0
                                                                        .add(52 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l27
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l28 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l29 = *arg0
                                                                        .add(60 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l29
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l30 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l31 = *arg0
                                                                        .add(68 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l31
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l32 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l33 = *arg0
                                                                        .add(76 + 4 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l33
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l34 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l35 = i32::from(
                                                        *arg0
                                                            .add(81 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioEffects::empty()
                                                        | super::super::super::super::golem::tts::types::AudioEffects::from_bits_retain(
                                                            ((l35 as u8) << 0) as _,
                                                        )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l36 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l37 = i32::from(
                                                        *arg0
                                                            .add(83 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l37 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l38 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l39 = i32::from(
                                                        *arg0
                                                            .add(85 + 4 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l39 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l40 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l41 = *arg0
                                                        .add(92 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l41 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l42 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l43 = *arg0
                                                        .add(96 + 5 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l44 = *arg0
                                                        .add(96 + 6 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len45 = l44;
                                                    let bytes45 = _rt::Vec::from_raw_parts(
                                                        l43.cast(),
                                                        len45,
                                                        len45,
                                                    );
                                                    _rt::string_lift(bytes45)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l46 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l47 = i32::from(
                                                        *arg0
                                                            .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l51 = i32::from(
                                                        *arg0
                                                            .add(96 + 11 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l55 = i32::from(
                                                        *arg0
                                                            .add(96 + 14 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l59 = i32::from(
                                                        *arg0
                                                            .add(96 + 17 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l63 = i32::from(
                                                        *arg0
                                                            .add(96 + 20 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    SynthesisContext {
                                                        previous_text: match l47 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l48 = *arg0
                                                                        .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l49 = *arg0
                                                                        .add(96 + 10 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len50 = l49;
                                                                    let bytes50 = _rt::Vec::from_raw_parts(
                                                                        l48.cast(),
                                                                        len50,
                                                                        len50,
                                                                    );
                                                                    _rt::string_lift(bytes50)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l51 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l52 = *arg0
                                                                        .add(96 + 12 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l53 = *arg0
                                                                        .add(96 + 13 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len54 = l53;
                                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                                        l52.cast(),
                                                                        len54,
                                                                        len54,
                                                                    );
                                                                    _rt::string_lift(bytes54)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l55 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l56 = *arg0
                                                                        .add(96 + 15 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l57 = *arg0
                                                                        .add(96 + 16 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len58 = l57;
                                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                                        l56.cast(),
                                                                        len58,
                                                                        len58,
                                                                    );
                                                                    _rt::string_lift(bytes58)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l59 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l60 = *arg0
                                                                        .add(96 + 18 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l61 = *arg0
                                                                        .add(96 + 19 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len62 = l61;
                                                                    let bytes62 = _rt::Vec::from_raw_parts(
                                                                        l60.cast(),
                                                                        len62,
                                                                        len62,
                                                                    );
                                                                    _rt::string_lift(bytes62)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l63 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l64 = *arg0
                                                                        .add(96 + 21 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l65 = *arg0
                                                                        .add(96 + 22 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len66 = l65;
                                                                    let bytes66 = _rt::Vec::from_raw_parts(
                                                                        l64.cast(),
                                                                        len66,
                                                                        len66,
                                                                    );
                                                                    _rt::string_lift(bytes66)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        96 + 23 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr68 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result67 {
                        Ok(e) => {
                            *ptr68.add(0).cast::<u8>() = (0i32) as u8;
                            let vec74 = e;
                            let len74 = vec74.len();
                            let layout74 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec74.len()
                                    * (16 + 7 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result74 = if layout74.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout74).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout74);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec74.into_iter().enumerate() {
                                let base = result74
                                    .add(i * (16 + 7 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let super::super::super::super::golem::tts::types::SynthesisResult {
                                        audio_data: audio_data69,
                                        metadata: metadata69,
                                    } = e;
                                    let vec70 = (audio_data69).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len70;
                                    *base.add(0).cast::<*mut u8>() = ptr70.cast_mut();
                                    let super::super::super::super::golem::tts::types::SynthesisMetadata {
                                        duration_seconds: duration_seconds71,
                                        character_count: character_count71,
                                        word_count: word_count71,
                                        audio_size_bytes: audio_size_bytes71,
                                        request_id: request_id71,
                                        provider_info: provider_info71,
                                    } = metadata69;
                                    *base
                                        .add(2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<f32>() = _rt::as_f32(duration_seconds71);
                                    *base
                                        .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(character_count71);
                                    *base
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(word_count71);
                                    *base
                                        .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(audio_size_bytes71);
                                    let vec72 = (request_id71.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *base
                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len72;
                                    *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr72.cast_mut();
                                    match provider_info71 {
                                        Some(e) => {
                                            *base
                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let vec73 = (e.into_bytes()).into_boxed_slice();
                                            let ptr73 = vec73.as_ptr().cast::<u8>();
                                            let len73 = vec73.len();
                                            ::core::mem::forget(vec73);
                                            *base
                                                .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>() = len73;
                                            *base
                                                .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>() = ptr73.cast_mut();
                                        }
                                        None => {
                                            *base
                                                .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            *ptr68
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len74;
                            *ptr68.add(8).cast::<*mut u8>() = result74;
                        }
                        Err(e) => {
                            *ptr68.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V92;
                            match e {
                                V92::InvalidText(e) => {
                                    *ptr68.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len75;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr75.cast_mut();
                                }
                                V92::TextTooLong(e) => {
                                    *ptr68.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V92::InvalidSsml(e) => {
                                    *ptr68.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec76 = (e.into_bytes()).into_boxed_slice();
                                    let ptr76 = vec76.as_ptr().cast::<u8>();
                                    let len76 = vec76.len();
                                    ::core::mem::forget(vec76);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len76;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr76.cast_mut();
                                }
                                V92::UnsupportedLanguage(e) => {
                                    *ptr68.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec77 = (e.into_bytes()).into_boxed_slice();
                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                    let len77 = vec77.len();
                                    ::core::mem::forget(vec77);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len77;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr77.cast_mut();
                                }
                                V92::VoiceNotFound(e) => {
                                    *ptr68.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec78 = (e.into_bytes()).into_boxed_slice();
                                    let ptr78 = vec78.as_ptr().cast::<u8>();
                                    let len78 = vec78.len();
                                    ::core::mem::forget(vec78);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len78;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr78.cast_mut();
                                }
                                V92::ModelNotFound(e) => {
                                    *ptr68.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec79 = (e.into_bytes()).into_boxed_slice();
                                    let ptr79 = vec79.as_ptr().cast::<u8>();
                                    let len79 = vec79.len();
                                    ::core::mem::forget(vec79);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len79;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr79.cast_mut();
                                }
                                V92::VoiceUnavailable(e) => {
                                    *ptr68.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec80 = (e.into_bytes()).into_boxed_slice();
                                    let ptr80 = vec80.as_ptr().cast::<u8>();
                                    let len80 = vec80.len();
                                    ::core::mem::forget(vec80);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len80;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr80.cast_mut();
                                }
                                V92::Unauthorized(e) => {
                                    *ptr68.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec81 = (e.into_bytes()).into_boxed_slice();
                                    let ptr81 = vec81.as_ptr().cast::<u8>();
                                    let len81 = vec81.len();
                                    ::core::mem::forget(vec81);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len81;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr81.cast_mut();
                                }
                                V92::AccessDenied(e) => {
                                    *ptr68.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec82 = (e.into_bytes()).into_boxed_slice();
                                    let ptr82 = vec82.as_ptr().cast::<u8>();
                                    let len82 = vec82.len();
                                    ::core::mem::forget(vec82);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len82;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr82.cast_mut();
                                }
                                V92::QuotaExceeded(e) => {
                                    *ptr68.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used83,
                                        limit: limit83,
                                        reset_time: reset_time83,
                                        unit: unit83,
                                    } = e;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(used83);
                                    *ptr68.add(20).cast::<i32>() = _rt::as_i32(limit83);
                                    *ptr68.add(24).cast::<i64>() = _rt::as_i64(reset_time83);
                                    *ptr68.add(32).cast::<u8>() = (unit83.clone() as i32) as u8;
                                }
                                V92::RateLimited(e) => {
                                    *ptr68.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V92::InsufficientCredits => {
                                    *ptr68.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V92::SynthesisFailed(e) => {
                                    *ptr68.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec84 = (e.into_bytes()).into_boxed_slice();
                                    let ptr84 = vec84.as_ptr().cast::<u8>();
                                    let len84 = vec84.len();
                                    ::core::mem::forget(vec84);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len84;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr84.cast_mut();
                                }
                                V92::UnsupportedOperation(e) => {
                                    *ptr68.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec85 = (e.into_bytes()).into_boxed_slice();
                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                    let len85 = vec85.len();
                                    ::core::mem::forget(vec85);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len85;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr85.cast_mut();
                                }
                                V92::InvalidConfiguration(e) => {
                                    *ptr68.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec86 = (e.into_bytes()).into_boxed_slice();
                                    let ptr86 = vec86.as_ptr().cast::<u8>();
                                    let len86 = vec86.len();
                                    ::core::mem::forget(vec86);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len86;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr86.cast_mut();
                                }
                                V92::ServiceUnavailable(e) => {
                                    *ptr68.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec87 = (e.into_bytes()).into_boxed_slice();
                                    let ptr87 = vec87.as_ptr().cast::<u8>();
                                    let len87 = vec87.len();
                                    ::core::mem::forget(vec87);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len87;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr87.cast_mut();
                                }
                                V92::NetworkError(e) => {
                                    *ptr68.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec88 = (e.into_bytes()).into_boxed_slice();
                                    let ptr88 = vec88.as_ptr().cast::<u8>();
                                    let len88 = vec88.len();
                                    ::core::mem::forget(vec88);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len88;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr88.cast_mut();
                                }
                                V92::InternalError(e) => {
                                    *ptr68.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec89 = (e.into_bytes()).into_boxed_slice();
                                    let ptr89 = vec89.as_ptr().cast::<u8>();
                                    let len89 = vec89.len();
                                    ::core::mem::forget(vec89);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len89;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr89.cast_mut();
                                }
                                V92::InvalidStorageLocation(e) => {
                                    *ptr68.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec90 = (e.into_bytes()).into_boxed_slice();
                                    let ptr90 = vec90.as_ptr().cast::<u8>();
                                    let len90 = vec90.len();
                                    ::core::mem::forget(vec90);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len90;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr90.cast_mut();
                                }
                                V92::StorageAccessDenied(e) => {
                                    *ptr68.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec91 = (e.into_bytes()).into_boxed_slice();
                                    let ptr91 = vec91.as_ptr().cast::<u8>();
                                    let len91 = vec91.len();
                                    ::core::mem::forget(vec91);
                                    *ptr68
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len91;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr91.cast_mut();
                                }
                            }
                        }
                    };
                    ptr68
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize_batch<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base11 = l1;
                            let len11 = l2;
                            for i in 0..len11 {
                                let base = base11
                                    .add(i * (16 + 7 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base5 = l3;
                                    let len5 = l4;
                                    _rt::cabi_dealloc(base5, len5 * 1, 1);
                                    let l6 = *base
                                        .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l7 = *base
                                        .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                    let l8 = i32::from(
                                        *base
                                            .add(16 + 4 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    match l8 {
                                        0 => {}
                                        _ => {
                                            let l9 = *base
                                                .add(16 + 5 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l10 = *base
                                                .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            _rt::cabi_dealloc(l9, l10, 1);
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(
                                base11,
                                len11 * (16 + 7 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l12 = i32::from(*arg0.add(8).cast::<u8>());
                            match l12 {
                                0 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                1 => {}
                                2 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                3 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                4 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                5 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                6 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                7 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                8 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                13 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                14 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                15 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                16 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                17 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                18 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                _ => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_timing_marks_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result2 = T::get_timing_marks(
                        super::super::super::super::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::golem::tts::types::TextType::_lift(
                                arg2 as u8,
                            ),
                            language: match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg5;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg4.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        unsafe { VoiceBorrow::lift(arg6 as u32 as usize) },
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec5 = e;
                            let len5 = vec5.len();
                            let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec5.len() * 24,
                                4,
                            );
                            let result5 = if layout5.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout5);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec5.into_iter().enumerate() {
                                let base = result5.add(i * 24);
                                {
                                    let super::super::super::super::golem::tts::types::TimingInfo {
                                        start_time_seconds: start_time_seconds4,
                                        end_time_seconds: end_time_seconds4,
                                        text_offset: text_offset4,
                                        mark_type: mark_type4,
                                    } = e;
                                    *base.add(0).cast::<f32>() = _rt::as_f32(
                                        start_time_seconds4,
                                    );
                                    match end_time_seconds4 {
                                        Some(e) => {
                                            *base.add(4).cast::<u8>() = (1i32) as u8;
                                            *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                        }
                                        None => {
                                            *base.add(4).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match text_offset4 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match mark_type4 {
                                        Some(e) => {
                                            *base.add(20).cast::<u8>() = (1i32) as u8;
                                            *base.add(21).cast::<u8>() = (e.clone() as i32) as u8;
                                        }
                                        None => {
                                            *base.add(20).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            *ptr3
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len5;
                            *ptr3.add(8).cast::<*mut u8>() = result5;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V23;
                            match e {
                                V23::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V23::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V23::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V23::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V23::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V23::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V23::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V23::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V23::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V23::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used14,
                                        limit: limit14,
                                        reset_time: reset_time14,
                                        unit: unit14,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used14);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit14);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time14);
                                    *ptr3.add(32).cast::<u8>() = (unit14.clone() as i32) as u8;
                                }
                                V23::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V23::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V23::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V23::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V23::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V23::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V23::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V23::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V23::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V23::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_timing_marks<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 24, 4);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_validate_input_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result2 = T::validate_input(
                        super::super::super::super::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::golem::tts::types::TextType::_lift(
                                arg2 as u8,
                            ),
                            language: match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg5;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg4.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        unsafe { VoiceBorrow::lift(arg6 as u32 as usize) },
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let ValidationResult {
                                is_valid: is_valid4,
                                character_count: character_count4,
                                estimated_duration: estimated_duration4,
                                warnings: warnings4,
                                errors: errors4,
                            } = e;
                            *ptr3.add(8).cast::<u8>() = (match is_valid4 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            *ptr3.add(12).cast::<i32>() = _rt::as_i32(character_count4);
                            match estimated_duration4 {
                                Some(e) => {
                                    *ptr3.add(16).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(20).cast::<f32>() = _rt::as_f32(e);
                                }
                                None => {
                                    *ptr3.add(16).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec6 = warnings4;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                            }
                            *ptr3
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr3.add(24).cast::<*mut u8>() = result6;
                            let vec8 = errors4;
                            let len8 = vec8.len();
                            let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec8.len() * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let result8 = if layout8.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout8);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec8.into_iter().enumerate() {
                                let base = result8
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                            }
                            *ptr3
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len8;
                            *ptr3
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = result8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V26;
                            match e {
                                V26::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V26::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V26::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V26::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V26::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V26::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V26::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V26::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V26::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used17,
                                        limit: limit17,
                                        reset_time: reset_time17,
                                        unit: unit17,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used17);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit17);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time17);
                                    *ptr3.add(32).cast::<u8>() = (unit17.clone() as i32) as u8;
                                }
                                V26::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V26::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V26::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V26::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V26::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V26::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V26::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V26::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V26::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_validate_input<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(24).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(24 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base5 = l1;
                            let len5 = l2;
                            for i in 0..len5 {
                                let base = base5
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base5,
                                len5 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                            let l6 = *arg0
                                .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l7 = *arg0
                                .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base10 = l6;
                            let len10 = l7;
                            for i in 0..len10 {
                                let base = base10
                                    .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                                {
                                    let l8 = *base.add(0).cast::<*mut u8>();
                                    let l9 = *base
                                        .add(::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                            }
                            _rt::cabi_dealloc(
                                base10,
                                len10 * (2 * ::core::mem::size_of::<*const u8>()),
                                ::core::mem::size_of::<*const u8>(),
                            );
                        }
                        _ => {
                            let l11 = i32::from(*arg0.add(8).cast::<u8>());
                            match l11 {
                                0 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                1 => {}
                                2 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                3 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                4 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                5 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                6 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                7 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                8 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                13 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                14 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                15 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                16 => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                                17 => {
                                    let l38 = *arg0.add(16).cast::<*mut u8>();
                                    let l39 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l38, l39, 1);
                                }
                                18 => {
                                    let l40 = *arg0.add(16).cast::<*mut u8>();
                                    let l41 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l40, l41, 1);
                                }
                                _ => {
                                    let l42 = *arg0.add(16).cast::<*mut u8>();
                                    let l43 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l42, l43, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Convert text to speech (removed async)
                    fn synthesize(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<SynthesisResult, TtsError>;
                    /// Batch synthesis for multiple inputs (removed async)
                    fn synthesize_batch(
                        inputs: _rt::Vec<TextInput>,
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<_rt::Vec<SynthesisResult>, TtsError>;
                    /// Get timing information without audio synthesis
                    fn get_timing_marks(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                    ) -> Result<_rt::Vec<TimingInfo>, TtsError>;
                    /// Validate text before synthesis
                    fn validate_input(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                    ) -> Result<ValidationResult, TtsError>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_synthesis_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:tts/synthesis@1.0.0#synthesize")] unsafe extern "C" fn
                        export_synthesize(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_synthesize_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#synthesize")] unsafe extern
                        "C" fn _post_return_synthesize(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_synthesize::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/synthesis@1.0.0#synthesize-batch")] unsafe extern "C"
                        fn export_synthesize_batch(arg0 : * mut u8,) -> * mut u8 { unsafe
                        { $($path_to_types)*:: _export_synthesize_batch_cabi::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#synthesize-batch")] unsafe
                        extern "C" fn _post_return_synthesize_batch(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_synthesize_batch::<$ty > (arg0) } } #[unsafe
                        (export_name = "golem:tts/synthesis@1.0.0#get-timing-marks")]
                        unsafe extern "C" fn export_get_timing_marks(arg0 : * mut u8,
                        arg1 : usize, arg2 : i32, arg3 : i32, arg4 : * mut u8, arg5 :
                        usize, arg6 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_get_timing_marks_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#get-timing-marks")] unsafe
                        extern "C" fn _post_return_get_timing_marks(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_get_timing_marks::<$ty > (arg0) } } #[unsafe
                        (export_name = "golem:tts/synthesis@1.0.0#validate-input")]
                        unsafe extern "C" fn export_validate_input(arg0 : * mut u8, arg1
                        : usize, arg2 : i32, arg3 : i32, arg4 : * mut u8, arg5 : usize,
                        arg6 : i32,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_validate_input_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#validate-input")] unsafe
                        extern "C" fn _post_return_validate_input(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_validate_input::<$ty
                        > (arg0) } } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_synthesis_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 32 + 6 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 32
                        + 6 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Real-time streaming synthesis
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod streaming {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TextInput = super::super::super::super::golem::tts::types::TextInput;
                pub type AudioConfig = super::super::super::super::golem::tts::types::AudioConfig;
                pub type VoiceSettings = super::super::super::super::golem::tts::types::VoiceSettings;
                pub type AudioChunk = super::super::super::super::golem::tts::types::AudioChunk;
                pub type TtsError = super::super::super::super::golem::tts::types::TtsError;
                pub type TimingInfo = super::super::super::super::golem::tts::types::TimingInfo;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                pub type SynthesisOptions = super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions;
                /// Streaming synthesis session
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SynthesisStream {
                    handle: _rt::Resource<SynthesisStream>,
                }
                type _SynthesisStreamRep<T> = Option<T>;
                impl SynthesisStream {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `SynthesisStream`.
                    pub fn new<T: GuestSynthesisStream>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _SynthesisStreamRep<T> = Some(val);
                        let ptr: *mut _SynthesisStreamRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestSynthesisStream>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestSynthesisStream>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestSynthesisStream>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _SynthesisStreamRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestSynthesisStream>(
                        &self,
                    ) -> *mut _SynthesisStreamRep<T> {
                        SynthesisStream::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`SynthesisStream`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SynthesisStreamBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a SynthesisStream>,
                }
                impl<'a> SynthesisStreamBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestSynthesisStream>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _SynthesisStreamRep<T> {
                        SynthesisStream::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for SynthesisStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]synthesis-stream"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum StreamStatus {
                    Ready,
                    Processing,
                    Finished,
                    Error,
                    Closed,
                }
                impl ::core::fmt::Debug for StreamStatus {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            StreamStatus::Ready => {
                                f.debug_tuple("StreamStatus::Ready").finish()
                            }
                            StreamStatus::Processing => {
                                f.debug_tuple("StreamStatus::Processing").finish()
                            }
                            StreamStatus::Finished => {
                                f.debug_tuple("StreamStatus::Finished").finish()
                            }
                            StreamStatus::Error => {
                                f.debug_tuple("StreamStatus::Error").finish()
                            }
                            StreamStatus::Closed => {
                                f.debug_tuple("StreamStatus::Closed").finish()
                            }
                        }
                    }
                }
                impl StreamStatus {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> StreamStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => StreamStatus::Ready,
                            1 => StreamStatus::Processing,
                            2 => StreamStatus::Finished,
                            3 => StreamStatus::Error,
                            4 => StreamStatus::Closed,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceConversionStream {
                    handle: _rt::Resource<VoiceConversionStream>,
                }
                type _VoiceConversionStreamRep<T> = Option<T>;
                impl VoiceConversionStream {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `VoiceConversionStream`.
                    pub fn new<T: GuestVoiceConversionStream>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceConversionStreamRep<T> = Some(val);
                        let ptr: *mut _VoiceConversionStreamRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoiceConversionStream>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoiceConversionStream>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoiceConversionStream>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(
                                handle as *mut _VoiceConversionStreamRep<T>,
                            )
                        };
                    }
                    fn as_ptr<T: GuestVoiceConversionStream>(
                        &self,
                    ) -> *mut _VoiceConversionStreamRep<T> {
                        VoiceConversionStream::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`VoiceConversionStream`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceConversionStreamBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a VoiceConversionStream>,
                }
                impl<'a> VoiceConversionStreamBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoiceConversionStream>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceConversionStreamRep<T> {
                        VoiceConversionStream::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for VoiceConversionStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]voice-conversion-stream"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_send_text_cabi<
                    T: GuestSynthesisStream,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: i32,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result2 = T::send_text(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                        super::super::super::super::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::golem::tts::types::TextType::_lift(
                                arg3 as u8,
                            ),
                            language: match arg4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg6;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg5.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(_) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr3.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_send_text<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_finish_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::finish(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_finish<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_receive_chunk_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::receive_chunk(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::tts::types::AudioChunk {
                                        data: data2,
                                        sequence_number: sequence_number2,
                                        is_final: is_final2,
                                        timing_info: timing_info2,
                                    } = e;
                                    let vec3 = (data2).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr3.cast_mut();
                                    *ptr1
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(sequence_number2);
                                    *ptr1
                                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_final2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match timing_info2 {
                                        Some(e) => {
                                            *ptr1
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::tts::types::TimingInfo {
                                                start_time_seconds: start_time_seconds4,
                                                end_time_seconds: end_time_seconds4,
                                                text_offset: text_offset4,
                                                mark_type: mark_type4,
                                            } = e;
                                            *ptr1
                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f32>() = _rt::as_f32(start_time_seconds4);
                                            match end_time_seconds4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(28 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<f32>() = _rt::as_f32(e);
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match text_offset4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match mark_type4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(41 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (e.clone() as i32) as u8;
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        None => {
                                            *ptr1
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr1.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_receive_chunk<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base4 = l2;
                                    let len4 = l3;
                                    _rt::cabi_dealloc(base4, len4 * 1, 1);
                                }
                            }
                        }
                        _ => {
                            let l5 = i32::from(*arg0.add(8).cast::<u8>());
                            match l5 {
                                0 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                1 => {}
                                2 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                3 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                4 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                5 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                6 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                7 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                8 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                13 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                14 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                15 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                16 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                17 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                18 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                _ => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_has_pending_audio_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::has_pending_audio(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_get_status_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_status(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_close_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::close(
                        unsafe { SynthesisStreamBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_stream_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<i32>();
                    let l1 = i32::from(
                        *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result56 = T::create_stream(
                        unsafe { VoiceBorrow::lift(l0 as u32 as usize) },
                        match l1 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l2 = i32::from(
                                        *arg0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l10 = i32::from(
                                        *arg0
                                            .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l23 = i32::from(
                                        *arg0
                                            .add(80 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l25 = i32::from(
                                        *arg0
                                            .add(82 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l27 = i32::from(
                                        *arg0
                                            .add(84 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l29 = i32::from(
                                        *arg0
                                            .add(88 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l31 = i32::from(
                                        *arg0
                                            .add(96 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l35 = i32::from(
                                        *arg0
                                            .add(96 + 5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions {
                                        audio_config: match l2 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l3 = i32::from(
                                                        *arg0
                                                            .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l4 = i32::from(
                                                        *arg0
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l6 = i32::from(
                                                        *arg0
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l8 = i32::from(
                                                        *arg0
                                                            .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::golem::tts::types::AudioFormat::_lift(
                                                            l3 as u8,
                                                        ),
                                                        sample_rate: match l4 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l5 = *arg0
                                                                        .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l5 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l6 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l7 = *arg0
                                                                        .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l7 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l8 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l9 = i32::from(
                                                                        *arg0
                                                                            .add(25 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>(),
                                                                    );
                                                                    l9 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(
                                                        *arg0
                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l13 = i32::from(
                                                        *arg0
                                                            .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l15 = i32::from(
                                                        *arg0
                                                            .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l17 = i32::from(
                                                        *arg0
                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l19 = i32::from(
                                                        *arg0
                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l21 = i32::from(
                                                        *arg0
                                                            .add(72 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceSettings {
                                                        speed: match l11 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l12 = *arg0
                                                                        .add(36 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l12
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l13 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l14 = *arg0
                                                                        .add(44 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l14
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0
                                                                        .add(52 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l16
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0
                                                                        .add(60 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l18
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0
                                                                        .add(68 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0
                                                                        .add(76 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l23 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l24 = i32::from(
                                                        *arg0
                                                            .add(81 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioEffects::empty()
                                                        | super::super::super::super::golem::tts::types::AudioEffects::from_bits_retain(
                                                            ((l24 as u8) << 0) as _,
                                                        )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l25 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l26 = i32::from(
                                                        *arg0
                                                            .add(83 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l26 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l27 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l28 = i32::from(
                                                        *arg0
                                                            .add(85 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l28 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l29 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l30 = *arg0
                                                        .add(92 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l30 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l31 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l32 = *arg0
                                                        .add(96 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l33 = *arg0
                                                        .add(96 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len34 = l33;
                                                    let bytes34 = _rt::Vec::from_raw_parts(
                                                        l32.cast(),
                                                        len34,
                                                        len34,
                                                    );
                                                    _rt::string_lift(bytes34)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l35 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l36 = i32::from(
                                                        *arg0
                                                            .add(96 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l40 = i32::from(
                                                        *arg0
                                                            .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l44 = i32::from(
                                                        *arg0
                                                            .add(96 + 12 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l48 = i32::from(
                                                        *arg0
                                                            .add(96 + 15 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l52 = i32::from(
                                                        *arg0
                                                            .add(96 + 18 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisContext {
                                                        previous_text: match l36 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l37 = *arg0
                                                                        .add(96 + 7 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l38 = *arg0
                                                                        .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len39 = l38;
                                                                    let bytes39 = _rt::Vec::from_raw_parts(
                                                                        l37.cast(),
                                                                        len39,
                                                                        len39,
                                                                    );
                                                                    _rt::string_lift(bytes39)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l40 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l41 = *arg0
                                                                        .add(96 + 10 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l42 = *arg0
                                                                        .add(96 + 11 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len43 = l42;
                                                                    let bytes43 = _rt::Vec::from_raw_parts(
                                                                        l41.cast(),
                                                                        len43,
                                                                        len43,
                                                                    );
                                                                    _rt::string_lift(bytes43)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l44 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l45 = *arg0
                                                                        .add(96 + 13 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l46 = *arg0
                                                                        .add(96 + 14 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len47 = l46;
                                                                    let bytes47 = _rt::Vec::from_raw_parts(
                                                                        l45.cast(),
                                                                        len47,
                                                                        len47,
                                                                    );
                                                                    _rt::string_lift(bytes47)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l48 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l49 = *arg0
                                                                        .add(96 + 16 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l50 = *arg0
                                                                        .add(96 + 17 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len51 = l50;
                                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                                        l49.cast(),
                                                                        len51,
                                                                        len51,
                                                                    );
                                                                    _rt::string_lift(bytes51)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l52 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l53 = *arg0
                                                                        .add(96 + 19 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l54 = *arg0
                                                                        .add(96 + 20 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len55 = l54;
                                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                                        l53.cast(),
                                                                        len55,
                                                                        len55,
                                                                    );
                                                                    _rt::string_lift(bytes55)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        96 + 21 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr57 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result56 {
                        Ok(e) => {
                            *ptr57.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr57.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr57.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V75;
                            match e {
                                V75::InvalidText(e) => {
                                    *ptr57.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec58 = (e.into_bytes()).into_boxed_slice();
                                    let ptr58 = vec58.as_ptr().cast::<u8>();
                                    let len58 = vec58.len();
                                    ::core::mem::forget(vec58);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len58;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr58.cast_mut();
                                }
                                V75::TextTooLong(e) => {
                                    *ptr57.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V75::InvalidSsml(e) => {
                                    *ptr57.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec59 = (e.into_bytes()).into_boxed_slice();
                                    let ptr59 = vec59.as_ptr().cast::<u8>();
                                    let len59 = vec59.len();
                                    ::core::mem::forget(vec59);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len59;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr59.cast_mut();
                                }
                                V75::UnsupportedLanguage(e) => {
                                    *ptr57.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec60 = (e.into_bytes()).into_boxed_slice();
                                    let ptr60 = vec60.as_ptr().cast::<u8>();
                                    let len60 = vec60.len();
                                    ::core::mem::forget(vec60);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len60;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr60.cast_mut();
                                }
                                V75::VoiceNotFound(e) => {
                                    *ptr57.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec61 = (e.into_bytes()).into_boxed_slice();
                                    let ptr61 = vec61.as_ptr().cast::<u8>();
                                    let len61 = vec61.len();
                                    ::core::mem::forget(vec61);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len61;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr61.cast_mut();
                                }
                                V75::ModelNotFound(e) => {
                                    *ptr57.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec62 = (e.into_bytes()).into_boxed_slice();
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    ::core::mem::forget(vec62);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len62;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                V75::VoiceUnavailable(e) => {
                                    *ptr57.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec63 = (e.into_bytes()).into_boxed_slice();
                                    let ptr63 = vec63.as_ptr().cast::<u8>();
                                    let len63 = vec63.len();
                                    ::core::mem::forget(vec63);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len63;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr63.cast_mut();
                                }
                                V75::Unauthorized(e) => {
                                    *ptr57.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec64 = (e.into_bytes()).into_boxed_slice();
                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                    let len64 = vec64.len();
                                    ::core::mem::forget(vec64);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len64;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr64.cast_mut();
                                }
                                V75::AccessDenied(e) => {
                                    *ptr57.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec65 = (e.into_bytes()).into_boxed_slice();
                                    let ptr65 = vec65.as_ptr().cast::<u8>();
                                    let len65 = vec65.len();
                                    ::core::mem::forget(vec65);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len65;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr65.cast_mut();
                                }
                                V75::QuotaExceeded(e) => {
                                    *ptr57.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used66,
                                        limit: limit66,
                                        reset_time: reset_time66,
                                        unit: unit66,
                                    } = e;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(used66);
                                    *ptr57.add(20).cast::<i32>() = _rt::as_i32(limit66);
                                    *ptr57.add(24).cast::<i64>() = _rt::as_i64(reset_time66);
                                    *ptr57.add(32).cast::<u8>() = (unit66.clone() as i32) as u8;
                                }
                                V75::RateLimited(e) => {
                                    *ptr57.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V75::InsufficientCredits => {
                                    *ptr57.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V75::SynthesisFailed(e) => {
                                    *ptr57.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec67 = (e.into_bytes()).into_boxed_slice();
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    ::core::mem::forget(vec67);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len67;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr67.cast_mut();
                                }
                                V75::UnsupportedOperation(e) => {
                                    *ptr57.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec68 = (e.into_bytes()).into_boxed_slice();
                                    let ptr68 = vec68.as_ptr().cast::<u8>();
                                    let len68 = vec68.len();
                                    ::core::mem::forget(vec68);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len68;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr68.cast_mut();
                                }
                                V75::InvalidConfiguration(e) => {
                                    *ptr57.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec69 = (e.into_bytes()).into_boxed_slice();
                                    let ptr69 = vec69.as_ptr().cast::<u8>();
                                    let len69 = vec69.len();
                                    ::core::mem::forget(vec69);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len69;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr69.cast_mut();
                                }
                                V75::ServiceUnavailable(e) => {
                                    *ptr57.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec70 = (e.into_bytes()).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len70;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr70.cast_mut();
                                }
                                V75::NetworkError(e) => {
                                    *ptr57.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec71 = (e.into_bytes()).into_boxed_slice();
                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                    let len71 = vec71.len();
                                    ::core::mem::forget(vec71);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len71;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr71.cast_mut();
                                }
                                V75::InternalError(e) => {
                                    *ptr57.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec72 = (e.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len72;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr72.cast_mut();
                                }
                                V75::InvalidStorageLocation(e) => {
                                    *ptr57.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len73;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                V75::StorageAccessDenied(e) => {
                                    *ptr57.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len74;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                            }
                        }
                    };
                    ptr57
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_stream<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_voice_conversion_stream_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<i32>();
                    let l1 = i32::from(
                        *arg0.add(::core::mem::size_of::<*const u8>()).cast::<u8>(),
                    );
                    let result56 = T::create_voice_conversion_stream(
                        unsafe { VoiceBorrow::lift(l0 as u32 as usize) },
                        match l1 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l2 = i32::from(
                                        *arg0
                                            .add(2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l10 = i32::from(
                                        *arg0
                                            .add(28 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l23 = i32::from(
                                        *arg0
                                            .add(80 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l25 = i32::from(
                                        *arg0
                                            .add(82 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l27 = i32::from(
                                        *arg0
                                            .add(84 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l29 = i32::from(
                                        *arg0
                                            .add(88 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l31 = i32::from(
                                        *arg0
                                            .add(96 + 2 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    let l35 = i32::from(
                                        *arg0
                                            .add(96 + 5 * ::core::mem::size_of::<*const u8>())
                                            .cast::<u8>(),
                                    );
                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions {
                                        audio_config: match l2 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l3 = i32::from(
                                                        *arg0
                                                            .add(4 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l4 = i32::from(
                                                        *arg0
                                                            .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l6 = i32::from(
                                                        *arg0
                                                            .add(16 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l8 = i32::from(
                                                        *arg0
                                                            .add(24 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::golem::tts::types::AudioFormat::_lift(
                                                            l3 as u8,
                                                        ),
                                                        sample_rate: match l4 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l5 = *arg0
                                                                        .add(12 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l5 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l6 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l7 = *arg0
                                                                        .add(20 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<i32>();
                                                                    l7 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l8 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l9 = i32::from(
                                                                        *arg0
                                                                            .add(25 + 2 * ::core::mem::size_of::<*const u8>())
                                                                            .cast::<u8>(),
                                                                    );
                                                                    l9 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(
                                                        *arg0
                                                            .add(32 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l13 = i32::from(
                                                        *arg0
                                                            .add(40 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l15 = i32::from(
                                                        *arg0
                                                            .add(48 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l17 = i32::from(
                                                        *arg0
                                                            .add(56 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l19 = i32::from(
                                                        *arg0
                                                            .add(64 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l21 = i32::from(
                                                        *arg0
                                                            .add(72 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::VoiceSettings {
                                                        speed: match l11 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l12 = *arg0
                                                                        .add(36 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l12
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l13 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l14 = *arg0
                                                                        .add(44 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l14
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0
                                                                        .add(52 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l16
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0
                                                                        .add(60 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l18
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0
                                                                        .add(68 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0
                                                                        .add(76 + 2 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l23 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l24 = i32::from(
                                                        *arg0
                                                            .add(81 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::golem::tts::types::AudioEffects::empty()
                                                        | super::super::super::super::golem::tts::types::AudioEffects::from_bits_retain(
                                                            ((l24 as u8) << 0) as _,
                                                        )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l25 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l26 = i32::from(
                                                        *arg0
                                                            .add(83 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l26 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l27 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l28 = i32::from(
                                                        *arg0
                                                            .add(85 + 2 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    _rt::bool_lift(l28 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l29 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l30 = *arg0
                                                        .add(92 + 2 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>();
                                                    l30 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l31 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l32 = *arg0
                                                        .add(96 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<*mut u8>();
                                                    let l33 = *arg0
                                                        .add(96 + 4 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<usize>();
                                                    let len34 = l33;
                                                    let bytes34 = _rt::Vec::from_raw_parts(
                                                        l32.cast(),
                                                        len34,
                                                        len34,
                                                    );
                                                    _rt::string_lift(bytes34)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l35 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l36 = i32::from(
                                                        *arg0
                                                            .add(96 + 6 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l40 = i32::from(
                                                        *arg0
                                                            .add(96 + 9 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l44 = i32::from(
                                                        *arg0
                                                            .add(96 + 12 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l48 = i32::from(
                                                        *arg0
                                                            .add(96 + 15 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    let l52 = i32::from(
                                                        *arg0
                                                            .add(96 + 18 * ::core::mem::size_of::<*const u8>())
                                                            .cast::<u8>(),
                                                    );
                                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisContext {
                                                        previous_text: match l36 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l37 = *arg0
                                                                        .add(96 + 7 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l38 = *arg0
                                                                        .add(96 + 8 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len39 = l38;
                                                                    let bytes39 = _rt::Vec::from_raw_parts(
                                                                        l37.cast(),
                                                                        len39,
                                                                        len39,
                                                                    );
                                                                    _rt::string_lift(bytes39)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l40 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l41 = *arg0
                                                                        .add(96 + 10 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l42 = *arg0
                                                                        .add(96 + 11 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len43 = l42;
                                                                    let bytes43 = _rt::Vec::from_raw_parts(
                                                                        l41.cast(),
                                                                        len43,
                                                                        len43,
                                                                    );
                                                                    _rt::string_lift(bytes43)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l44 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l45 = *arg0
                                                                        .add(96 + 13 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l46 = *arg0
                                                                        .add(96 + 14 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len47 = l46;
                                                                    let bytes47 = _rt::Vec::from_raw_parts(
                                                                        l45.cast(),
                                                                        len47,
                                                                        len47,
                                                                    );
                                                                    _rt::string_lift(bytes47)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l48 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l49 = *arg0
                                                                        .add(96 + 16 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l50 = *arg0
                                                                        .add(96 + 17 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len51 = l50;
                                                                    let bytes51 = _rt::Vec::from_raw_parts(
                                                                        l49.cast(),
                                                                        len51,
                                                                        len51,
                                                                    );
                                                                    _rt::string_lift(bytes51)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l52 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l53 = *arg0
                                                                        .add(96 + 19 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<*mut u8>();
                                                                    let l54 = *arg0
                                                                        .add(96 + 20 * ::core::mem::size_of::<*const u8>())
                                                                        .cast::<usize>();
                                                                    let len55 = l54;
                                                                    let bytes55 = _rt::Vec::from_raw_parts(
                                                                        l53.cast(),
                                                                        len55,
                                                                        len55,
                                                                    );
                                                                    _rt::string_lift(bytes55)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(
                        arg0,
                        96 + 21 * ::core::mem::size_of::<*const u8>(),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let ptr57 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result56 {
                        Ok(e) => {
                            *ptr57.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr57.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr57.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V75;
                            match e {
                                V75::InvalidText(e) => {
                                    *ptr57.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec58 = (e.into_bytes()).into_boxed_slice();
                                    let ptr58 = vec58.as_ptr().cast::<u8>();
                                    let len58 = vec58.len();
                                    ::core::mem::forget(vec58);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len58;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr58.cast_mut();
                                }
                                V75::TextTooLong(e) => {
                                    *ptr57.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V75::InvalidSsml(e) => {
                                    *ptr57.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec59 = (e.into_bytes()).into_boxed_slice();
                                    let ptr59 = vec59.as_ptr().cast::<u8>();
                                    let len59 = vec59.len();
                                    ::core::mem::forget(vec59);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len59;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr59.cast_mut();
                                }
                                V75::UnsupportedLanguage(e) => {
                                    *ptr57.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec60 = (e.into_bytes()).into_boxed_slice();
                                    let ptr60 = vec60.as_ptr().cast::<u8>();
                                    let len60 = vec60.len();
                                    ::core::mem::forget(vec60);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len60;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr60.cast_mut();
                                }
                                V75::VoiceNotFound(e) => {
                                    *ptr57.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec61 = (e.into_bytes()).into_boxed_slice();
                                    let ptr61 = vec61.as_ptr().cast::<u8>();
                                    let len61 = vec61.len();
                                    ::core::mem::forget(vec61);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len61;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr61.cast_mut();
                                }
                                V75::ModelNotFound(e) => {
                                    *ptr57.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec62 = (e.into_bytes()).into_boxed_slice();
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    ::core::mem::forget(vec62);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len62;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                V75::VoiceUnavailable(e) => {
                                    *ptr57.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec63 = (e.into_bytes()).into_boxed_slice();
                                    let ptr63 = vec63.as_ptr().cast::<u8>();
                                    let len63 = vec63.len();
                                    ::core::mem::forget(vec63);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len63;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr63.cast_mut();
                                }
                                V75::Unauthorized(e) => {
                                    *ptr57.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec64 = (e.into_bytes()).into_boxed_slice();
                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                    let len64 = vec64.len();
                                    ::core::mem::forget(vec64);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len64;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr64.cast_mut();
                                }
                                V75::AccessDenied(e) => {
                                    *ptr57.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec65 = (e.into_bytes()).into_boxed_slice();
                                    let ptr65 = vec65.as_ptr().cast::<u8>();
                                    let len65 = vec65.len();
                                    ::core::mem::forget(vec65);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len65;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr65.cast_mut();
                                }
                                V75::QuotaExceeded(e) => {
                                    *ptr57.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used66,
                                        limit: limit66,
                                        reset_time: reset_time66,
                                        unit: unit66,
                                    } = e;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(used66);
                                    *ptr57.add(20).cast::<i32>() = _rt::as_i32(limit66);
                                    *ptr57.add(24).cast::<i64>() = _rt::as_i64(reset_time66);
                                    *ptr57.add(32).cast::<u8>() = (unit66.clone() as i32) as u8;
                                }
                                V75::RateLimited(e) => {
                                    *ptr57.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr57.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V75::InsufficientCredits => {
                                    *ptr57.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V75::SynthesisFailed(e) => {
                                    *ptr57.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec67 = (e.into_bytes()).into_boxed_slice();
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    ::core::mem::forget(vec67);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len67;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr67.cast_mut();
                                }
                                V75::UnsupportedOperation(e) => {
                                    *ptr57.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec68 = (e.into_bytes()).into_boxed_slice();
                                    let ptr68 = vec68.as_ptr().cast::<u8>();
                                    let len68 = vec68.len();
                                    ::core::mem::forget(vec68);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len68;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr68.cast_mut();
                                }
                                V75::InvalidConfiguration(e) => {
                                    *ptr57.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec69 = (e.into_bytes()).into_boxed_slice();
                                    let ptr69 = vec69.as_ptr().cast::<u8>();
                                    let len69 = vec69.len();
                                    ::core::mem::forget(vec69);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len69;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr69.cast_mut();
                                }
                                V75::ServiceUnavailable(e) => {
                                    *ptr57.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec70 = (e.into_bytes()).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len70;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr70.cast_mut();
                                }
                                V75::NetworkError(e) => {
                                    *ptr57.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec71 = (e.into_bytes()).into_boxed_slice();
                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                    let len71 = vec71.len();
                                    ::core::mem::forget(vec71);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len71;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr71.cast_mut();
                                }
                                V75::InternalError(e) => {
                                    *ptr57.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec72 = (e.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len72;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr72.cast_mut();
                                }
                                V75::InvalidStorageLocation(e) => {
                                    *ptr57.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len73;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                V75::StorageAccessDenied(e) => {
                                    *ptr57.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr57
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len74;
                                    *ptr57.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                            }
                        }
                    };
                    ptr57
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_voice_conversion_stream<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_send_audio_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8, arg1: *mut u8, arg2: usize) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let result1 = T::send_audio(
                        unsafe {
                            VoiceConversionStreamBorrow::lift(arg0 as u32 as usize)
                        }
                            .get(),
                        _rt::Vec::from_raw_parts(arg1.cast(), len0, len0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_send_audio<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_receive_converted_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::receive_converted(
                        unsafe {
                            VoiceConversionStreamBorrow::lift(arg0 as u32 as usize)
                        }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::golem::tts::types::AudioChunk {
                                        data: data2,
                                        sequence_number: sequence_number2,
                                        is_final: is_final2,
                                        timing_info: timing_info2,
                                    } = e;
                                    let vec3 = (data2).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr3.cast_mut();
                                    *ptr1
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<i32>() = _rt::as_i32(sequence_number2);
                                    *ptr1
                                        .add(12 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (match is_final2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match timing_info2 {
                                        Some(e) => {
                                            *ptr1
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::golem::tts::types::TimingInfo {
                                                start_time_seconds: start_time_seconds4,
                                                end_time_seconds: end_time_seconds4,
                                                text_offset: text_offset4,
                                                mark_type: mark_type4,
                                            } = e;
                                            *ptr1
                                                .add(20 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<f32>() = _rt::as_f32(start_time_seconds4);
                                            match end_time_seconds4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(28 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<f32>() = _rt::as_f32(e);
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(24 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match text_offset4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(36 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(32 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match mark_type4 {
                                                Some(e) => {
                                                    *ptr1
                                                        .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (1i32) as u8;
                                                    *ptr1
                                                        .add(41 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (e.clone() as i32) as u8;
                                                }
                                                None => {
                                                    *ptr1
                                                        .add(40 + 3 * ::core::mem::size_of::<*const u8>())
                                                        .cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        None => {
                                            *ptr1
                                                .add(16 + 3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr1.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_receive_converted<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0
                                        .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base4 = l2;
                                    let len4 = l3;
                                    _rt::cabi_dealloc(base4, len4 * 1, 1);
                                }
                            }
                        }
                        _ => {
                            let l5 = i32::from(*arg0.add(8).cast::<u8>());
                            match l5 {
                                0 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                1 => {}
                                2 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                3 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                4 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                5 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                6 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                7 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                8 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                13 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                14 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                15 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                16 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                17 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                18 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                _ => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_finish_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::finish(
                        unsafe {
                            VoiceConversionStreamBorrow::lift(arg0 as u32 as usize)
                        }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_finish<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_close_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::close(
                        unsafe {
                            VoiceConversionStreamBorrow::lift(arg0 as u32 as usize)
                        }
                            .get(),
                    );
                }
                pub trait Guest {
                    type SynthesisStream: GuestSynthesisStream;
                    type VoiceConversionStream: GuestVoiceConversionStream;
                    /// Create streaming synthesis session
                    fn create_stream(
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<SynthesisStream, TtsError>;
                    /// Real-time voice conversion streaming
                    fn create_voice_conversion_stream(
                        target_voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<VoiceConversionStream, TtsError>;
                }
                pub trait GuestSynthesisStream: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]synthesis-stream"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]synthesis-stream"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Send text for synthesis (can be called multiple times)
                    fn send_text(&self, input: TextInput) -> Result<(), TtsError>;
                    /// Signal end of input and flush remaining audio
                    fn finish(&self) -> Result<(), TtsError>;
                    /// Receive next audio chunk (non-blocking)
                    fn receive_chunk(&self) -> Result<Option<AudioChunk>, TtsError>;
                    /// Check if more chunks are available
                    fn has_pending_audio(&self) -> bool;
                    /// Get current stream status
                    fn get_status(&self) -> StreamStatus;
                    /// Close stream and clean up resources
                    fn close(&self) -> ();
                }
                pub trait GuestVoiceConversionStream: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]voice-conversion-stream"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]voice-conversion-stream"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Send input audio chunks
                    fn send_audio(
                        &self,
                        audio_data: _rt::Vec<u8>,
                    ) -> Result<(), TtsError>;
                    /// Receive converted audio chunks
                    fn receive_converted(&self) -> Result<Option<AudioChunk>, TtsError>;
                    fn finish(&self) -> Result<(), TtsError>;
                    fn close(&self) -> ();
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_streaming_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.send-text")]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_send_text(arg0 : * mut u8, arg1 :
                        * mut u8, arg2 : usize, arg3 : i32, arg4 : i32, arg5 : * mut u8,
                        arg6 : usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_send_text_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0, arg1,
                        arg2, arg3, arg4, arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.send-text")]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_send_text(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_synthesis_stream_send_text::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.finish")]
                        unsafe extern "C" fn export_method_synthesis_stream_finish(arg0 :
                        * mut u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_finish_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.finish")]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_finish(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_method_synthesis_stream_finish::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.receive-chunk")]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_receive_chunk(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_receive_chunk_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.receive-chunk")]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_receive_chunk(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_synthesis_stream_receive_chunk::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.has-pending-audio")]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_has_pending_audio(arg0 : * mut
                        u8,) -> i32 { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_has_pending_audio_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.get-status")]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_get_status(arg0 : * mut u8,) ->
                        i32 { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_get_status_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.close")]
                        unsafe extern "C" fn export_method_synthesis_stream_close(arg0 :
                        * mut u8,) { unsafe { $($path_to_types)*::
                        _export_method_synthesis_stream_close_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#create-stream")] unsafe extern "C" fn
                        export_create_stream(arg0 : * mut u8,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_create_stream_cabi::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#create-stream")] unsafe
                        extern "C" fn _post_return_create_stream(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_create_stream::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#create-voice-conversion-stream")]
                        unsafe extern "C" fn export_create_voice_conversion_stream(arg0 :
                        * mut u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_create_voice_conversion_stream_cabi::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#create-voice-conversion-stream")]
                        unsafe extern "C" fn
                        _post_return_create_voice_conversion_stream(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_create_voice_conversion_stream::<$ty > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.send-audio")]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_send_audio(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*::
                        _export_method_voice_conversion_stream_send_audio_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0,
                        arg1, arg2) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.send-audio")]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_send_audio(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_send_audio::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.receive-converted")]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_receive_converted(arg0 : *
                        mut u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_conversion_stream_receive_converted_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        } #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.receive-converted")]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_receive_converted(arg0
                        : * mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_receive_converted::<<$ty
                        as $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        } #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.finish")]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_finish(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_voice_conversion_stream_finish_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.finish")]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_finish(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_finish::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.close")]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_close(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        _export_method_voice_conversion_stream_close_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) } }
                        const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[dtor]synthesis-stream")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: SynthesisStream::dtor::< <$ty
                        as $($path_to_types)*:: Guest >::SynthesisStream > (rep) } } };
                        const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "golem:tts/streaming@1.0.0#[dtor]voice-conversion-stream")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*::
                        VoiceConversionStream::dtor::< <$ty as $($path_to_types)*:: Guest
                        >::VoiceConversionStream > (rep) } } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_streaming_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 40 + 4 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 40
                        + 4 * ::core::mem::size_of::<*const u8>()],
                );
            }
            /// Advanced TTS features and voice manipulation
            #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
            pub mod advanced {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TtsError = super::super::super::super::golem::tts::types::TtsError;
                pub type AudioConfig = super::super::super::super::golem::tts::types::AudioConfig;
                pub type LanguageCode = super::super::super::super::golem::tts::types::LanguageCode;
                pub type VoiceGender = super::super::super::super::golem::tts::types::VoiceGender;
                pub type SynthesisMetadata = super::super::super::super::golem::tts::types::SynthesisMetadata;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                #[derive(Clone)]
                pub struct AudioSample {
                    pub data: _rt::Vec<u8>,
                    pub transcript: Option<_rt::String>,
                    pub quality_rating: Option<u8>,
                }
                impl ::core::fmt::Debug for AudioSample {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AudioSample")
                            .field("data", &self.data)
                            .field("transcript", &self.transcript)
                            .field("quality-rating", &self.quality_rating)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AgeCategory {
                    Child,
                    YoungAdult,
                    MiddleAged,
                    Elderly,
                }
                impl ::core::fmt::Debug for AgeCategory {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AgeCategory::Child => {
                                f.debug_tuple("AgeCategory::Child").finish()
                            }
                            AgeCategory::YoungAdult => {
                                f.debug_tuple("AgeCategory::YoungAdult").finish()
                            }
                            AgeCategory::MiddleAged => {
                                f.debug_tuple("AgeCategory::MiddleAged").finish()
                            }
                            AgeCategory::Elderly => {
                                f.debug_tuple("AgeCategory::Elderly").finish()
                            }
                        }
                    }
                }
                impl AgeCategory {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AgeCategory {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AgeCategory::Child,
                            1 => AgeCategory::YoungAdult,
                            2 => AgeCategory::MiddleAged,
                            3 => AgeCategory::Elderly,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct VoiceDesignParams {
                    pub gender: VoiceGender,
                    pub age_category: AgeCategory,
                    pub accent: _rt::String,
                    pub personality_traits: _rt::Vec<_rt::String>,
                    pub reference_voice: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceDesignParams {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceDesignParams")
                            .field("gender", &self.gender)
                            .field("age-category", &self.age_category)
                            .field("accent", &self.accent)
                            .field("personality-traits", &self.personality_traits)
                            .field("reference-voice", &self.reference_voice)
                            .finish()
                    }
                }
                /// Custom pronunciation management
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct PronunciationLexicon {
                    handle: _rt::Resource<PronunciationLexicon>,
                }
                type _PronunciationLexiconRep<T> = Option<T>;
                impl PronunciationLexicon {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `PronunciationLexicon`.
                    pub fn new<T: GuestPronunciationLexicon>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _PronunciationLexiconRep<T> = Some(val);
                        let ptr: *mut _PronunciationLexiconRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestPronunciationLexicon>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestPronunciationLexicon>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestPronunciationLexicon>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(
                                handle as *mut _PronunciationLexiconRep<T>,
                            )
                        };
                    }
                    fn as_ptr<T: GuestPronunciationLexicon>(
                        &self,
                    ) -> *mut _PronunciationLexiconRep<T> {
                        PronunciationLexicon::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`PronunciationLexicon`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct PronunciationLexiconBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a PronunciationLexicon>,
                }
                impl<'a> PronunciationLexiconBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestPronunciationLexicon>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _PronunciationLexiconRep<T> {
                        PronunciationLexicon::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for PronunciationLexicon {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]pronunciation-lexicon"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[derive(Clone)]
                pub struct PronunciationEntry {
                    pub word: _rt::String,
                    pub pronunciation: _rt::String,
                    pub part_of_speech: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for PronunciationEntry {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PronunciationEntry")
                            .field("word", &self.word)
                            .field("pronunciation", &self.pronunciation)
                            .field("part-of-speech", &self.part_of_speech)
                            .finish()
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct LongFormOperation {
                    handle: _rt::Resource<LongFormOperation>,
                }
                type _LongFormOperationRep<T> = Option<T>;
                impl LongFormOperation {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `LongFormOperation`.
                    pub fn new<T: GuestLongFormOperation>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _LongFormOperationRep<T> = Some(val);
                        let ptr: *mut _LongFormOperationRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestLongFormOperation>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestLongFormOperation>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestLongFormOperation>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: unsafe { _rt::Resource::from_handle(handle) },
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = unsafe {
                            _rt::Box::from_raw(handle as *mut _LongFormOperationRep<T>)
                        };
                    }
                    fn as_ptr<T: GuestLongFormOperation>(
                        &self,
                    ) -> *mut _LongFormOperationRep<T> {
                        LongFormOperation::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`LongFormOperation`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct LongFormOperationBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a LongFormOperation>,
                }
                impl<'a> LongFormOperationBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestLongFormOperation>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _LongFormOperationRep<T> {
                        LongFormOperation::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for LongFormOperation {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-drop]long-form-operation"]
                                fn drop(_: u32);
                            }
                            unsafe { drop(_handle) };
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum OperationStatus {
                    Pending,
                    Processing,
                    Completed,
                    Failed,
                    Cancelled,
                }
                impl ::core::fmt::Debug for OperationStatus {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            OperationStatus::Pending => {
                                f.debug_tuple("OperationStatus::Pending").finish()
                            }
                            OperationStatus::Processing => {
                                f.debug_tuple("OperationStatus::Processing").finish()
                            }
                            OperationStatus::Completed => {
                                f.debug_tuple("OperationStatus::Completed").finish()
                            }
                            OperationStatus::Failed => {
                                f.debug_tuple("OperationStatus::Failed").finish()
                            }
                            OperationStatus::Cancelled => {
                                f.debug_tuple("OperationStatus::Cancelled").finish()
                            }
                        }
                    }
                }
                impl OperationStatus {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> OperationStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => OperationStatus::Pending,
                            1 => OperationStatus::Processing,
                            2 => OperationStatus::Completed,
                            3 => OperationStatus::Failed,
                            4 => OperationStatus::Cancelled,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct LongFormResult {
                    pub output_location: _rt::String,
                    pub total_duration: f32,
                    pub chapter_durations: Option<_rt::Vec<f32>>,
                    pub metadata: SynthesisMetadata,
                }
                impl ::core::fmt::Debug for LongFormResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LongFormResult")
                            .field("output-location", &self.output_location)
                            .field("total-duration", &self.total_duration)
                            .field("chapter-durations", &self.chapter_durations)
                            .field("metadata", &self.metadata)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_voice_clone_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base10 = arg2;
                    let len10 = arg3;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10
                            .add(i * (6 * ::core::mem::size_of::<*const u8>()));
                        let e10 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len3 = l2;
                            let l4 = i32::from(
                                *base
                                    .add(2 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            let l8 = i32::from(
                                *base
                                    .add(5 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            AudioSample {
                                data: _rt::Vec::from_raw_parts(l1.cast(), len3, len3),
                                transcript: match l4 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l5 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *base
                                                .add(4 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                quality_rating: match l8 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l9 = i32::from(
                                                *base
                                                    .add(1 + 5 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            l9 as u8
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                            }
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(
                        base10,
                        len10 * (6 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result12 = T::create_voice_clone(
                        _rt::string_lift(bytes0),
                        result10,
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len11 = arg6;
                                    let bytes11 = _rt::Vec::from_raw_parts(
                                        arg5.cast(),
                                        len11,
                                        len11,
                                    );
                                    _rt::string_lift(bytes11)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr13 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result12 {
                        Ok(e) => {
                            *ptr13.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr13.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr13.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V31;
                            match e {
                                V31::InvalidText(e) => {
                                    *ptr13.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V31::TextTooLong(e) => {
                                    *ptr13.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InvalidSsml(e) => {
                                    *ptr13.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V31::UnsupportedLanguage(e) => {
                                    *ptr13.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V31::VoiceNotFound(e) => {
                                    *ptr13.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V31::ModelNotFound(e) => {
                                    *ptr13.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V31::VoiceUnavailable(e) => {
                                    *ptr13.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V31::Unauthorized(e) => {
                                    *ptr13.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V31::AccessDenied(e) => {
                                    *ptr13.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V31::QuotaExceeded(e) => {
                                    *ptr13.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used22,
                                        limit: limit22,
                                        reset_time: reset_time22,
                                        unit: unit22,
                                    } = e;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(used22);
                                    *ptr13.add(20).cast::<i32>() = _rt::as_i32(limit22);
                                    *ptr13.add(24).cast::<i64>() = _rt::as_i64(reset_time22);
                                    *ptr13.add(32).cast::<u8>() = (unit22.clone() as i32) as u8;
                                }
                                V31::RateLimited(e) => {
                                    *ptr13.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InsufficientCredits => {
                                    *ptr13.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V31::SynthesisFailed(e) => {
                                    *ptr13.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V31::UnsupportedOperation(e) => {
                                    *ptr13.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V31::InvalidConfiguration(e) => {
                                    *ptr13.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V31::ServiceUnavailable(e) => {
                                    *ptr13.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len26;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V31::NetworkError(e) => {
                                    *ptr13.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V31::InternalError(e) => {
                                    *ptr13.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len28;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V31::InvalidStorageLocation(e) => {
                                    *ptr13.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len29;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V31::StorageAccessDenied(e) => {
                                    *ptr13.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr13
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len30;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                            }
                        }
                    };
                    ptr13
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_voice_clone<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_design_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: *mut u8,
                    arg7: usize,
                    arg8: i32,
                    arg9: *mut u8,
                    arg10: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg5;
                    let bytes1 = _rt::Vec::from_raw_parts(arg4.cast(), len1, len1);
                    let base5 = arg6;
                    let len5 = arg7;
                    let mut result5 = _rt::Vec::with_capacity(len5);
                    for i in 0..len5 {
                        let base = base5
                            .add(i * (2 * ::core::mem::size_of::<*const u8>()));
                        let e5 = {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base
                                .add(::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let len4 = l3;
                            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                            _rt::string_lift(bytes4)
                        };
                        result5.push(e5);
                    }
                    _rt::cabi_dealloc(
                        base5,
                        len5 * (2 * ::core::mem::size_of::<*const u8>()),
                        ::core::mem::size_of::<*const u8>(),
                    );
                    let result7 = T::design_voice(
                        _rt::string_lift(bytes0),
                        VoiceDesignParams {
                            gender: super::super::super::super::golem::tts::types::VoiceGender::_lift(
                                arg2 as u8,
                            ),
                            age_category: AgeCategory::_lift(arg3 as u8),
                            accent: _rt::string_lift(bytes1),
                            personality_traits: result5,
                            reference_voice: match arg8 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len6 = arg10;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            arg9.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr8 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result7 {
                        Ok(e) => {
                            *ptr8.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr8.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr8.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V26;
                            match e {
                                V26::InvalidText(e) => {
                                    *ptr8.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V26::TextTooLong(e) => {
                                    *ptr8.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InvalidSsml(e) => {
                                    *ptr8.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V26::UnsupportedLanguage(e) => {
                                    *ptr8.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V26::VoiceNotFound(e) => {
                                    *ptr8.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V26::ModelNotFound(e) => {
                                    *ptr8.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V26::VoiceUnavailable(e) => {
                                    *ptr8.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V26::Unauthorized(e) => {
                                    *ptr8.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V26::AccessDenied(e) => {
                                    *ptr8.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V26::QuotaExceeded(e) => {
                                    *ptr8.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used17,
                                        limit: limit17,
                                        reset_time: reset_time17,
                                        unit: unit17,
                                    } = e;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(used17);
                                    *ptr8.add(20).cast::<i32>() = _rt::as_i32(limit17);
                                    *ptr8.add(24).cast::<i64>() = _rt::as_i64(reset_time17);
                                    *ptr8.add(32).cast::<u8>() = (unit17.clone() as i32) as u8;
                                }
                                V26::RateLimited(e) => {
                                    *ptr8.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InsufficientCredits => {
                                    *ptr8.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V26::SynthesisFailed(e) => {
                                    *ptr8.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V26::UnsupportedOperation(e) => {
                                    *ptr8.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V26::InvalidConfiguration(e) => {
                                    *ptr8.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V26::ServiceUnavailable(e) => {
                                    *ptr8.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V26::NetworkError(e) => {
                                    *ptr8.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V26::InternalError(e) => {
                                    *ptr8.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V26::InvalidStorageLocation(e) => {
                                    *ptr8.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V26::StorageAccessDenied(e) => {
                                    *ptr8.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr8
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                            }
                        }
                    };
                    ptr8
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_design_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_convert_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::convert_voice(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        unsafe { VoiceBorrow::lift(arg2 as u32 as usize) },
                        match arg3 {
                            0 => None,
                            1 => {
                                let e = _rt::bool_lift(arg4 as u8);
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_convert_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_sound_effect_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: f32,
                    arg4: i32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::generate_sound_effect(
                        _rt::string_lift(bytes0),
                        match arg2 {
                            0 => None,
                            1 => {
                                let e = arg3;
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = arg5;
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_sound_effect<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_name_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_name(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_get_name<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_language_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_language(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_get_language<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0
                        .add(::core::mem::size_of::<*const u8>())
                        .cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_entry_count_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_entry_count(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_add_entry_cabi<
                    T: GuestPronunciationLexicon,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: *mut u8,
                    arg4: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let len1 = arg4;
                    let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);
                    let result2 = T::add_entry(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result2 {
                        Ok(_) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr3.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_add_entry<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_remove_entry_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8, arg1: *mut u8, arg2: usize) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result1 = T::remove_entry(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                        _rt::string_lift(bytes0),
                    );
                    let ptr2 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_remove_entry<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_export_content_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::export_content(
                        unsafe { PronunciationLexiconBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len2;
                            *ptr1.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr1.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_export_content<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = i32::from(*arg0.add(8).cast::<u8>());
                            match l3 {
                                0 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                1 => {}
                                2 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                3 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                4 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                5 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                6 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                7 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                8 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                13 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                14 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                15 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                16 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                17 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                18 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                _ => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_lexicon_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result13 = T::create_lexicon(
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = {
                                    let base12 = arg5;
                                    let len12 = arg6;
                                    let mut result12 = _rt::Vec::with_capacity(len12);
                                    for i in 0..len12 {
                                        let base = base12
                                            .add(i * (7 * ::core::mem::size_of::<*const u8>()));
                                        let e12 = {
                                            let l2 = *base.add(0).cast::<*mut u8>();
                                            let l3 = *base
                                                .add(::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len4 = l3;
                                            let bytes4 = _rt::Vec::from_raw_parts(
                                                l2.cast(),
                                                len4,
                                                len4,
                                            );
                                            let l5 = *base
                                                .add(2 * ::core::mem::size_of::<*const u8>())
                                                .cast::<*mut u8>();
                                            let l6 = *base
                                                .add(3 * ::core::mem::size_of::<*const u8>())
                                                .cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            let l8 = i32::from(
                                                *base
                                                    .add(4 * ::core::mem::size_of::<*const u8>())
                                                    .cast::<u8>(),
                                            );
                                            PronunciationEntry {
                                                word: _rt::string_lift(bytes4),
                                                pronunciation: _rt::string_lift(bytes7),
                                                part_of_speech: match l8 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l9 = *base
                                                                .add(5 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<*mut u8>();
                                                            let l10 = *base
                                                                .add(6 * ::core::mem::size_of::<*const u8>())
                                                                .cast::<usize>();
                                                            let len11 = l10;
                                                            let bytes11 = _rt::Vec::from_raw_parts(
                                                                l9.cast(),
                                                                len11,
                                                                len11,
                                                            );
                                                            _rt::string_lift(bytes11)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        result12.push(e12);
                                    }
                                    _rt::cabi_dealloc(
                                        base12,
                                        len12 * (7 * ::core::mem::size_of::<*const u8>()),
                                        ::core::mem::size_of::<*const u8>(),
                                    );
                                    result12
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr14 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result13 {
                        Ok(e) => {
                            *ptr14.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr14.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr14.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V32;
                            match e {
                                V32::InvalidText(e) => {
                                    *ptr14.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V32::TextTooLong(e) => {
                                    *ptr14.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V32::InvalidSsml(e) => {
                                    *ptr14.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V32::UnsupportedLanguage(e) => {
                                    *ptr14.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V32::VoiceNotFound(e) => {
                                    *ptr14.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V32::ModelNotFound(e) => {
                                    *ptr14.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V32::VoiceUnavailable(e) => {
                                    *ptr14.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V32::Unauthorized(e) => {
                                    *ptr14.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V32::AccessDenied(e) => {
                                    *ptr14.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V32::QuotaExceeded(e) => {
                                    *ptr14.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used23,
                                        limit: limit23,
                                        reset_time: reset_time23,
                                        unit: unit23,
                                    } = e;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(used23);
                                    *ptr14.add(20).cast::<i32>() = _rt::as_i32(limit23);
                                    *ptr14.add(24).cast::<i64>() = _rt::as_i64(reset_time23);
                                    *ptr14.add(32).cast::<u8>() = (unit23.clone() as i32) as u8;
                                }
                                V32::RateLimited(e) => {
                                    *ptr14.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V32::InsufficientCredits => {
                                    *ptr14.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V32::SynthesisFailed(e) => {
                                    *ptr14.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V32::UnsupportedOperation(e) => {
                                    *ptr14.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len25;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V32::InvalidConfiguration(e) => {
                                    *ptr14.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len26;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V32::ServiceUnavailable(e) => {
                                    *ptr14.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len27;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V32::NetworkError(e) => {
                                    *ptr14.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len28;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V32::InternalError(e) => {
                                    *ptr14.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len29;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V32::InvalidStorageLocation(e) => {
                                    *ptr14.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len30;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                                V32::StorageAccessDenied(e) => {
                                    *ptr14.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec31 = (e.into_bytes()).into_boxed_slice();
                                    let ptr31 = vec31.as_ptr().cast::<u8>();
                                    let len31 = vec31.len();
                                    ::core::mem::forget(vec31);
                                    *ptr14
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len31;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr31.cast_mut();
                                }
                            }
                        }
                    };
                    ptr14
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_lexicon<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_long_form_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: i32,
                    arg6: *mut u8,
                    arg7: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg4;
                    let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);
                    let result3 = T::synthesize_long_form(
                        _rt::string_lift(bytes0),
                        unsafe { VoiceBorrow::lift(arg2 as u32 as usize) },
                        _rt::string_lift(bytes1),
                        match arg5 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len2 = arg7;
                                    _rt::Vec::from_raw_parts(arg6.cast(), len2, len2)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr4 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr4.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr4.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr4.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr4.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr4.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr4.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr4.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr4.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr4.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr4.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr4.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr4.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr4.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr4
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize_long_form<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_status_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_status(
                        unsafe { LongFormOperationBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_progress_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_progress(
                        unsafe { LongFormOperationBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_cancel_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::cancel(
                        unsafe { LongFormOperationBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_long_form_operation_cancel<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_result_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_result(
                        unsafe { LongFormOperationBorrow::lift(arg0 as u32 as usize) }
                            .get(),
                    );
                    let ptr1 = (&raw mut _RET_AREA.0).cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let LongFormResult {
                                output_location: output_location2,
                                total_duration: total_duration2,
                                chapter_durations: chapter_durations2,
                                metadata: metadata2,
                            } = e;
                            let vec3 = (output_location2.into_bytes())
                                .into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len3;
                            *ptr1.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                            *ptr1
                                .add(8 + 2 * ::core::mem::size_of::<*const u8>())
                                .cast::<f32>() = _rt::as_f32(total_duration2);
                            match chapter_durations2 {
                                Some(e) => {
                                    *ptr1
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len4;
                                    *ptr1
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                None => {
                                    *ptr1
                                        .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let super::super::super::super::golem::tts::types::SynthesisMetadata {
                                duration_seconds: duration_seconds5,
                                character_count: character_count5,
                                word_count: word_count5,
                                audio_size_bytes: audio_size_bytes5,
                                request_id: request_id5,
                                provider_info: provider_info5,
                            } = metadata2;
                            *ptr1
                                .add(8 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<f32>() = _rt::as_f32(duration_seconds5);
                            *ptr1
                                .add(12 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(character_count5);
                            *ptr1
                                .add(16 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(word_count5);
                            *ptr1
                                .add(20 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<i32>() = _rt::as_i32(audio_size_bytes5);
                            let vec6 = (request_id5.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr1
                                .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>() = len6;
                            *ptr1
                                .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>() = ptr6.cast_mut();
                            match provider_info5 {
                                Some(e) => {
                                    *ptr1
                                        .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1
                                        .add(24 + 10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len7;
                                    *ptr1
                                        .add(24 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                None => {
                                    *ptr1
                                        .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                        .cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::golem::tts::types::TtsError as V25;
                            match e {
                                V25::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V25::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V25::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V25::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V25::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V25::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V25::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V25::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V25::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V25::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::golem::tts::types::QuotaInfo {
                                        used: used16,
                                        limit: limit16,
                                        reset_time: reset_time16,
                                        unit: unit16,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used16);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit16);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time16);
                                    *ptr1.add(32).cast::<u8>() = (unit16.clone() as i32) as u8;
                                }
                                V25::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V25::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V25::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V25::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V25::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V25::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V25::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V25::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len22;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V25::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V25::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr1
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>() = len24;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_long_form_operation_get_result<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0
                                .add(8 + 1 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(
                                *arg0
                                    .add(8 + 3 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0
                                        .add(8 + 4 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l5 = *arg0
                                        .add(8 + 5 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    let base6 = l4;
                                    let len6 = l5;
                                    _rt::cabi_dealloc(base6, len6 * 4, 4);
                                }
                            }
                            let l7 = *arg0
                                .add(24 + 6 * ::core::mem::size_of::<*const u8>())
                                .cast::<*mut u8>();
                            let l8 = *arg0
                                .add(24 + 7 * ::core::mem::size_of::<*const u8>())
                                .cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                            let l9 = i32::from(
                                *arg0
                                    .add(24 + 8 * ::core::mem::size_of::<*const u8>())
                                    .cast::<u8>(),
                            );
                            match l9 {
                                0 => {}
                                _ => {
                                    let l10 = *arg0
                                        .add(24 + 9 * ::core::mem::size_of::<*const u8>())
                                        .cast::<*mut u8>();
                                    let l11 = *arg0
                                        .add(24 + 10 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                            }
                        }
                        _ => {
                            let l12 = i32::from(*arg0.add(8).cast::<u8>());
                            match l12 {
                                0 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                1 => {}
                                2 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                3 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                4 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                5 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                6 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                7 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                8 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                13 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                14 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                15 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                16 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                17 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                18 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                _ => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0
                                        .add(16 + 1 * ::core::mem::size_of::<*const u8>())
                                        .cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    type PronunciationLexicon: GuestPronunciationLexicon;
                    type LongFormOperation: GuestLongFormOperation;
                    /// Voice cloning and creation (removed async)
                    fn create_voice_clone(
                        name: _rt::String,
                        audio_samples: _rt::Vec<AudioSample>,
                        description: Option<_rt::String>,
                    ) -> Result<Voice, TtsError>;
                    /// Design synthetic voice (removed async)
                    fn design_voice(
                        name: _rt::String,
                        characteristics: VoiceDesignParams,
                    ) -> Result<Voice, TtsError>;
                    /// Voice-to-voice conversion (removed async)
                    fn convert_voice(
                        input_audio: _rt::Vec<u8>,
                        target_voice: VoiceBorrow<'_>,
                        preserve_timing: Option<bool>,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                    /// Generate sound effects from text description (removed async)
                    fn generate_sound_effect(
                        description: _rt::String,
                        duration_seconds: Option<f32>,
                        style_influence: Option<f32>,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                    /// Create custom pronunciation lexicon
                    fn create_lexicon(
                        name: _rt::String,
                        language: LanguageCode,
                        entries: Option<_rt::Vec<PronunciationEntry>>,
                    ) -> Result<PronunciationLexicon, TtsError>;
                    /// Long-form content synthesis with optimization (removed async)
                    fn synthesize_long_form(
                        content: _rt::String,
                        voice: VoiceBorrow<'_>,
                        output_location: _rt::String,
                        chapter_breaks: Option<_rt::Vec<u32>>,
                    ) -> Result<LongFormOperation, TtsError>;
                }
                pub trait GuestPronunciationLexicon: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]pronunciation-lexicon"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]pronunciation-lexicon"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn get_name(&self) -> _rt::String;
                    fn get_language(&self) -> LanguageCode;
                    fn get_entry_count(&self) -> u32;
                    /// Add pronunciation rule
                    fn add_entry(
                        &self,
                        word: _rt::String,
                        pronunciation: _rt::String,
                    ) -> Result<(), TtsError>;
                    /// Remove pronunciation rule
                    fn remove_entry(&self, word: _rt::String) -> Result<(), TtsError>;
                    /// Export lexicon content
                    fn export_content(&self) -> Result<_rt::String, TtsError>;
                }
                pub trait GuestLongFormOperation: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-new]long-form-operation"]
                                fn new(_: *mut u8) -> u32;
                            }
                            unsafe { new(val) }
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            unsafe extern "C" {
                                #[link_name = "[resource-rep]long-form-operation"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn get_status(&self) -> OperationStatus;
                    fn get_progress(&self) -> f32;
                    fn cancel(&self) -> Result<(), TtsError>;
                    fn get_result(&self) -> Result<LongFormResult, TtsError>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_advanced_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#create-voice-clone")] unsafe extern "C"
                        fn export_create_voice_clone(arg0 : * mut u8, arg1 : usize, arg2
                        : * mut u8, arg3 : usize, arg4 : i32, arg5 : * mut u8, arg6 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_create_voice_clone_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#create-voice-clone")] unsafe
                        extern "C" fn _post_return_create_voice_clone(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*::
                        __post_return_create_voice_clone::<$ty > (arg0) } } #[unsafe
                        (export_name = "golem:tts/advanced@1.0.0#design-voice")] unsafe
                        extern "C" fn export_design_voice(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32, arg3 : i32, arg4 : * mut u8, arg5 : usize, arg6 : *
                        mut u8, arg7 : usize, arg8 : i32, arg9 : * mut u8, arg10 :
                        usize,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_design_voice_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6, arg7, arg8, arg9, arg10) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#design-voice")] unsafe extern
                        "C" fn _post_return_design_voice(arg0 : * mut u8,) { unsafe {
                        $($path_to_types)*:: __post_return_design_voice::<$ty > (arg0) }
                        } #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#convert-voice")] unsafe extern "C" fn
                        export_convert_voice(arg0 : * mut u8, arg1 : usize, arg2 : i32,
                        arg3 : i32, arg4 : i32,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_convert_voice_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#convert-voice")] unsafe
                        extern "C" fn _post_return_convert_voice(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_convert_voice::<$ty >
                        (arg0) } } #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#generate-sound-effect")] unsafe extern
                        "C" fn export_generate_sound_effect(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32, arg3 : f32, arg4 : i32, arg5 : f32,) -> * mut
                        u8 { unsafe { $($path_to_types)*::
                        _export_generate_sound_effect_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#generate-sound-effect")]
                        unsafe extern "C" fn _post_return_generate_sound_effect(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_generate_sound_effect::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-name")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_name(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_name_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-name")]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_get_name(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_get_name::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-language")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_language(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_language_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-language")]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_get_language(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_get_language::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-entry-count")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_entry_count(arg0 : * mut
                        u8,) -> i32 { unsafe { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_entry_count_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        } #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.add-entry")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_add_entry(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize, arg3 : * mut u8, arg4 : usize,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_add_entry_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0, arg1,
                        arg2, arg3, arg4) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.add-entry")]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_add_entry(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_add_entry::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.remove-entry")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_remove_entry(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*::
                        _export_method_pronunciation_lexicon_remove_entry_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0, arg1,
                        arg2) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.remove-entry")]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_remove_entry(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_remove_entry::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.export-content")]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_export_content(arg0 : * mut
                        u8,) -> * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_export_content_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.export-content")]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_export_content(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_export_content::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        } #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#create-lexicon")] unsafe extern "C" fn
                        export_create_lexicon(arg0 : * mut u8, arg1 : usize, arg2 : * mut
                        u8, arg3 : usize, arg4 : i32, arg5 : * mut u8, arg6 : usize,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_create_lexicon_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } } #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#create-lexicon")] unsafe
                        extern "C" fn _post_return_create_lexicon(arg0 : * mut u8,) {
                        unsafe { $($path_to_types)*:: __post_return_create_lexicon::<$ty
                        > (arg0) } } #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#synthesize-long-form")] unsafe extern
                        "C" fn export_synthesize_long_form(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32, arg3 : * mut u8, arg4 : usize, arg5 : i32, arg6 : *
                        mut u8, arg7 : usize,) -> * mut u8 { unsafe {
                        $($path_to_types)*:: _export_synthesize_long_form_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) } } #[unsafe
                        (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#synthesize-long-form")]
                        unsafe extern "C" fn _post_return_synthesize_long_form(arg0 : *
                        mut u8,) { unsafe { $($path_to_types)*::
                        __post_return_synthesize_long_form::<$ty > (arg0) } } #[unsafe
                        (export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-status")]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_status(arg0 : * mut u8,) ->
                        i32 { unsafe { $($path_to_types)*::
                        _export_method_long_form_operation_get_status_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-progress")]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_progress(arg0 : * mut u8,)
                        -> f32 { unsafe { $($path_to_types)*::
                        _export_method_long_form_operation_get_progress_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.cancel")]
                        unsafe extern "C" fn
                        export_method_long_form_operation_cancel(arg0 : * mut u8,) -> *
                        mut u8 { unsafe { $($path_to_types)*::
                        _export_method_long_form_operation_cancel_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]long-form-operation.cancel")]
                        unsafe extern "C" fn
                        _post_return_method_long_form_operation_cancel(arg0 : * mut u8,)
                        { unsafe { $($path_to_types)*::
                        __post_return_method_long_form_operation_cancel::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-result")]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_result(arg0 : * mut u8,) ->
                        * mut u8 { unsafe { $($path_to_types)*::
                        _export_method_long_form_operation_get_result_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        #[unsafe (export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]long-form-operation.get-result")]
                        unsafe extern "C" fn
                        _post_return_method_long_form_operation_get_result(arg0 : * mut
                        u8,) { unsafe { $($path_to_types)*::
                        __post_return_method_long_form_operation_get_result::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } }
                        const _ : () = { #[doc(hidden)] #[unsafe (export_name =
                        "golem:tts/advanced@1.0.0#[dtor]pronunciation-lexicon")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: PronunciationLexicon::dtor::<
                        <$ty as $($path_to_types)*:: Guest >::PronunciationLexicon >
                        (rep) } } }; const _ : () = { #[doc(hidden)] #[unsafe
                        (export_name =
                        "golem:tts/advanced@1.0.0#[dtor]long-form-operation")]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { unsafe { $($path_to_types)*:: LongFormOperation::dtor::<
                        <$ty as $($path_to_types)*:: Guest >::LongFormOperation > (rep) }
                        } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_advanced_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea(
                    [::core::mem::MaybeUninit<
                        u8,
                    >; 32 + 10 * ::core::mem::size_of::<*const u8>()],
                );
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 32
                        + 10 * ::core::mem::size_of::<*const u8>()],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            unsafe { core::hint::unreachable_unchecked() }
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_tts_library_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::golem::tts::voices::__export_golem_tts_voices_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::voices);
        $($path_to_types_root)*::
        exports::golem::tts::synthesis::__export_golem_tts_synthesis_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::synthesis);
        $($path_to_types_root)*::
        exports::golem::tts::streaming::__export_golem_tts_streaming_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::streaming);
        $($path_to_types_root)*::
        exports::golem::tts::advanced::__export_golem_tts_advanced_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::advanced);
    };
}
#[doc(inline)]
pub(crate) use __export_tts_library_impl as export;
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:golem:tts-elevenlabs@1.0.0:tts-library:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 6916] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x825\x01A\x02\x01A\x19\
\x01B*\x01m\x04\x0acharacters\x08requests\x07seconds\x07credits\x04\0\x0aquota-u\
nit\x03\0\0\x01r\x04\x04usedy\x05limity\x0areset-timew\x04unit\x01\x04\0\x0aquot\
a-info\x03\0\x02\x01q\x14\x0cinvalid-text\x01s\0\x0dtext-too-long\x01y\0\x0cinva\
lid-ssml\x01s\0\x14unsupported-language\x01s\0\x0fvoice-not-found\x01s\0\x0fmode\
l-not-found\x01s\0\x11voice-unavailable\x01s\0\x0cunauthorized\x01s\0\x0daccess-\
denied\x01s\0\x0equota-exceeded\x01\x03\0\x0crate-limited\x01y\0\x14insufficient\
-credits\0\0\x10synthesis-failed\x01s\0\x15unsupported-operation\x01s\0\x15inval\
id-configuration\x01s\0\x13service-unavailable\x01s\0\x0dnetwork-error\x01s\0\x0e\
internal-error\x01s\0\x18invalid-storage-location\x01s\0\x15storage-access-denie\
d\x01s\0\x04\0\x09tts-error\x03\0\x04\x01s\x04\0\x0dlanguage-code\x03\0\x06\x01m\
\x03\x04male\x06female\x07neutral\x04\0\x0cvoice-gender\x03\0\x08\x01m\x04\x08st\
andard\x07premium\x06neural\x06studio\x04\0\x0dvoice-quality\x03\0\x0a\x01m\x02\x05\
plain\x04ssml\x04\0\x09text-type\x03\0\x0c\x01m\x08\x03mp3\x03wav\x03pcm\x08ogg-\
opus\x03aac\x04flac\x05mulaw\x04alaw\x04\0\x0caudio-format\x03\0\x0e\x01ky\x01k}\
\x01r\x04\x06format\x0f\x0bsample-rate\x10\x08bit-rate\x10\x08channels\x11\x04\0\
\x0caudio-config\x03\0\x12\x01kv\x01r\x06\x05speed\x14\x05pitch\x14\x06volume\x14\
\x09stability\x14\x0asimilarity\x14\x05style\x14\x04\0\x0evoice-settings\x03\0\x15\
\x01n\x07\x11telephone-quality\x13headphone-optimized\x11speaker-optimized\x13ca\
r-audio-optimized\x0fnoise-reduction\x0abass-boost\x0ctreble-boost\x04\0\x0daudi\
o-effects\x03\0\x17\x01k\x07\x01r\x03\x07contents\x09text-type\x0d\x08language\x19\
\x04\0\x0atext-input\x03\0\x1a\x01ks\x01r\x06\x10duration-secondsv\x0fcharacter-\
county\x0aword-county\x10audio-size-bytesy\x0arequest-ids\x0dprovider-info\x1c\x04\
\0\x12synthesis-metadata\x03\0\x1d\x01p}\x01r\x02\x0aaudio-data\x1f\x08metadata\x1e\
\x04\0\x10synthesis-result\x03\0\x20\x01m\x05\x04word\x08sentence\x09paragraph\x09\
ssml-mark\x06viseme\x04\0\x10timing-mark-type\x03\0\"\x01k#\x01r\x04\x12start-ti\
me-secondsv\x10end-time-seconds\x14\x0btext-offset\x10\x09mark-type$\x04\0\x0bti\
ming-info\x03\0%\x01k&\x01r\x04\x04data\x1f\x0fsequence-numbery\x08is-final\x7f\x0b\
timing-info'\x04\0\x0baudio-chunk\x03\0(\x03\0\x15golem:tts/types@1.0.0\x05\0\x02\
\x03\0\0\x09tts-error\x02\x03\0\0\x0dlanguage-code\x02\x03\0\0\x0cvoice-gender\x02\
\x03\0\0\x0dvoice-quality\x02\x03\0\0\x0evoice-settings\x02\x03\0\0\x0caudio-for\
mat\x01BV\x02\x03\x02\x01\x01\x04\0\x09tts-error\x03\0\0\x02\x03\x02\x01\x02\x04\
\0\x0dlanguage-code\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0cvoice-gender\x03\0\x04\
\x02\x03\x02\x01\x04\x04\0\x0dvoice-quality\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x0e\
voice-settings\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x0caudio-format\x03\0\x0a\x04\
\0\x05voice\x03\x01\x01k\x03\x01k\x05\x01k\x07\x01k\x7f\x01ks\x01r\x06\x08langua\
ge\x0d\x06gender\x0e\x07quality\x0f\x0dsupports-ssml\x10\x08provider\x11\x0csear\
ch-query\x11\x04\0\x0cvoice-filter\x03\0\x12\x01p\x03\x01ps\x01r\x0d\x02ids\x04n\
ames\x08language\x03\x14additional-languages\x14\x06gender\x05\x07quality\x07\x0b\
description\x11\x08providers\x0bsample-ratey\x09is-custom\x7f\x09is-cloned\x7f\x0b\
preview-url\x11\x09use-cases\x15\x04\0\x0avoice-info\x03\0\x16\x04\0\x0dvoice-re\
sults\x03\x01\x01r\x04\x04code\x03\x04names\x0bnative-names\x0bvoice-county\x04\0\
\x0dlanguage-info\x03\0\x19\x01h\x0c\x01@\x01\x04self\x1b\0s\x04\0\x14[method]vo\
ice.get-id\x01\x1c\x04\0\x16[method]voice.get-name\x01\x1c\x01@\x01\x04self\x1b\0\
\x11\x04\0\x1d[method]voice.get-provider-id\x01\x1d\x01@\x01\x04self\x1b\0\x03\x04\
\0\x1a[method]voice.get-language\x01\x1e\x01@\x01\x04self\x1b\0\x14\x04\0&[metho\
d]voice.get-additional-languages\x01\x1f\x01@\x01\x04self\x1b\0\x05\x04\0\x18[me\
thod]voice.get-gender\x01\x20\x01@\x01\x04self\x1b\0\x07\x04\0\x19[method]voice.\
get-quality\x01!\x04\0\x1d[method]voice.get-description\x01\x1d\x01@\x01\x04self\
\x1b\0\x7f\x04\0\x1b[method]voice.supports-ssml\x01\"\x01py\x01@\x01\x04self\x1b\
\0#\x04\0\x1e[method]voice.get-sample-rates\x01$\x01p\x0b\x01@\x01\x04self\x1b\0\
%\x04\0#[method]voice.get-supported-formats\x01&\x01j\0\x01\x01\x01@\x02\x04self\
\x1b\x08settings\x09\0'\x04\0\x1d[method]voice.update-settings\x01(\x01@\x01\x04\
self\x1b\0'\x04\0\x14[method]voice.delete\x01)\x01i\x0c\x01j\x01*\x01\x01\x01@\x01\
\x04self\x1b\0+\x04\0\x13[method]voice.clone\x01,\x01p}\x01j\x01-\x01\x01\x01@\x02\
\x04self\x1b\x04texts\0.\x04\0\x15[method]voice.preview\x01/\x01h\x18\x01@\x01\x04\
self0\0\x7f\x04\0\x1e[method]voice-results.has-more\x011\x01p\x17\x01j\x012\x01\x01\
\x01@\x01\x04self0\03\x04\0\x1e[method]voice-results.get-next\x014\x01ky\x01@\x01\
\x04self0\05\x04\0%[method]voice-results.get-total-count\x016\x01k\x13\x01i\x18\x01\
j\x018\x01\x01\x01@\x01\x06filter7\09\x04\0\x0blist-voices\x01:\x01@\x01\x08voic\
e-ids\0+\x04\0\x09get-voice\x01;\x01@\x02\x05querys\x06filter7\03\x04\0\x0dsearc\
h-voices\x01<\x01p\x1a\x01j\x01=\x01\x01\x01@\0\0>\x04\0\x0elist-languages\x01?\x04\
\0\x16golem:tts/voices@1.0.0\x05\x07\x02\x03\0\0\x0atext-input\x02\x03\0\0\x0cau\
dio-config\x02\x03\0\0\x0daudio-effects\x02\x03\0\0\x10synthesis-result\x02\x03\0\
\0\x0btiming-info\x02\x03\0\x01\x05voice\x01B0\x02\x03\x02\x01\x08\x04\0\x0atext\
-input\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0caudio-config\x03\0\x02\x02\x03\x02\x01\
\x05\x04\0\x0evoice-settings\x03\0\x04\x02\x03\x02\x01\x0a\x04\0\x0daudio-effect\
s\x03\0\x06\x02\x03\x02\x01\x0b\x04\0\x10synthesis-result\x03\0\x08\x02\x03\x02\x01\
\x01\x04\0\x09tts-error\x03\0\x0a\x02\x03\x02\x01\x0c\x04\0\x0btiming-info\x03\0\
\x0c\x02\x03\x02\x01\x0d\x04\0\x05voice\x03\0\x0e\x01ks\x01r\x05\x0dprevious-tex\
t\x10\x09next-text\x10\x05topic\x10\x07emotion\x10\x0espeaking-style\x10\x04\0\x11\
synthesis-context\x03\0\x11\x01k\x03\x01k\x05\x01k\x07\x01k\x7f\x01ky\x01k\x12\x01\
r\x08\x0caudio-config\x13\x0evoice-settings\x14\x0daudio-effects\x15\x0denable-t\
iming\x16\x12enable-word-timing\x16\x04seed\x17\x0dmodel-version\x10\x07context\x18\
\x04\0\x11synthesis-options\x03\0\x19\x01kv\x01ps\x01r\x05\x08is-valid\x7f\x0fch\
aracter-county\x12estimated-duration\x1b\x08warnings\x1c\x06errors\x1c\x04\0\x11\
validation-result\x03\0\x1d\x01h\x0f\x01k\x1a\x01j\x01\x09\x01\x0b\x01@\x03\x05i\
nput\x01\x05voice\x1f\x07options\x20\0!\x04\0\x0asynthesize\x01\"\x01p\x01\x01p\x09\
\x01j\x01$\x01\x0b\x01@\x03\x06inputs#\x05voice\x1f\x07options\x20\0%\x04\0\x10s\
ynthesize-batch\x01&\x01p\x0d\x01j\x01'\x01\x0b\x01@\x02\x05input\x01\x05voice\x1f\
\0(\x04\0\x10get-timing-marks\x01)\x01j\x01\x1e\x01\x0b\x01@\x02\x05input\x01\x05\
voice\x1f\0*\x04\0\x0evalidate-input\x01+\x04\0\x19golem:tts/synthesis@1.0.0\x05\
\x0e\x02\x03\0\0\x0baudio-chunk\x02\x03\0\x02\x11synthesis-options\x01B8\x02\x03\
\x02\x01\x08\x04\0\x0atext-input\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0caudio-conf\
ig\x03\0\x02\x02\x03\x02\x01\x05\x04\0\x0evoice-settings\x03\0\x04\x02\x03\x02\x01\
\x0f\x04\0\x0baudio-chunk\x03\0\x06\x02\x03\x02\x01\x01\x04\0\x09tts-error\x03\0\
\x08\x02\x03\x02\x01\x0c\x04\0\x0btiming-info\x03\0\x0a\x02\x03\x02\x01\x0d\x04\0\
\x05voice\x03\0\x0c\x02\x03\x02\x01\x10\x04\0\x11synthesis-options\x03\0\x0e\x04\
\0\x10synthesis-stream\x03\x01\x01m\x05\x05ready\x0aprocessing\x08finished\x05er\
ror\x06closed\x04\0\x0dstream-status\x03\0\x11\x04\0\x17voice-conversion-stream\x03\
\x01\x01h\x10\x01j\0\x01\x09\x01@\x02\x04self\x14\x05input\x01\0\x15\x04\0\"[met\
hod]synthesis-stream.send-text\x01\x16\x01@\x01\x04self\x14\0\x15\x04\0\x1f[meth\
od]synthesis-stream.finish\x01\x17\x01k\x07\x01j\x01\x18\x01\x09\x01@\x01\x04sel\
f\x14\0\x19\x04\0&[method]synthesis-stream.receive-chunk\x01\x1a\x01@\x01\x04sel\
f\x14\0\x7f\x04\0*[method]synthesis-stream.has-pending-audio\x01\x1b\x01@\x01\x04\
self\x14\0\x12\x04\0#[method]synthesis-stream.get-status\x01\x1c\x01@\x01\x04sel\
f\x14\x01\0\x04\0\x1e[method]synthesis-stream.close\x01\x1d\x01h\x13\x01p}\x01@\x02\
\x04self\x1e\x0aaudio-data\x1f\0\x15\x04\0*[method]voice-conversion-stream.send-\
audio\x01\x20\x01@\x01\x04self\x1e\0\x19\x04\01[method]voice-conversion-stream.r\
eceive-converted\x01!\x01@\x01\x04self\x1e\0\x15\x04\0&[method]voice-conversion-\
stream.finish\x01\"\x01@\x01\x04self\x1e\x01\0\x04\0%[method]voice-conversion-st\
ream.close\x01#\x01h\x0d\x01k\x0f\x01i\x10\x01j\x01&\x01\x09\x01@\x02\x05voice$\x07\
options%\0'\x04\0\x0dcreate-stream\x01(\x01i\x13\x01j\x01)\x01\x09\x01@\x02\x0ct\
arget-voice$\x07options%\0*\x04\0\x1ecreate-voice-conversion-stream\x01+\x04\0\x19\
golem:tts/streaming@1.0.0\x05\x11\x02\x03\0\0\x12synthesis-metadata\x01BT\x02\x03\
\x02\x01\x01\x04\0\x09tts-error\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0caudio-confi\
g\x03\0\x02\x02\x03\x02\x01\x02\x04\0\x0dlanguage-code\x03\0\x04\x02\x03\x02\x01\
\x03\x04\0\x0cvoice-gender\x03\0\x06\x02\x03\x02\x01\x12\x04\0\x12synthesis-meta\
data\x03\0\x08\x02\x03\x02\x01\x0d\x04\0\x05voice\x03\0\x0a\x01p}\x01ks\x01k}\x01\
r\x03\x04data\x0c\x0atranscript\x0d\x0equality-rating\x0e\x04\0\x0caudio-sample\x03\
\0\x0f\x01m\x04\x05child\x0byoung-adult\x0bmiddle-aged\x07elderly\x04\0\x0cage-c\
ategory\x03\0\x11\x01ps\x01r\x05\x06gender\x07\x0cage-category\x12\x06accents\x12\
personality-traits\x13\x0freference-voice\x0d\x04\0\x13voice-design-params\x03\0\
\x14\x04\0\x15pronunciation-lexicon\x03\x01\x01r\x03\x04words\x0dpronunciations\x0e\
part-of-speech\x0d\x04\0\x13pronunciation-entry\x03\0\x17\x04\0\x13long-form-ope\
ration\x03\x01\x01m\x05\x07pending\x0aprocessing\x09completed\x06failed\x09cance\
lled\x04\0\x10operation-status\x03\0\x1a\x01pv\x01k\x1c\x01r\x04\x0foutput-locat\
ions\x0etotal-durationv\x11chapter-durations\x1d\x08metadata\x09\x04\0\x10long-f\
orm-result\x03\0\x1e\x01h\x16\x01@\x01\x04self\x20\0s\x04\0&[method]pronunciatio\
n-lexicon.get-name\x01!\x01@\x01\x04self\x20\0\x05\x04\0*[method]pronunciation-l\
exicon.get-language\x01\"\x01@\x01\x04self\x20\0y\x04\0-[method]pronunciation-le\
xicon.get-entry-count\x01#\x01j\0\x01\x01\x01@\x03\x04self\x20\x04words\x0dpronu\
nciations\0$\x04\0'[method]pronunciation-lexicon.add-entry\x01%\x01@\x02\x04self\
\x20\x04words\0$\x04\0*[method]pronunciation-lexicon.remove-entry\x01&\x01j\x01s\
\x01\x01\x01@\x01\x04self\x20\0'\x04\0,[method]pronunciation-lexicon.export-cont\
ent\x01(\x01h\x19\x01@\x01\x04self)\0\x1b\x04\0&[method]long-form-operation.get-\
status\x01*\x01@\x01\x04self)\0v\x04\0([method]long-form-operation.get-progress\x01\
+\x01@\x01\x04self)\0$\x04\0\"[method]long-form-operation.cancel\x01,\x01j\x01\x1f\
\x01\x01\x01@\x01\x04self)\0-\x04\0&[method]long-form-operation.get-result\x01.\x01\
p\x10\x01i\x0b\x01j\x010\x01\x01\x01@\x03\x04names\x0daudio-samples/\x0bdescript\
ion\x0d\01\x04\0\x12create-voice-clone\x012\x01@\x02\x04names\x0fcharacteristics\
\x15\01\x04\0\x0cdesign-voice\x013\x01h\x0b\x01k\x7f\x01j\x01\x0c\x01\x01\x01@\x03\
\x0binput-audio\x0c\x0ctarget-voice4\x0fpreserve-timing5\06\x04\0\x0dconvert-voi\
ce\x017\x01kv\x01@\x03\x0bdescriptions\x10duration-seconds8\x0fstyle-influence8\0\
6\x04\0\x15generate-sound-effect\x019\x01p\x18\x01k:\x01i\x16\x01j\x01<\x01\x01\x01\
@\x03\x04names\x08language\x05\x07entries;\0=\x04\0\x0ecreate-lexicon\x01>\x01py\
\x01k?\x01i\x19\x01j\x01\xc1\0\x01\x01\x01@\x04\x07contents\x05voice4\x0foutput-\
locations\x0echapter-breaks\xc0\0\0\xc2\0\x04\0\x14synthesize-long-form\x01C\x04\
\0\x18golem:tts/advanced@1.0.0\x05\x13\x04\0&golem:tts-elevenlabs/tts-library@1.\
0.0\x04\0\x0b\x11\x01\0\x0btts-library\x03\0\0\0G\x09producers\x01\x0cprocessed-\
by\x02\x0dwit-component\x070.227.1\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
