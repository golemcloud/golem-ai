package golem:exec@1.0.0;

interface types {
  /// Supported language types and optional version
  record language {
    kind: language-kind,
    version: option<string>,
  }

  enum language-kind {
    javascript,
    python,
  }

  enum encoding {
    utf8,
    base64,
    hex,
  }

  record file {
    name: string,
    content: list<u8>,
    encoding: option<encoding>,
  }

  record limits {
    time-ms: option<u64>,
    memory-bytes: option<u64>,
    file-size-bytes: option<u64>,
    max-processes: option<u32>,
  }

  record stage-result {
    stdout: string,
    stderr: string,
    exit-code: option<s32>,
    signal: option<string>,
  }

  record exec-result {
    compile: option<stage-result>,
    run: stage-result,
    time-ms: option<u64>,
    memory-bytes: option<u64>,
  }

  variant error {
    unsupported-language,
    compilation-failed(stage-result),
    runtime-failed(stage-result),
    timeout,
    resource-exceeded,
    internal(string),
  }

  variant exec-event {
    stdout-chunk(list<u8>),
    stderr-chunk(list<u8>),
    finished(exec-result),
    failed(error),
  }
}

interface input-stream {
  resource input-stream {
    get-next: func() -> option<list<u8>>;
  }
}

interface output-stream {
  use types.{exec-event};

  resource output-stream {
    push: func(chunk: exec-event);
    close: func();
  }
}

interface executor {
  use types.{language, file, limits, exec-result, error, exec-event};
  use input-stream.{input-stream};
  use output-stream.{output-stream};

  run: func(
    lang: language,
    files: list<file>,
    stdin: option<string>,
    args: list<string>,
    env: list<tuple<string, string>>,
    constraints: option<limits>
  ) -> result<exec-result, error>;

  run-streaming: func(
    lang: language,
    files: list<file>,
    stdin: option<borrow<input-stream>>,
    args: list<string>,
    env: list<tuple<string, string>>,
    constraints: option<limits>,
    output: borrow<output-stream>
  ) -> result<_, error>;
}

interface session {
   use types.{language, file, limits, exec-result, error};
  use input-stream.{input-stream};
  use output-stream.{output-stream};

  resource session {
    constructor(lang: language);

    upload: func( file: file) -> result<_, error>;

    run: func(
      
      entrypoint: string,
      args: list<string>,
      stdin: option<string>,
      env: list<tuple<string, string>>,
      constraints: option<limits>
    ) -> result<exec-result, error>;

    run-streaming: func(
      
      entrypoint: string,
      args: list<string>,
      stdin: option<borrow<input-stream>>,
      env: list<tuple<string, string>>,
      constraints: option<limits>,
      output: borrow<output-stream>
    ) -> result<_, error>;

    download: func( path: string) -> result<list<u8>, error>;
    list-files: func( dir: string) -> result<list<string>, error>;
    set-working-dir: func(path: string) -> result<_, error>;
    close: func();
  }
}

world exec-component {
  export executor;
  export session;
}
