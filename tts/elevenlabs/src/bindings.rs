// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * generate_unused_types
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod exports {
    pub mod golem {
        pub mod tts {
            /// Core types and error handling for universal text-to-speech
            #[allow(dead_code, clippy::all)]
            pub mod types {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum QuotaUnit {
                    Characters,
                    Requests,
                    Seconds,
                    Credits,
                }
                impl ::core::fmt::Debug for QuotaUnit {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            QuotaUnit::Characters => {
                                f.debug_tuple("QuotaUnit::Characters").finish()
                            }
                            QuotaUnit::Requests => {
                                f.debug_tuple("QuotaUnit::Requests").finish()
                            }
                            QuotaUnit::Seconds => {
                                f.debug_tuple("QuotaUnit::Seconds").finish()
                            }
                            QuotaUnit::Credits => {
                                f.debug_tuple("QuotaUnit::Credits").finish()
                            }
                        }
                    }
                }
                impl QuotaUnit {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> QuotaUnit {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => QuotaUnit::Characters,
                            1 => QuotaUnit::Requests,
                            2 => QuotaUnit::Seconds,
                            3 => QuotaUnit::Credits,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct QuotaInfo {
                    pub used: u32,
                    pub limit: u32,
                    pub reset_time: u64,
                    pub unit: QuotaUnit,
                }
                impl ::core::fmt::Debug for QuotaInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("QuotaInfo")
                            .field("used", &self.used)
                            .field("limit", &self.limit)
                            .field("reset-time", &self.reset_time)
                            .field("unit", &self.unit)
                            .finish()
                    }
                }
                /// Comprehensive error types covering all TTS operations
                #[derive(Clone)]
                pub enum TtsError {
                    /// Input validation errors
                    InvalidText(_rt::String),
                    TextTooLong(u32),
                    InvalidSsml(_rt::String),
                    UnsupportedLanguage(_rt::String),
                    /// Voice and model errors
                    VoiceNotFound(_rt::String),
                    ModelNotFound(_rt::String),
                    VoiceUnavailable(_rt::String),
                    /// Authentication and authorization
                    Unauthorized(_rt::String),
                    AccessDenied(_rt::String),
                    /// Resource and quota limits
                    QuotaExceeded(QuotaInfo),
                    RateLimited(u32),
                    InsufficientCredits,
                    /// Operation errors
                    SynthesisFailed(_rt::String),
                    UnsupportedOperation(_rt::String),
                    InvalidConfiguration(_rt::String),
                    /// Service errors
                    ServiceUnavailable(_rt::String),
                    NetworkError(_rt::String),
                    InternalError(_rt::String),
                    /// Storage errors (for async operations)
                    InvalidStorageLocation(_rt::String),
                    StorageAccessDenied(_rt::String),
                }
                impl ::core::fmt::Debug for TtsError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            TtsError::InvalidText(e) => {
                                f.debug_tuple("TtsError::InvalidText").field(e).finish()
                            }
                            TtsError::TextTooLong(e) => {
                                f.debug_tuple("TtsError::TextTooLong").field(e).finish()
                            }
                            TtsError::InvalidSsml(e) => {
                                f.debug_tuple("TtsError::InvalidSsml").field(e).finish()
                            }
                            TtsError::UnsupportedLanguage(e) => {
                                f.debug_tuple("TtsError::UnsupportedLanguage")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::VoiceNotFound(e) => {
                                f.debug_tuple("TtsError::VoiceNotFound").field(e).finish()
                            }
                            TtsError::ModelNotFound(e) => {
                                f.debug_tuple("TtsError::ModelNotFound").field(e).finish()
                            }
                            TtsError::VoiceUnavailable(e) => {
                                f.debug_tuple("TtsError::VoiceUnavailable")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::Unauthorized(e) => {
                                f.debug_tuple("TtsError::Unauthorized").field(e).finish()
                            }
                            TtsError::AccessDenied(e) => {
                                f.debug_tuple("TtsError::AccessDenied").field(e).finish()
                            }
                            TtsError::QuotaExceeded(e) => {
                                f.debug_tuple("TtsError::QuotaExceeded").field(e).finish()
                            }
                            TtsError::RateLimited(e) => {
                                f.debug_tuple("TtsError::RateLimited").field(e).finish()
                            }
                            TtsError::InsufficientCredits => {
                                f.debug_tuple("TtsError::InsufficientCredits").finish()
                            }
                            TtsError::SynthesisFailed(e) => {
                                f.debug_tuple("TtsError::SynthesisFailed").field(e).finish()
                            }
                            TtsError::UnsupportedOperation(e) => {
                                f.debug_tuple("TtsError::UnsupportedOperation")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::InvalidConfiguration(e) => {
                                f.debug_tuple("TtsError::InvalidConfiguration")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::ServiceUnavailable(e) => {
                                f.debug_tuple("TtsError::ServiceUnavailable")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::NetworkError(e) => {
                                f.debug_tuple("TtsError::NetworkError").field(e).finish()
                            }
                            TtsError::InternalError(e) => {
                                f.debug_tuple("TtsError::InternalError").field(e).finish()
                            }
                            TtsError::InvalidStorageLocation(e) => {
                                f.debug_tuple("TtsError::InvalidStorageLocation")
                                    .field(e)
                                    .finish()
                            }
                            TtsError::StorageAccessDenied(e) => {
                                f.debug_tuple("TtsError::StorageAccessDenied")
                                    .field(e)
                                    .finish()
                            }
                        }
                    }
                }
                impl ::core::fmt::Display for TtsError {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        write!(f, "{:?}", self)
                    }
                }
                impl std::error::Error for TtsError {}
                /// Language identification using BCP 47 codes
                pub type LanguageCode = _rt::String;
                /// Voice gender classification
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum VoiceGender {
                    Male,
                    Female,
                    Neutral,
                }
                impl ::core::fmt::Debug for VoiceGender {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            VoiceGender::Male => {
                                f.debug_tuple("VoiceGender::Male").finish()
                            }
                            VoiceGender::Female => {
                                f.debug_tuple("VoiceGender::Female").finish()
                            }
                            VoiceGender::Neutral => {
                                f.debug_tuple("VoiceGender::Neutral").finish()
                            }
                        }
                    }
                }
                impl VoiceGender {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> VoiceGender {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => VoiceGender::Male,
                            1 => VoiceGender::Female,
                            2 => VoiceGender::Neutral,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Voice quality tiers
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum VoiceQuality {
                    Standard,
                    Premium,
                    Neural,
                    Studio,
                }
                impl ::core::fmt::Debug for VoiceQuality {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            VoiceQuality::Standard => {
                                f.debug_tuple("VoiceQuality::Standard").finish()
                            }
                            VoiceQuality::Premium => {
                                f.debug_tuple("VoiceQuality::Premium").finish()
                            }
                            VoiceQuality::Neural => {
                                f.debug_tuple("VoiceQuality::Neural").finish()
                            }
                            VoiceQuality::Studio => {
                                f.debug_tuple("VoiceQuality::Studio").finish()
                            }
                        }
                    }
                }
                impl VoiceQuality {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> VoiceQuality {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => VoiceQuality::Standard,
                            1 => VoiceQuality::Premium,
                            2 => VoiceQuality::Neural,
                            3 => VoiceQuality::Studio,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Text input types
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum TextType {
                    Plain,
                    Ssml,
                }
                impl ::core::fmt::Debug for TextType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            TextType::Plain => f.debug_tuple("TextType::Plain").finish(),
                            TextType::Ssml => f.debug_tuple("TextType::Ssml").finish(),
                        }
                    }
                }
                impl TextType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> TextType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => TextType::Plain,
                            1 => TextType::Ssml,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Audio output formats
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AudioFormat {
                    Mp3,
                    Wav,
                    Pcm,
                    OggOpus,
                    Aac,
                    Flac,
                    Mulaw,
                    Alaw,
                }
                impl ::core::fmt::Debug for AudioFormat {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AudioFormat::Mp3 => {
                                f.debug_tuple("AudioFormat::Mp3").finish()
                            }
                            AudioFormat::Wav => {
                                f.debug_tuple("AudioFormat::Wav").finish()
                            }
                            AudioFormat::Pcm => {
                                f.debug_tuple("AudioFormat::Pcm").finish()
                            }
                            AudioFormat::OggOpus => {
                                f.debug_tuple("AudioFormat::OggOpus").finish()
                            }
                            AudioFormat::Aac => {
                                f.debug_tuple("AudioFormat::Aac").finish()
                            }
                            AudioFormat::Flac => {
                                f.debug_tuple("AudioFormat::Flac").finish()
                            }
                            AudioFormat::Mulaw => {
                                f.debug_tuple("AudioFormat::Mulaw").finish()
                            }
                            AudioFormat::Alaw => {
                                f.debug_tuple("AudioFormat::Alaw").finish()
                            }
                        }
                    }
                }
                impl AudioFormat {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AudioFormat {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AudioFormat::Mp3,
                            1 => AudioFormat::Wav,
                            2 => AudioFormat::Pcm,
                            3 => AudioFormat::OggOpus,
                            4 => AudioFormat::Aac,
                            5 => AudioFormat::Flac,
                            6 => AudioFormat::Mulaw,
                            7 => AudioFormat::Alaw,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Audio quality settings
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct AudioConfig {
                    pub format: AudioFormat,
                    pub sample_rate: Option<u32>,
                    pub bit_rate: Option<u32>,
                    pub channels: Option<u8>,
                }
                impl ::core::fmt::Debug for AudioConfig {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AudioConfig")
                            .field("format", &self.format)
                            .field("sample-rate", &self.sample_rate)
                            .field("bit-rate", &self.bit_rate)
                            .field("channels", &self.channels)
                            .finish()
                    }
                }
                /// Voice synthesis parameters
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct VoiceSettings {
                    /// Speaking rate (0.25 to 4.0, default 1.0)
                    pub speed: Option<f32>,
                    /// Pitch adjustment in semitones (-20.0 to 20.0, default 0.0)
                    pub pitch: Option<f32>,
                    /// Volume gain in dB (-96.0 to 16.0, default 0.0)
                    pub volume: Option<f32>,
                    /// Voice stability (0.0 to 1.0, provider-specific)
                    pub stability: Option<f32>,
                    /// Similarity to original (0.0 to 1.0, provider-specific)
                    pub similarity: Option<f32>,
                    /// Style exaggeration (0.0 to 1.0, provider-specific)
                    pub style: Option<f32>,
                }
                impl ::core::fmt::Debug for VoiceSettings {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceSettings")
                            .field("speed", &self.speed)
                            .field("pitch", &self.pitch)
                            .field("volume", &self.volume)
                            .field("stability", &self.stability)
                            .field("similarity", &self.similarity)
                            .field("style", &self.style)
                            .finish()
                    }
                }
                /// Audio effects and device optimization
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AudioEffects {
                    TelephoneQuality,
                    HeadphoneOptimized,
                    SpeakerOptimized,
                    CarAudioOptimized,
                    NoiseReduction,
                    BassBoost,
                    TrebleBoost,
                }
                impl ::core::fmt::Debug for AudioEffects {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AudioEffects::TelephoneQuality => {
                                f.debug_tuple("AudioEffects::TelephoneQuality").finish()
                            }
                            AudioEffects::HeadphoneOptimized => {
                                f.debug_tuple("AudioEffects::HeadphoneOptimized").finish()
                            }
                            AudioEffects::SpeakerOptimized => {
                                f.debug_tuple("AudioEffects::SpeakerOptimized").finish()
                            }
                            AudioEffects::CarAudioOptimized => {
                                f.debug_tuple("AudioEffects::CarAudioOptimized").finish()
                            }
                            AudioEffects::NoiseReduction => {
                                f.debug_tuple("AudioEffects::NoiseReduction").finish()
                            }
                            AudioEffects::BassBoost => {
                                f.debug_tuple("AudioEffects::BassBoost").finish()
                            }
                            AudioEffects::TrebleBoost => {
                                f.debug_tuple("AudioEffects::TrebleBoost").finish()
                            }
                        }
                    }
                }
                impl AudioEffects {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AudioEffects {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AudioEffects::TelephoneQuality,
                            1 => AudioEffects::HeadphoneOptimized,
                            2 => AudioEffects::SpeakerOptimized,
                            3 => AudioEffects::CarAudioOptimized,
                            4 => AudioEffects::NoiseReduction,
                            5 => AudioEffects::BassBoost,
                            6 => AudioEffects::TrebleBoost,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Input text with metadata
                #[derive(Clone)]
                pub struct TextInput {
                    pub content: _rt::String,
                    pub text_type: TextType,
                    pub language: Option<LanguageCode>,
                }
                impl ::core::fmt::Debug for TextInput {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("TextInput")
                            .field("content", &self.content)
                            .field("text-type", &self.text_type)
                            .field("language", &self.language)
                            .finish()
                    }
                }
                /// Metadata about synthesized audio
                #[derive(Clone)]
                pub struct SynthesisMetadata {
                    pub duration_seconds: f32,
                    pub character_count: u32,
                    pub word_count: u32,
                    pub audio_size_bytes: u32,
                    pub request_id: _rt::String,
                    pub provider_info: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for SynthesisMetadata {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisMetadata")
                            .field("duration-seconds", &self.duration_seconds)
                            .field("character-count", &self.character_count)
                            .field("word-count", &self.word_count)
                            .field("audio-size-bytes", &self.audio_size_bytes)
                            .field("request-id", &self.request_id)
                            .field("provider-info", &self.provider_info)
                            .finish()
                    }
                }
                /// Complete synthesis result
                #[derive(Clone)]
                pub struct SynthesisResult {
                    pub audio_data: _rt::Vec<u8>,
                    pub metadata: SynthesisMetadata,
                }
                impl ::core::fmt::Debug for SynthesisResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisResult")
                            .field("audio-data", &self.audio_data)
                            .field("metadata", &self.metadata)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum TimingMarkType {
                    Word,
                    Sentence,
                    Paragraph,
                    SsmlMark,
                    Viseme,
                }
                impl ::core::fmt::Debug for TimingMarkType {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            TimingMarkType::Word => {
                                f.debug_tuple("TimingMarkType::Word").finish()
                            }
                            TimingMarkType::Sentence => {
                                f.debug_tuple("TimingMarkType::Sentence").finish()
                            }
                            TimingMarkType::Paragraph => {
                                f.debug_tuple("TimingMarkType::Paragraph").finish()
                            }
                            TimingMarkType::SsmlMark => {
                                f.debug_tuple("TimingMarkType::SsmlMark").finish()
                            }
                            TimingMarkType::Viseme => {
                                f.debug_tuple("TimingMarkType::Viseme").finish()
                            }
                        }
                    }
                }
                impl TimingMarkType {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> TimingMarkType {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => TimingMarkType::Word,
                            1 => TimingMarkType::Sentence,
                            2 => TimingMarkType::Paragraph,
                            3 => TimingMarkType::SsmlMark,
                            4 => TimingMarkType::Viseme,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                /// Timing and synchronization information
                #[repr(C)]
                #[derive(Clone, Copy)]
                pub struct TimingInfo {
                    pub start_time_seconds: f32,
                    pub end_time_seconds: Option<f32>,
                    pub text_offset: Option<u32>,
                    pub mark_type: Option<TimingMarkType>,
                }
                impl ::core::fmt::Debug for TimingInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("TimingInfo")
                            .field("start-time-seconds", &self.start_time_seconds)
                            .field("end-time-seconds", &self.end_time_seconds)
                            .field("text-offset", &self.text_offset)
                            .field("mark-type", &self.mark_type)
                            .finish()
                    }
                }
                /// Streaming audio chunk
                #[derive(Clone)]
                pub struct AudioChunk {
                    pub data: _rt::Vec<u8>,
                    pub sequence_number: u32,
                    pub is_final: bool,
                    pub timing_info: Option<TimingInfo>,
                }
                impl ::core::fmt::Debug for AudioChunk {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AudioChunk")
                            .field("data", &self.data)
                            .field("sequence-number", &self.sequence_number)
                            .field("is-final", &self.is_final)
                            .field("timing-info", &self.timing_info)
                            .finish()
                    }
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_types_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = {};
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_types_1_0_0_cabi;
            }
            /// Voice discovery and management
            #[allow(dead_code, clippy::all)]
            pub mod voices {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TtsError = super::super::super::super::exports::golem::tts::types::TtsError;
                pub type LanguageCode = super::super::super::super::exports::golem::tts::types::LanguageCode;
                pub type VoiceGender = super::super::super::super::exports::golem::tts::types::VoiceGender;
                pub type VoiceQuality = super::super::super::super::exports::golem::tts::types::VoiceQuality;
                pub type AudioFormat = super::super::super::super::exports::golem::tts::types::AudioFormat;
                pub type VoiceSettings = super::super::super::super::exports::golem::tts::types::VoiceSettings;
                /// Represents a voice that can be used for speech synthesis
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct Voice {
                    handle: _rt::Resource<Voice>,
                }
                type _VoiceRep<T> = Option<T>;
                impl Voice {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `Voice`.
                    pub fn new<T: GuestVoice>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceRep<T> = Some(val);
                        let ptr: *mut _VoiceRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoice>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoice>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoice>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _VoiceRep<T>);
                    }
                    fn as_ptr<T: GuestVoice>(&self) -> *mut _VoiceRep<T> {
                        Voice::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`Voice`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a Voice>,
                }
                impl<'a> VoiceBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoice>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceRep<T> {
                        Voice::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for Voice {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]voice"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                /// Voice search and filtering
                #[derive(Clone)]
                pub struct VoiceFilter {
                    pub language: Option<LanguageCode>,
                    pub gender: Option<VoiceGender>,
                    pub quality: Option<VoiceQuality>,
                    pub supports_ssml: Option<bool>,
                    pub provider: Option<_rt::String>,
                    pub search_query: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceFilter {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceFilter")
                            .field("language", &self.language)
                            .field("gender", &self.gender)
                            .field("quality", &self.quality)
                            .field("supports-ssml", &self.supports_ssml)
                            .field("provider", &self.provider)
                            .field("search-query", &self.search_query)
                            .finish()
                    }
                }
                /// Detailed voice information
                #[derive(Clone)]
                pub struct VoiceInfo {
                    pub id: _rt::String,
                    pub name: _rt::String,
                    pub language: LanguageCode,
                    pub additional_languages: _rt::Vec<LanguageCode>,
                    pub gender: VoiceGender,
                    pub quality: VoiceQuality,
                    pub description: Option<_rt::String>,
                    pub provider: _rt::String,
                    pub sample_rate: u32,
                    pub is_custom: bool,
                    pub is_cloned: bool,
                    pub preview_url: Option<_rt::String>,
                    pub use_cases: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceInfo")
                            .field("id", &self.id)
                            .field("name", &self.name)
                            .field("language", &self.language)
                            .field("additional-languages", &self.additional_languages)
                            .field("gender", &self.gender)
                            .field("quality", &self.quality)
                            .field("description", &self.description)
                            .field("provider", &self.provider)
                            .field("sample-rate", &self.sample_rate)
                            .field("is-custom", &self.is_custom)
                            .field("is-cloned", &self.is_cloned)
                            .field("preview-url", &self.preview_url)
                            .field("use-cases", &self.use_cases)
                            .finish()
                    }
                }
                /// Resource-based iterator for voice results
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceResults {
                    handle: _rt::Resource<VoiceResults>,
                }
                type _VoiceResultsRep<T> = Option<T>;
                impl VoiceResults {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `VoiceResults`.
                    pub fn new<T: GuestVoiceResults>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceResultsRep<T> = Some(val);
                        let ptr: *mut _VoiceResultsRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoiceResults>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoiceResults>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoiceResults>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(handle as *mut _VoiceResultsRep<T>);
                    }
                    fn as_ptr<T: GuestVoiceResults>(&self) -> *mut _VoiceResultsRep<T> {
                        VoiceResults::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`VoiceResults`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceResultsBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a VoiceResults>,
                }
                impl<'a> VoiceResultsBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoiceResults>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceResultsRep<T> {
                        VoiceResults::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for VoiceResults {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]voice-results"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[derive(Clone)]
                pub struct LanguageInfo {
                    pub code: LanguageCode,
                    pub name: _rt::String,
                    pub native_name: _rt::String,
                    pub voice_count: u32,
                }
                impl ::core::fmt::Debug for LanguageInfo {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LanguageInfo")
                            .field("code", &self.code)
                            .field("name", &self.name)
                            .field("native-name", &self.native_name)
                            .field("voice-count", &self.voice_count)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_id_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_id(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_id<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_name_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_name(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_name<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_provider_id_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_provider_id(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1.add(8).cast::<usize>() = len2;
                            *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_provider_id<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_language_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_language(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_language<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_additional_languages_cabi<
                    T: GuestVoice,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_additional_languages(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec3 = result0;
                    let len3 = vec3.len();
                    let layout3 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec3.len() * 8,
                        4,
                    );
                    let result3 = if layout3.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout3).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout3);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec3.into_iter().enumerate() {
                        let base = result3.add(i * 8);
                        {
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *base.add(4).cast::<usize>() = len2;
                            *base.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len3;
                    *ptr1.add(0).cast::<*mut u8>() = result3;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_additional_languages<
                    T: GuestVoice,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base4 = l0;
                    let len4 = l1;
                    for i in 0..len4 {
                        let base = base4.add(i * 8);
                        {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            _rt::cabi_dealloc(l2, l3, 1);
                        }
                    }
                    _rt::cabi_dealloc(base4, len4 * 8, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_gender_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_gender(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_quality_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_quality(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_description_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_description(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1.add(8).cast::<usize>() = len2;
                            *ptr1.add(4).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_description<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = *arg0.add(4).cast::<*mut u8>();
                            let l2 = *arg0.add(8).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_supports_ssml_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::supports_ssml(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_sample_rates_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_sample_rates(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_sample_rates<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 4, 4);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_get_supported_formats_cabi<
                    T: GuestVoice,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_supported_formats(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = result0;
                    let len2 = vec2.len();
                    let layout2 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec2.len() * 1,
                        1,
                    );
                    let result2 = if layout2.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout2).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout2);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec2.into_iter().enumerate() {
                        let base = result2.add(i * 1);
                        {
                            *base.add(0).cast::<u8>() = (e.clone() as i32) as u8;
                        }
                    }
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = result2;
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_get_supported_formats<
                    T: GuestVoice,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base2 = l0;
                    let len2 = l1;
                    _rt::cabi_dealloc(base2, len2 * 1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_update_settings_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                    arg1: i32,
                    arg2: f32,
                    arg3: i32,
                    arg4: f32,
                    arg5: i32,
                    arg6: f32,
                    arg7: i32,
                    arg8: f32,
                    arg9: i32,
                    arg10: f32,
                    arg11: i32,
                    arg12: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::update_settings(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                        super::super::super::super::exports::golem::tts::types::VoiceSettings {
                            speed: match arg1 {
                                0 => None,
                                1 => {
                                    let e = arg2;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            pitch: match arg3 {
                                0 => None,
                                1 => {
                                    let e = arg4;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            volume: match arg5 {
                                0 => None,
                                1 => {
                                    let e = arg6;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            stability: match arg7 {
                                0 => None,
                                1 => {
                                    let e = arg8;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            similarity: match arg9 {
                                0 => None,
                                1 => {
                                    let e = arg10;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            style: match arg11 {
                                0 => None,
                                1 => {
                                    let e = arg12;
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_update_settings<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_delete_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::delete(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_delete<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_clone_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::clone(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr1.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_clone<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_preview_cabi<T: GuestVoice>(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result1 = T::preview(
                        VoiceBorrow::lift(arg0 as u32 as usize).get(),
                        _rt::string_lift(bytes0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2.add(12).cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2.add(20).cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2.add(20).cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_preview<T: GuestVoice>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_has_more_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::has_more(
                        VoiceResultsBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_get_next_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_next(
                        VoiceResultsBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec13 = e;
                            let len13 = vec13.len();
                            let layout13 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec13.len() * 84,
                                4,
                            );
                            let result13 = if layout13.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout13).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout13);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec13.into_iter().enumerate() {
                                let base = result13.add(i * 84);
                                {
                                    let VoiceInfo {
                                        id: id2,
                                        name: name2,
                                        language: language2,
                                        additional_languages: additional_languages2,
                                        gender: gender2,
                                        quality: quality2,
                                        description: description2,
                                        provider: provider2,
                                        sample_rate: sample_rate2,
                                        is_custom: is_custom2,
                                        is_cloned: is_cloned2,
                                        preview_url: preview_url2,
                                        use_cases: use_cases2,
                                    } = e;
                                    let vec3 = (id2.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *base.add(4).cast::<usize>() = len3;
                                    *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                    let vec4 = (name2.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base.add(12).cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = (language2.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                    let vec7 = additional_languages2;
                                    let len7 = vec7.len();
                                    let layout7 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec7.len() * 8,
                                        4,
                                    );
                                    let result7 = if layout7.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout7).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout7);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec7.into_iter().enumerate() {
                                        let base = result7.add(i * 8);
                                        {
                                            let vec6 = (e.into_bytes()).into_boxed_slice();
                                            let ptr6 = vec6.as_ptr().cast::<u8>();
                                            let len6 = vec6.len();
                                            ::core::mem::forget(vec6);
                                            *base.add(4).cast::<usize>() = len6;
                                            *base.add(0).cast::<*mut u8>() = ptr6.cast_mut();
                                        }
                                    }
                                    *base.add(28).cast::<usize>() = len7;
                                    *base.add(24).cast::<*mut u8>() = result7;
                                    *base.add(32).cast::<u8>() = (gender2.clone() as i32) as u8;
                                    *base.add(33).cast::<u8>() = (quality2.clone() as i32)
                                        as u8;
                                    match description2 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec8 = (e.into_bytes()).into_boxed_slice();
                                            let ptr8 = vec8.as_ptr().cast::<u8>();
                                            let len8 = vec8.len();
                                            ::core::mem::forget(vec8);
                                            *base.add(44).cast::<usize>() = len8;
                                            *base.add(40).cast::<*mut u8>() = ptr8.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec9 = (provider2.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *base.add(52).cast::<usize>() = len9;
                                    *base.add(48).cast::<*mut u8>() = ptr9.cast_mut();
                                    *base.add(56).cast::<i32>() = _rt::as_i32(sample_rate2);
                                    *base.add(60).cast::<u8>() = (match is_custom2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base.add(61).cast::<u8>() = (match is_cloned2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match preview_url2 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec10 = (e.into_bytes()).into_boxed_slice();
                                            let ptr10 = vec10.as_ptr().cast::<u8>();
                                            let len10 = vec10.len();
                                            ::core::mem::forget(vec10);
                                            *base.add(72).cast::<usize>() = len10;
                                            *base.add(68).cast::<*mut u8>() = ptr10.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec12 = use_cases2;
                                    let len12 = vec12.len();
                                    let layout12 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec12.len() * 8,
                                        4,
                                    );
                                    let result12 = if layout12.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout12).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout12);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec12.into_iter().enumerate() {
                                        let base = result12.add(i * 8);
                                        {
                                            let vec11 = (e.into_bytes()).into_boxed_slice();
                                            let ptr11 = vec11.as_ptr().cast::<u8>();
                                            let len11 = vec11.len();
                                            ::core::mem::forget(vec11);
                                            *base.add(4).cast::<usize>() = len11;
                                            *base.add(0).cast::<*mut u8>() = ptr11.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len12;
                                    *base.add(76).cast::<*mut u8>() = result12;
                                }
                            }
                            *ptr1.add(12).cast::<usize>() = len13;
                            *ptr1.add(8).cast::<*mut u8>() = result13;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V31;
                            match e {
                                V31::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V31::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V31::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V31::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V31::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V31::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V31::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1.add(20).cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V31::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1.add(20).cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V31::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used22,
                                        limit: limit22,
                                        reset_time: reset_time22,
                                        unit: unit22,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used22);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit22);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time22);
                                    *ptr1.add(32).cast::<u8>() = (unit22.clone() as i32) as u8;
                                }
                                V31::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V31::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1.add(20).cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V31::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr1.add(20).cast::<usize>() = len24;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V31::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr1.add(20).cast::<usize>() = len25;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V31::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr1.add(20).cast::<usize>() = len26;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V31::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr1.add(20).cast::<usize>() = len27;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V31::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr1.add(20).cast::<usize>() = len28;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V31::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr1.add(20).cast::<usize>() = len29;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V31::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr1.add(20).cast::<usize>() = len30;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_results_get_next<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base27 = l1;
                            let len27 = l2;
                            for i in 0..len27 {
                                let base = base27.add(i * 84);
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base.add(8).cast::<*mut u8>();
                                    let l6 = *base.add(12).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base.add(16).cast::<*mut u8>();
                                    let l8 = *base.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                    let l9 = *base.add(24).cast::<*mut u8>();
                                    let l10 = *base.add(28).cast::<usize>();
                                    let base13 = l9;
                                    let len13 = l10;
                                    for i in 0..len13 {
                                        let base = base13.add(i * 8);
                                        {
                                            let l11 = *base.add(0).cast::<*mut u8>();
                                            let l12 = *base.add(4).cast::<usize>();
                                            _rt::cabi_dealloc(l11, l12, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(base13, len13 * 8, 4);
                                    let l14 = i32::from(*base.add(36).cast::<u8>());
                                    match l14 {
                                        0 => {}
                                        _ => {
                                            let l15 = *base.add(40).cast::<*mut u8>();
                                            let l16 = *base.add(44).cast::<usize>();
                                            _rt::cabi_dealloc(l15, l16, 1);
                                        }
                                    }
                                    let l17 = *base.add(48).cast::<*mut u8>();
                                    let l18 = *base.add(52).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                    let l19 = i32::from(*base.add(64).cast::<u8>());
                                    match l19 {
                                        0 => {}
                                        _ => {
                                            let l20 = *base.add(68).cast::<*mut u8>();
                                            let l21 = *base.add(72).cast::<usize>();
                                            _rt::cabi_dealloc(l20, l21, 1);
                                        }
                                    }
                                    let l22 = *base.add(76).cast::<*mut u8>();
                                    let l23 = *base.add(80).cast::<usize>();
                                    let base26 = l22;
                                    let len26 = l23;
                                    for i in 0..len26 {
                                        let base = base26.add(i * 8);
                                        {
                                            let l24 = *base.add(0).cast::<*mut u8>();
                                            let l25 = *base.add(4).cast::<usize>();
                                            _rt::cabi_dealloc(l24, l25, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(base26, len26 * 8, 4);
                                }
                            }
                            _rt::cabi_dealloc(base27, len27 * 84, 4);
                        }
                        _ => {
                            let l28 = i32::from(*arg0.add(8).cast::<u8>());
                            match l28 {
                                0 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                1 => {}
                                2 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                3 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                4 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                5 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                6 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                7 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                8 => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l45 = *arg0.add(16).cast::<*mut u8>();
                                    let l46 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l45, l46, 1);
                                }
                                13 => {
                                    let l47 = *arg0.add(16).cast::<*mut u8>();
                                    let l48 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l47, l48, 1);
                                }
                                14 => {
                                    let l49 = *arg0.add(16).cast::<*mut u8>();
                                    let l50 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l49, l50, 1);
                                }
                                15 => {
                                    let l51 = *arg0.add(16).cast::<*mut u8>();
                                    let l52 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l51, l52, 1);
                                }
                                16 => {
                                    let l53 = *arg0.add(16).cast::<*mut u8>();
                                    let l54 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l53, l54, 1);
                                }
                                17 => {
                                    let l55 = *arg0.add(16).cast::<*mut u8>();
                                    let l56 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l55, l56, 1);
                                }
                                18 => {
                                    let l57 = *arg0.add(16).cast::<*mut u8>();
                                    let l58 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l57, l58, 1);
                                }
                                _ => {
                                    let l59 = *arg0.add(16).cast::<*mut u8>();
                                    let l60 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l59, l60, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_results_get_total_count_cabi<
                    T: GuestVoiceResults,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_total_count(
                        VoiceResultsBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Some(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            *ptr1.add(4).cast::<i32>() = _rt::as_i32(e);
                        }
                        None => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_list_voices_cabi<T: Guest>(
                    arg0: i32,
                    arg1: i32,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: i32,
                    arg6: i32,
                    arg7: i32,
                    arg8: i32,
                    arg9: i32,
                    arg10: i32,
                    arg11: *mut u8,
                    arg12: usize,
                    arg13: i32,
                    arg14: *mut u8,
                    arg15: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result3 = T::list_voices(
                        match arg0 {
                            0 => None,
                            1 => {
                                let e = VoiceFilter {
                                    language: match arg1 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len0 = arg3;
                                                let bytes0 = _rt::Vec::from_raw_parts(
                                                    arg2.cast(),
                                                    len0,
                                                    len0,
                                                );
                                                _rt::string_lift(bytes0)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    gender: match arg4 {
                                        0 => None,
                                        1 => {
                                            let e = super::super::super::super::exports::golem::tts::types::VoiceGender::_lift(
                                                arg5 as u8,
                                            );
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    quality: match arg6 {
                                        0 => None,
                                        1 => {
                                            let e = super::super::super::super::exports::golem::tts::types::VoiceQuality::_lift(
                                                arg7 as u8,
                                            );
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    supports_ssml: match arg8 {
                                        0 => None,
                                        1 => {
                                            let e = _rt::bool_lift(arg9 as u8);
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    provider: match arg10 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len1 = arg12;
                                                let bytes1 = _rt::Vec::from_raw_parts(
                                                    arg11.cast(),
                                                    len1,
                                                    len1,
                                                );
                                                _rt::string_lift(bytes1)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                    search_query: match arg13 {
                                        0 => None,
                                        1 => {
                                            let e = {
                                                let len2 = arg15;
                                                let bytes2 = _rt::Vec::from_raw_parts(
                                                    arg14.cast(),
                                                    len2,
                                                    len2,
                                                );
                                                _rt::string_lift(bytes2)
                                            };
                                            Some(e)
                                        }
                                        _ => _rt::invalid_enum_discriminant(),
                                    },
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr4.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr4.add(20).cast::<usize>() = len5;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr4.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr4.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr4.add(20).cast::<usize>() = len6;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr4.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr4.add(20).cast::<usize>() = len7;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr4.add(20).cast::<usize>() = len8;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr4.add(20).cast::<usize>() = len9;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr4.add(20).cast::<usize>() = len10;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr4.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr4.add(20).cast::<usize>() = len11;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr4.add(20).cast::<usize>() = len12;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr4.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr4.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr4.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr4.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr4.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr4.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr4.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr4.add(20).cast::<usize>() = len14;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr4.add(20).cast::<usize>() = len15;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr4.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr4.add(20).cast::<usize>() = len16;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr4.add(20).cast::<usize>() = len17;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr4.add(20).cast::<usize>() = len18;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr4.add(20).cast::<usize>() = len19;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr4.add(20).cast::<usize>() = len20;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr4.add(20).cast::<usize>() = len21;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_list_voices<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::get_voice(_rt::string_lift(bytes0));
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr2.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2.add(20).cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2.add(20).cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_search_voices_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = i32::from(*arg0.add(8).cast::<u8>());
                    let result22 = T::search_voices(
                        _rt::string_lift(bytes2),
                        match l3 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l4 = i32::from(*arg0.add(12).cast::<u8>());
                                    let l8 = i32::from(*arg0.add(24).cast::<u8>());
                                    let l10 = i32::from(*arg0.add(26).cast::<u8>());
                                    let l12 = i32::from(*arg0.add(28).cast::<u8>());
                                    let l14 = i32::from(*arg0.add(32).cast::<u8>());
                                    let l18 = i32::from(*arg0.add(44).cast::<u8>());
                                    VoiceFilter {
                                        language: match l4 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                                    let l6 = *arg0.add(20).cast::<usize>();
                                                    let len7 = l6;
                                                    let bytes7 = _rt::Vec::from_raw_parts(
                                                        l5.cast(),
                                                        len7,
                                                        len7,
                                                    );
                                                    _rt::string_lift(bytes7)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        gender: match l8 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l9 = i32::from(*arg0.add(25).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceGender::_lift(
                                                        l9 as u8,
                                                    )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        quality: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(*arg0.add(27).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceQuality::_lift(
                                                        l11 as u8,
                                                    )
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        supports_ssml: match l12 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l13 = i32::from(*arg0.add(29).cast::<u8>());
                                                    _rt::bool_lift(l13 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        provider: match l14 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l15 = *arg0.add(36).cast::<*mut u8>();
                                                    let l16 = *arg0.add(40).cast::<usize>();
                                                    let len17 = l16;
                                                    let bytes17 = _rt::Vec::from_raw_parts(
                                                        l15.cast(),
                                                        len17,
                                                        len17,
                                                    );
                                                    _rt::string_lift(bytes17)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        search_query: match l18 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l19 = *arg0.add(48).cast::<*mut u8>();
                                                    let l20 = *arg0.add(52).cast::<usize>();
                                                    let len21 = l20;
                                                    let bytes21 = _rt::Vec::from_raw_parts(
                                                        l19.cast(),
                                                        len21,
                                                        len21,
                                                    );
                                                    _rt::string_lift(bytes21)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(arg0, 56, 4);
                    let ptr23 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result22 {
                        Ok(e) => {
                            *ptr23.add(0).cast::<u8>() = (0i32) as u8;
                            let vec35 = e;
                            let len35 = vec35.len();
                            let layout35 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec35.len() * 84,
                                4,
                            );
                            let result35 = if layout35.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout35).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout35);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec35.into_iter().enumerate() {
                                let base = result35.add(i * 84);
                                {
                                    let VoiceInfo {
                                        id: id24,
                                        name: name24,
                                        language: language24,
                                        additional_languages: additional_languages24,
                                        gender: gender24,
                                        quality: quality24,
                                        description: description24,
                                        provider: provider24,
                                        sample_rate: sample_rate24,
                                        is_custom: is_custom24,
                                        is_cloned: is_cloned24,
                                        preview_url: preview_url24,
                                        use_cases: use_cases24,
                                    } = e;
                                    let vec25 = (id24.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *base.add(4).cast::<usize>() = len25;
                                    *base.add(0).cast::<*mut u8>() = ptr25.cast_mut();
                                    let vec26 = (name24.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *base.add(12).cast::<usize>() = len26;
                                    *base.add(8).cast::<*mut u8>() = ptr26.cast_mut();
                                    let vec27 = (language24.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *base.add(20).cast::<usize>() = len27;
                                    *base.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                    let vec29 = additional_languages24;
                                    let len29 = vec29.len();
                                    let layout29 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec29.len() * 8,
                                        4,
                                    );
                                    let result29 = if layout29.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout29).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout29);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec29.into_iter().enumerate() {
                                        let base = result29.add(i * 8);
                                        {
                                            let vec28 = (e.into_bytes()).into_boxed_slice();
                                            let ptr28 = vec28.as_ptr().cast::<u8>();
                                            let len28 = vec28.len();
                                            ::core::mem::forget(vec28);
                                            *base.add(4).cast::<usize>() = len28;
                                            *base.add(0).cast::<*mut u8>() = ptr28.cast_mut();
                                        }
                                    }
                                    *base.add(28).cast::<usize>() = len29;
                                    *base.add(24).cast::<*mut u8>() = result29;
                                    *base.add(32).cast::<u8>() = (gender24.clone() as i32)
                                        as u8;
                                    *base.add(33).cast::<u8>() = (quality24.clone() as i32)
                                        as u8;
                                    match description24 {
                                        Some(e) => {
                                            *base.add(36).cast::<u8>() = (1i32) as u8;
                                            let vec30 = (e.into_bytes()).into_boxed_slice();
                                            let ptr30 = vec30.as_ptr().cast::<u8>();
                                            let len30 = vec30.len();
                                            ::core::mem::forget(vec30);
                                            *base.add(44).cast::<usize>() = len30;
                                            *base.add(40).cast::<*mut u8>() = ptr30.cast_mut();
                                        }
                                        None => {
                                            *base.add(36).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec31 = (provider24.into_bytes()).into_boxed_slice();
                                    let ptr31 = vec31.as_ptr().cast::<u8>();
                                    let len31 = vec31.len();
                                    ::core::mem::forget(vec31);
                                    *base.add(52).cast::<usize>() = len31;
                                    *base.add(48).cast::<*mut u8>() = ptr31.cast_mut();
                                    *base.add(56).cast::<i32>() = _rt::as_i32(sample_rate24);
                                    *base.add(60).cast::<u8>() = (match is_custom24 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    *base.add(61).cast::<u8>() = (match is_cloned24 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match preview_url24 {
                                        Some(e) => {
                                            *base.add(64).cast::<u8>() = (1i32) as u8;
                                            let vec32 = (e.into_bytes()).into_boxed_slice();
                                            let ptr32 = vec32.as_ptr().cast::<u8>();
                                            let len32 = vec32.len();
                                            ::core::mem::forget(vec32);
                                            *base.add(72).cast::<usize>() = len32;
                                            *base.add(68).cast::<*mut u8>() = ptr32.cast_mut();
                                        }
                                        None => {
                                            *base.add(64).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    let vec34 = use_cases24;
                                    let len34 = vec34.len();
                                    let layout34 = _rt::alloc::Layout::from_size_align_unchecked(
                                        vec34.len() * 8,
                                        4,
                                    );
                                    let result34 = if layout34.size() != 0 {
                                        let ptr = _rt::alloc::alloc(layout34).cast::<u8>();
                                        if ptr.is_null() {
                                            _rt::alloc::handle_alloc_error(layout34);
                                        }
                                        ptr
                                    } else {
                                        ::core::ptr::null_mut()
                                    };
                                    for (i, e) in vec34.into_iter().enumerate() {
                                        let base = result34.add(i * 8);
                                        {
                                            let vec33 = (e.into_bytes()).into_boxed_slice();
                                            let ptr33 = vec33.as_ptr().cast::<u8>();
                                            let len33 = vec33.len();
                                            ::core::mem::forget(vec33);
                                            *base.add(4).cast::<usize>() = len33;
                                            *base.add(0).cast::<*mut u8>() = ptr33.cast_mut();
                                        }
                                    }
                                    *base.add(80).cast::<usize>() = len34;
                                    *base.add(76).cast::<*mut u8>() = result34;
                                }
                            }
                            *ptr23.add(12).cast::<usize>() = len35;
                            *ptr23.add(8).cast::<*mut u8>() = result35;
                        }
                        Err(e) => {
                            *ptr23.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V53;
                            match e {
                                V53::InvalidText(e) => {
                                    *ptr23.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec36 = (e.into_bytes()).into_boxed_slice();
                                    let ptr36 = vec36.as_ptr().cast::<u8>();
                                    let len36 = vec36.len();
                                    ::core::mem::forget(vec36);
                                    *ptr23.add(20).cast::<usize>() = len36;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr36.cast_mut();
                                }
                                V53::TextTooLong(e) => {
                                    *ptr23.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V53::InvalidSsml(e) => {
                                    *ptr23.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec37 = (e.into_bytes()).into_boxed_slice();
                                    let ptr37 = vec37.as_ptr().cast::<u8>();
                                    let len37 = vec37.len();
                                    ::core::mem::forget(vec37);
                                    *ptr23.add(20).cast::<usize>() = len37;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr37.cast_mut();
                                }
                                V53::UnsupportedLanguage(e) => {
                                    *ptr23.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec38 = (e.into_bytes()).into_boxed_slice();
                                    let ptr38 = vec38.as_ptr().cast::<u8>();
                                    let len38 = vec38.len();
                                    ::core::mem::forget(vec38);
                                    *ptr23.add(20).cast::<usize>() = len38;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr38.cast_mut();
                                }
                                V53::VoiceNotFound(e) => {
                                    *ptr23.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec39 = (e.into_bytes()).into_boxed_slice();
                                    let ptr39 = vec39.as_ptr().cast::<u8>();
                                    let len39 = vec39.len();
                                    ::core::mem::forget(vec39);
                                    *ptr23.add(20).cast::<usize>() = len39;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr39.cast_mut();
                                }
                                V53::ModelNotFound(e) => {
                                    *ptr23.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec40 = (e.into_bytes()).into_boxed_slice();
                                    let ptr40 = vec40.as_ptr().cast::<u8>();
                                    let len40 = vec40.len();
                                    ::core::mem::forget(vec40);
                                    *ptr23.add(20).cast::<usize>() = len40;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr40.cast_mut();
                                }
                                V53::VoiceUnavailable(e) => {
                                    *ptr23.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec41 = (e.into_bytes()).into_boxed_slice();
                                    let ptr41 = vec41.as_ptr().cast::<u8>();
                                    let len41 = vec41.len();
                                    ::core::mem::forget(vec41);
                                    *ptr23.add(20).cast::<usize>() = len41;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr41.cast_mut();
                                }
                                V53::Unauthorized(e) => {
                                    *ptr23.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec42 = (e.into_bytes()).into_boxed_slice();
                                    let ptr42 = vec42.as_ptr().cast::<u8>();
                                    let len42 = vec42.len();
                                    ::core::mem::forget(vec42);
                                    *ptr23.add(20).cast::<usize>() = len42;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr42.cast_mut();
                                }
                                V53::AccessDenied(e) => {
                                    *ptr23.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec43 = (e.into_bytes()).into_boxed_slice();
                                    let ptr43 = vec43.as_ptr().cast::<u8>();
                                    let len43 = vec43.len();
                                    ::core::mem::forget(vec43);
                                    *ptr23.add(20).cast::<usize>() = len43;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr43.cast_mut();
                                }
                                V53::QuotaExceeded(e) => {
                                    *ptr23.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used44,
                                        limit: limit44,
                                        reset_time: reset_time44,
                                        unit: unit44,
                                    } = e;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(used44);
                                    *ptr23.add(20).cast::<i32>() = _rt::as_i32(limit44);
                                    *ptr23.add(24).cast::<i64>() = _rt::as_i64(reset_time44);
                                    *ptr23.add(32).cast::<u8>() = (unit44.clone() as i32) as u8;
                                }
                                V53::RateLimited(e) => {
                                    *ptr23.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr23.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V53::InsufficientCredits => {
                                    *ptr23.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V53::SynthesisFailed(e) => {
                                    *ptr23.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec45 = (e.into_bytes()).into_boxed_slice();
                                    let ptr45 = vec45.as_ptr().cast::<u8>();
                                    let len45 = vec45.len();
                                    ::core::mem::forget(vec45);
                                    *ptr23.add(20).cast::<usize>() = len45;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr45.cast_mut();
                                }
                                V53::UnsupportedOperation(e) => {
                                    *ptr23.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec46 = (e.into_bytes()).into_boxed_slice();
                                    let ptr46 = vec46.as_ptr().cast::<u8>();
                                    let len46 = vec46.len();
                                    ::core::mem::forget(vec46);
                                    *ptr23.add(20).cast::<usize>() = len46;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr46.cast_mut();
                                }
                                V53::InvalidConfiguration(e) => {
                                    *ptr23.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec47 = (e.into_bytes()).into_boxed_slice();
                                    let ptr47 = vec47.as_ptr().cast::<u8>();
                                    let len47 = vec47.len();
                                    ::core::mem::forget(vec47);
                                    *ptr23.add(20).cast::<usize>() = len47;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr47.cast_mut();
                                }
                                V53::ServiceUnavailable(e) => {
                                    *ptr23.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec48 = (e.into_bytes()).into_boxed_slice();
                                    let ptr48 = vec48.as_ptr().cast::<u8>();
                                    let len48 = vec48.len();
                                    ::core::mem::forget(vec48);
                                    *ptr23.add(20).cast::<usize>() = len48;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr48.cast_mut();
                                }
                                V53::NetworkError(e) => {
                                    *ptr23.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec49 = (e.into_bytes()).into_boxed_slice();
                                    let ptr49 = vec49.as_ptr().cast::<u8>();
                                    let len49 = vec49.len();
                                    ::core::mem::forget(vec49);
                                    *ptr23.add(20).cast::<usize>() = len49;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr49.cast_mut();
                                }
                                V53::InternalError(e) => {
                                    *ptr23.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec50 = (e.into_bytes()).into_boxed_slice();
                                    let ptr50 = vec50.as_ptr().cast::<u8>();
                                    let len50 = vec50.len();
                                    ::core::mem::forget(vec50);
                                    *ptr23.add(20).cast::<usize>() = len50;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr50.cast_mut();
                                }
                                V53::InvalidStorageLocation(e) => {
                                    *ptr23.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec51 = (e.into_bytes()).into_boxed_slice();
                                    let ptr51 = vec51.as_ptr().cast::<u8>();
                                    let len51 = vec51.len();
                                    ::core::mem::forget(vec51);
                                    *ptr23.add(20).cast::<usize>() = len51;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr51.cast_mut();
                                }
                                V53::StorageAccessDenied(e) => {
                                    *ptr23.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec52 = (e.into_bytes()).into_boxed_slice();
                                    let ptr52 = vec52.as_ptr().cast::<u8>();
                                    let len52 = vec52.len();
                                    ::core::mem::forget(vec52);
                                    *ptr23.add(20).cast::<usize>() = len52;
                                    *ptr23.add(16).cast::<*mut u8>() = ptr52.cast_mut();
                                }
                            }
                        }
                    };
                    ptr23
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_search_voices<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base27 = l1;
                            let len27 = l2;
                            for i in 0..len27 {
                                let base = base27.add(i * 84);
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base.add(8).cast::<*mut u8>();
                                    let l6 = *base.add(12).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base.add(16).cast::<*mut u8>();
                                    let l8 = *base.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                    let l9 = *base.add(24).cast::<*mut u8>();
                                    let l10 = *base.add(28).cast::<usize>();
                                    let base13 = l9;
                                    let len13 = l10;
                                    for i in 0..len13 {
                                        let base = base13.add(i * 8);
                                        {
                                            let l11 = *base.add(0).cast::<*mut u8>();
                                            let l12 = *base.add(4).cast::<usize>();
                                            _rt::cabi_dealloc(l11, l12, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(base13, len13 * 8, 4);
                                    let l14 = i32::from(*base.add(36).cast::<u8>());
                                    match l14 {
                                        0 => {}
                                        _ => {
                                            let l15 = *base.add(40).cast::<*mut u8>();
                                            let l16 = *base.add(44).cast::<usize>();
                                            _rt::cabi_dealloc(l15, l16, 1);
                                        }
                                    }
                                    let l17 = *base.add(48).cast::<*mut u8>();
                                    let l18 = *base.add(52).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                    let l19 = i32::from(*base.add(64).cast::<u8>());
                                    match l19 {
                                        0 => {}
                                        _ => {
                                            let l20 = *base.add(68).cast::<*mut u8>();
                                            let l21 = *base.add(72).cast::<usize>();
                                            _rt::cabi_dealloc(l20, l21, 1);
                                        }
                                    }
                                    let l22 = *base.add(76).cast::<*mut u8>();
                                    let l23 = *base.add(80).cast::<usize>();
                                    let base26 = l22;
                                    let len26 = l23;
                                    for i in 0..len26 {
                                        let base = base26.add(i * 8);
                                        {
                                            let l24 = *base.add(0).cast::<*mut u8>();
                                            let l25 = *base.add(4).cast::<usize>();
                                            _rt::cabi_dealloc(l24, l25, 1);
                                        }
                                    }
                                    _rt::cabi_dealloc(base26, len26 * 8, 4);
                                }
                            }
                            _rt::cabi_dealloc(base27, len27 * 84, 4);
                        }
                        _ => {
                            let l28 = i32::from(*arg0.add(8).cast::<u8>());
                            match l28 {
                                0 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                1 => {}
                                2 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                3 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                4 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                5 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                6 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                7 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                8 => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l45 = *arg0.add(16).cast::<*mut u8>();
                                    let l46 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l45, l46, 1);
                                }
                                13 => {
                                    let l47 = *arg0.add(16).cast::<*mut u8>();
                                    let l48 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l47, l48, 1);
                                }
                                14 => {
                                    let l49 = *arg0.add(16).cast::<*mut u8>();
                                    let l50 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l49, l50, 1);
                                }
                                15 => {
                                    let l51 = *arg0.add(16).cast::<*mut u8>();
                                    let l52 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l51, l52, 1);
                                }
                                16 => {
                                    let l53 = *arg0.add(16).cast::<*mut u8>();
                                    let l54 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l53, l54, 1);
                                }
                                17 => {
                                    let l55 = *arg0.add(16).cast::<*mut u8>();
                                    let l56 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l55, l56, 1);
                                }
                                18 => {
                                    let l57 = *arg0.add(16).cast::<*mut u8>();
                                    let l58 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l57, l58, 1);
                                }
                                _ => {
                                    let l59 = *arg0.add(16).cast::<*mut u8>();
                                    let l60 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l59, l60, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_list_languages_cabi<T: Guest>() -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::list_languages();
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec6 = e;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * 28,
                                4,
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 28);
                                {
                                    let LanguageInfo {
                                        code: code2,
                                        name: name2,
                                        native_name: native_name2,
                                        voice_count: voice_count2,
                                    } = e;
                                    let vec3 = (code2.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *base.add(4).cast::<usize>() = len3;
                                    *base.add(0).cast::<*mut u8>() = ptr3.cast_mut();
                                    let vec4 = (name2.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *base.add(12).cast::<usize>() = len4;
                                    *base.add(8).cast::<*mut u8>() = ptr4.cast_mut();
                                    let vec5 = (native_name2.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base.add(20).cast::<usize>() = len5;
                                    *base.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                    *base.add(24).cast::<i32>() = _rt::as_i32(voice_count2);
                                }
                            }
                            *ptr1.add(12).cast::<usize>() = len6;
                            *ptr1.add(8).cast::<*mut u8>() = result6;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V24;
                            match e {
                                V24::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V24::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V24::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V24::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V24::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1.add(20).cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V24::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V24::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V24::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V24::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V24::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used15,
                                        limit: limit15,
                                        reset_time: reset_time15,
                                        unit: unit15,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used15);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit15);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time15);
                                    *ptr1.add(32).cast::<u8>() = (unit15.clone() as i32) as u8;
                                }
                                V24::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V24::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V24::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V24::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V24::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V24::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V24::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1.add(20).cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V24::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1.add(20).cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V24::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr1.add(20).cast::<usize>() = len22;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V24::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1.add(20).cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_list_languages<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base9 = l1;
                            let len9 = l2;
                            for i in 0..len9 {
                                let base = base9.add(i * 28);
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                    let l5 = *base.add(8).cast::<*mut u8>();
                                    let l6 = *base.add(12).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                    let l7 = *base.add(16).cast::<*mut u8>();
                                    let l8 = *base.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                            _rt::cabi_dealloc(base9, len9 * 28, 4);
                        }
                        _ => {
                            let l10 = i32::from(*arg0.add(8).cast::<u8>());
                            match l10 {
                                0 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                1 => {}
                                2 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                3 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                4 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                5 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                6 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                7 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                8 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                13 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                14 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                15 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                16 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                17 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                18 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                _ => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    type Voice: GuestVoice;
                    type VoiceResults: GuestVoiceResults;
                    /// List available voices with filtering and pagination
                    fn list_voices(
                        filter: Option<VoiceFilter>,
                    ) -> Result<VoiceResults, TtsError>;
                    /// Get specific voice by ID
                    fn get_voice(voice_id: _rt::String) -> Result<Voice, TtsError>;
                    /// Search voices by characteristics
                    fn search_voices(
                        query: _rt::String,
                        filter: Option<VoiceFilter>,
                    ) -> Result<_rt::Vec<VoiceInfo>, TtsError>;
                    /// Get supported languages
                    fn list_languages() -> Result<_rt::Vec<LanguageInfo>, TtsError>;
                }
                pub trait GuestVoice: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]voice"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]voice"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Get voice identification
                    fn get_id(&self) -> _rt::String;
                    fn get_name(&self) -> _rt::String;
                    fn get_provider_id(&self) -> Option<_rt::String>;
                    /// Get voice characteristics
                    fn get_language(&self) -> LanguageCode;
                    fn get_additional_languages(&self) -> _rt::Vec<LanguageCode>;
                    fn get_gender(&self) -> VoiceGender;
                    fn get_quality(&self) -> VoiceQuality;
                    fn get_description(&self) -> Option<_rt::String>;
                    /// Voice capabilities
                    fn supports_ssml(&self) -> bool;
                    fn get_sample_rates(&self) -> _rt::Vec<u32>;
                    fn get_supported_formats(&self) -> _rt::Vec<AudioFormat>;
                    /// Voice management (may return unsupported-operation)
                    fn update_settings(
                        &self,
                        settings: VoiceSettings,
                    ) -> Result<(), TtsError>;
                    fn delete(&self) -> Result<(), TtsError>;
                    fn clone(&self) -> Result<Voice, TtsError>;
                    /// Preview voice with sample text
                    fn preview(
                        &self,
                        text: _rt::String,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                }
                pub trait GuestVoiceResults: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]voice-results"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/voices@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]voice-results"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Check if more voices are available
                    fn has_more(&self) -> bool;
                    /// Get next batch of voices
                    fn get_next(&self) -> Result<_rt::Vec<VoiceInfo>, TtsError>;
                    /// Get total count if available
                    fn get_total_count(&self) -> Option<u32>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_voices_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-id"] unsafe extern "C"
                        fn export_method_voice_get_id(arg0 : * mut u8,) -> * mut u8 {
                        $($path_to_types)*:: _export_method_voice_get_id_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-id"] unsafe
                        extern "C" fn _post_return_method_voice_get_id(arg0 : * mut u8,)
                        { $($path_to_types)*:: __post_return_method_voice_get_id::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-name"] unsafe extern
                        "C" fn export_method_voice_get_name(arg0 : * mut u8,) -> * mut u8
                        { $($path_to_types)*:: _export_method_voice_get_name_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-name"] unsafe
                        extern "C" fn _post_return_method_voice_get_name(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_voice_get_name::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-provider-id"] unsafe
                        extern "C" fn export_method_voice_get_provider_id(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_get_provider_id_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-provider-id"]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_provider_id(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_voice_get_provider_id::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-language"] unsafe
                        extern "C" fn export_method_voice_get_language(arg0 : * mut u8,)
                        -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_get_language_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-language"]
                        unsafe extern "C" fn _post_return_method_voice_get_language(arg0
                        : * mut u8,) { $($path_to_types)*::
                        __post_return_method_voice_get_language::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-additional-languages"]
                        unsafe extern "C" fn
                        export_method_voice_get_additional_languages(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_voice_get_additional_languages_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-additional-languages"]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_additional_languages(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_voice_get_additional_languages::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-gender"] unsafe extern
                        "C" fn export_method_voice_get_gender(arg0 : * mut u8,) -> i32 {
                        $($path_to_types)*:: _export_method_voice_get_gender_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-quality"] unsafe extern
                        "C" fn export_method_voice_get_quality(arg0 : * mut u8,) -> i32 {
                        $($path_to_types)*:: _export_method_voice_get_quality_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-description"] unsafe
                        extern "C" fn export_method_voice_get_description(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_get_description_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-description"]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_description(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_voice_get_description::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.supports-ssml"] unsafe
                        extern "C" fn export_method_voice_supports_ssml(arg0 : * mut u8,)
                        -> i32 { $($path_to_types)*::
                        _export_method_voice_supports_ssml_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-sample-rates"] unsafe
                        extern "C" fn export_method_voice_get_sample_rates(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_get_sample_rates_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-sample-rates"]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_sample_rates(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_voice_get_sample_rates::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.get-supported-formats"]
                        unsafe extern "C" fn
                        export_method_voice_get_supported_formats(arg0 : * mut u8,) -> *
                        mut u8 { $($path_to_types)*::
                        _export_method_voice_get_supported_formats_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.get-supported-formats"]
                        unsafe extern "C" fn
                        _post_return_method_voice_get_supported_formats(arg0 : * mut u8,)
                        { $($path_to_types)*::
                        __post_return_method_voice_get_supported_formats::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.update-settings"] unsafe
                        extern "C" fn export_method_voice_update_settings(arg0 : * mut
                        u8, arg1 : i32, arg2 : f32, arg3 : i32, arg4 : f32, arg5 : i32,
                        arg6 : f32, arg7 : i32, arg8 : f32, arg9 : i32, arg10 : f32,
                        arg11 : i32, arg12 : f32,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_update_settings_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12) }
                        #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.update-settings"]
                        unsafe extern "C" fn
                        _post_return_method_voice_update_settings(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_voice_update_settings::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.delete"] unsafe extern "C"
                        fn export_method_voice_delete(arg0 : * mut u8,) -> * mut u8 {
                        $($path_to_types)*:: _export_method_voice_delete_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.delete"] unsafe
                        extern "C" fn _post_return_method_voice_delete(arg0 : * mut u8,)
                        { $($path_to_types)*:: __post_return_method_voice_delete::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.clone"] unsafe extern "C"
                        fn export_method_voice_clone(arg0 : * mut u8,) -> * mut u8 {
                        $($path_to_types)*:: _export_method_voice_clone_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.clone"] unsafe
                        extern "C" fn _post_return_method_voice_clone(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_method_voice_clone::<<$ty as
                        $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice.preview"] unsafe extern "C"
                        fn export_method_voice_preview(arg0 : * mut u8, arg1 : * mut u8,
                        arg2 : usize,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_preview_cabi::<<$ty as $($path_to_types)*::
                        Guest >::Voice > (arg0, arg1, arg2) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice.preview"] unsafe
                        extern "C" fn _post_return_method_voice_preview(arg0 : * mut u8,)
                        { $($path_to_types)*:: __post_return_method_voice_preview::<<$ty
                        as $($path_to_types)*:: Guest >::Voice > (arg0) } #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.has-more"] unsafe
                        extern "C" fn export_method_voice_results_has_more(arg0 : * mut
                        u8,) -> i32 { $($path_to_types)*::
                        _export_method_voice_results_has_more_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) }
                        #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.get-next"] unsafe
                        extern "C" fn export_method_voice_results_get_next(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_results_get_next_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#[method]voice-results.get-next"]
                        unsafe extern "C" fn
                        _post_return_method_voice_results_get_next(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_voice_results_get_next::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) }
                        #[export_name =
                        "golem:tts/voices@1.0.0#[method]voice-results.get-total-count"]
                        unsafe extern "C" fn
                        export_method_voice_results_get_total_count(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_voice_results_get_total_count_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (arg0) }
                        #[export_name = "golem:tts/voices@1.0.0#list-voices"] unsafe
                        extern "C" fn export_list_voices(arg0 : i32, arg1 : i32, arg2 : *
                        mut u8, arg3 : usize, arg4 : i32, arg5 : i32, arg6 : i32, arg7 :
                        i32, arg8 : i32, arg9 : i32, arg10 : i32, arg11 : * mut u8, arg12
                        : usize, arg13 : i32, arg14 : * mut u8, arg15 : usize,) -> * mut
                        u8 { $($path_to_types)*:: _export_list_voices_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10,
                        arg11, arg12, arg13, arg14, arg15) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#list-voices"] unsafe extern "C"
                        fn _post_return_list_voices(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_list_voices::<$ty > (arg0) }
                        #[export_name = "golem:tts/voices@1.0.0#get-voice"] unsafe extern
                        "C" fn export_get_voice(arg0 : * mut u8, arg1 : usize,) -> * mut
                        u8 { $($path_to_types)*:: _export_get_voice_cabi::<$ty > (arg0,
                        arg1) } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#get-voice"] unsafe extern "C"
                        fn _post_return_get_voice(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_get_voice::<$ty > (arg0) }
                        #[export_name = "golem:tts/voices@1.0.0#search-voices"] unsafe
                        extern "C" fn export_search_voices(arg0 : * mut u8,) -> * mut u8
                        { $($path_to_types)*:: _export_search_voices_cabi::<$ty > (arg0)
                        } #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#search-voices"] unsafe extern
                        "C" fn _post_return_search_voices(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_search_voices::<$ty > (arg0) }
                        #[export_name = "golem:tts/voices@1.0.0#list-languages"] unsafe
                        extern "C" fn export_list_languages() -> * mut u8 {
                        $($path_to_types)*:: _export_list_languages_cabi::<$ty > () }
                        #[export_name =
                        "cabi_post_golem:tts/voices@1.0.0#list-languages"] unsafe extern
                        "C" fn _post_return_list_languages(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_list_languages::<$ty > (arg0)
                        } const _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/voices@1.0.0#[dtor]voice"] #[allow(non_snake_case)]
                        unsafe extern "C" fn dtor(rep : * mut u8) { $($path_to_types)*::
                        Voice::dtor::< <$ty as $($path_to_types)*:: Guest >::Voice >
                        (rep) } }; const _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/voices@1.0.0#[dtor]voice-results"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: VoiceResults::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::VoiceResults > (rep) } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_voices_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 40]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 40],
                );
            }
            /// Core text-to-speech synthesis operations
            #[allow(dead_code, clippy::all)]
            pub mod synthesis {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TextInput = super::super::super::super::exports::golem::tts::types::TextInput;
                pub type AudioConfig = super::super::super::super::exports::golem::tts::types::AudioConfig;
                pub type VoiceSettings = super::super::super::super::exports::golem::tts::types::VoiceSettings;
                pub type AudioEffects = super::super::super::super::exports::golem::tts::types::AudioEffects;
                pub type SynthesisResult = super::super::super::super::exports::golem::tts::types::SynthesisResult;
                pub type TtsError = super::super::super::super::exports::golem::tts::types::TtsError;
                pub type TimingInfo = super::super::super::super::exports::golem::tts::types::TimingInfo;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                /// Context for better synthesis quality
                #[derive(Clone)]
                pub struct SynthesisContext {
                    pub previous_text: Option<_rt::String>,
                    pub next_text: Option<_rt::String>,
                    pub topic: Option<_rt::String>,
                    pub emotion: Option<_rt::String>,
                    pub speaking_style: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for SynthesisContext {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisContext")
                            .field("previous-text", &self.previous_text)
                            .field("next-text", &self.next_text)
                            .field("topic", &self.topic)
                            .field("emotion", &self.emotion)
                            .field("speaking-style", &self.speaking_style)
                            .finish()
                    }
                }
                /// Synthesis configuration options
                #[derive(Clone)]
                pub struct SynthesisOptions {
                    pub audio_config: Option<AudioConfig>,
                    pub voice_settings: Option<VoiceSettings>,
                    pub audio_effects: Option<_rt::Vec<AudioEffects>>,
                    pub enable_timing: Option<bool>,
                    pub enable_word_timing: Option<bool>,
                    pub seed: Option<u32>,
                    pub model_version: Option<_rt::String>,
                    pub context: Option<SynthesisContext>,
                }
                impl ::core::fmt::Debug for SynthesisOptions {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("SynthesisOptions")
                            .field("audio-config", &self.audio_config)
                            .field("voice-settings", &self.voice_settings)
                            .field("audio-effects", &self.audio_effects)
                            .field("enable-timing", &self.enable_timing)
                            .field("enable-word-timing", &self.enable_word_timing)
                            .field("seed", &self.seed)
                            .field("model-version", &self.model_version)
                            .field("context", &self.context)
                            .finish()
                    }
                }
                #[derive(Clone)]
                pub struct ValidationResult {
                    pub is_valid: bool,
                    pub character_count: u32,
                    pub estimated_duration: Option<f32>,
                    pub warnings: _rt::Vec<_rt::String>,
                    pub errors: _rt::Vec<_rt::String>,
                }
                impl ::core::fmt::Debug for ValidationResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("ValidationResult")
                            .field("is-valid", &self.is_valid)
                            .field("character-count", &self.character_count)
                            .field("estimated-duration", &self.estimated_duration)
                            .field("warnings", &self.warnings)
                            .field("errors", &self.errors)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let len2 = l1;
                    let bytes2 = _rt::Vec::from_raw_parts(l0.cast(), len2, len2);
                    let l3 = i32::from(*arg0.add(8).cast::<u8>());
                    let l4 = i32::from(*arg0.add(12).cast::<u8>());
                    let l8 = *arg0.add(24).cast::<i32>();
                    let l9 = i32::from(*arg0.add(28).cast::<u8>());
                    let result67 = T::synthesize(
                        super::super::super::super::exports::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes2),
                            text_type: super::super::super::super::exports::golem::tts::types::TextType::_lift(
                                l3 as u8,
                            ),
                            language: match l4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l5 = *arg0.add(16).cast::<*mut u8>();
                                        let l6 = *arg0.add(20).cast::<usize>();
                                        let len7 = l6;
                                        let bytes7 = _rt::Vec::from_raw_parts(
                                            l5.cast(),
                                            len7,
                                            len7,
                                        );
                                        _rt::string_lift(bytes7)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        VoiceBorrow::lift(l8 as u32 as usize),
                        match l9 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l10 = i32::from(*arg0.add(32).cast::<u8>());
                                    let l18 = i32::from(*arg0.add(60).cast::<u8>());
                                    let l31 = i32::from(*arg0.add(112).cast::<u8>());
                                    let l36 = i32::from(*arg0.add(124).cast::<u8>());
                                    let l38 = i32::from(*arg0.add(126).cast::<u8>());
                                    let l40 = i32::from(*arg0.add(128).cast::<u8>());
                                    let l42 = i32::from(*arg0.add(136).cast::<u8>());
                                    let l46 = i32::from(*arg0.add(148).cast::<u8>());
                                    SynthesisOptions {
                                        audio_config: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(*arg0.add(36).cast::<u8>());
                                                    let l12 = i32::from(*arg0.add(40).cast::<u8>());
                                                    let l14 = i32::from(*arg0.add(48).cast::<u8>());
                                                    let l16 = i32::from(*arg0.add(56).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::exports::golem::tts::types::AudioFormat::_lift(
                                                            l11 as u8,
                                                        ),
                                                        sample_rate: match l12 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l13 = *arg0.add(44).cast::<i32>();
                                                                    l13 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l14 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l15 = *arg0.add(52).cast::<i32>();
                                                                    l15 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l16 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l17 = i32::from(*arg0.add(57).cast::<u8>());
                                                                    l17 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l18 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l19 = i32::from(*arg0.add(64).cast::<u8>());
                                                    let l21 = i32::from(*arg0.add(72).cast::<u8>());
                                                    let l23 = i32::from(*arg0.add(80).cast::<u8>());
                                                    let l25 = i32::from(*arg0.add(88).cast::<u8>());
                                                    let l27 = i32::from(*arg0.add(96).cast::<u8>());
                                                    let l29 = i32::from(*arg0.add(104).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceSettings {
                                                        speed: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0.add(68).cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0.add(76).cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l23 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l24 = *arg0.add(84).cast::<f32>();
                                                                    l24
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l25 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l26 = *arg0.add(92).cast::<f32>();
                                                                    l26
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l27 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l28 = *arg0.add(100).cast::<f32>();
                                                                    l28
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l29 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l30 = *arg0.add(108).cast::<f32>();
                                                                    l30
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l31 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l32 = *arg0.add(116).cast::<*mut u8>();
                                                    let l33 = *arg0.add(120).cast::<usize>();
                                                    let base35 = l32;
                                                    let len35 = l33;
                                                    let mut result35 = _rt::Vec::with_capacity(len35);
                                                    for i in 0..len35 {
                                                        let base = base35.add(i * 1);
                                                        let e35 = {
                                                            let l34 = i32::from(*base.add(0).cast::<u8>());
                                                            super::super::super::super::exports::golem::tts::types::AudioEffects::_lift(
                                                                l34 as u8,
                                                            )
                                                        };
                                                        result35.push(e35);
                                                    }
                                                    _rt::cabi_dealloc(base35, len35 * 1, 1);
                                                    result35
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l36 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l37 = i32::from(*arg0.add(125).cast::<u8>());
                                                    _rt::bool_lift(l37 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l38 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l39 = i32::from(*arg0.add(127).cast::<u8>());
                                                    _rt::bool_lift(l39 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l40 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l41 = *arg0.add(132).cast::<i32>();
                                                    l41 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l42 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l43 = *arg0.add(140).cast::<*mut u8>();
                                                    let l44 = *arg0.add(144).cast::<usize>();
                                                    let len45 = l44;
                                                    let bytes45 = _rt::Vec::from_raw_parts(
                                                        l43.cast(),
                                                        len45,
                                                        len45,
                                                    );
                                                    _rt::string_lift(bytes45)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l46 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l47 = i32::from(*arg0.add(152).cast::<u8>());
                                                    let l51 = i32::from(*arg0.add(164).cast::<u8>());
                                                    let l55 = i32::from(*arg0.add(176).cast::<u8>());
                                                    let l59 = i32::from(*arg0.add(188).cast::<u8>());
                                                    let l63 = i32::from(*arg0.add(200).cast::<u8>());
                                                    SynthesisContext {
                                                        previous_text: match l47 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l48 = *arg0.add(156).cast::<*mut u8>();
                                                                    let l49 = *arg0.add(160).cast::<usize>();
                                                                    let len50 = l49;
                                                                    let bytes50 = _rt::Vec::from_raw_parts(
                                                                        l48.cast(),
                                                                        len50,
                                                                        len50,
                                                                    );
                                                                    _rt::string_lift(bytes50)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l51 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l52 = *arg0.add(168).cast::<*mut u8>();
                                                                    let l53 = *arg0.add(172).cast::<usize>();
                                                                    let len54 = l53;
                                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                                        l52.cast(),
                                                                        len54,
                                                                        len54,
                                                                    );
                                                                    _rt::string_lift(bytes54)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l55 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l56 = *arg0.add(180).cast::<*mut u8>();
                                                                    let l57 = *arg0.add(184).cast::<usize>();
                                                                    let len58 = l57;
                                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                                        l56.cast(),
                                                                        len58,
                                                                        len58,
                                                                    );
                                                                    _rt::string_lift(bytes58)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l59 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l60 = *arg0.add(192).cast::<*mut u8>();
                                                                    let l61 = *arg0.add(196).cast::<usize>();
                                                                    let len62 = l61;
                                                                    let bytes62 = _rt::Vec::from_raw_parts(
                                                                        l60.cast(),
                                                                        len62,
                                                                        len62,
                                                                    );
                                                                    _rt::string_lift(bytes62)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l63 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l64 = *arg0.add(204).cast::<*mut u8>();
                                                                    let l65 = *arg0.add(208).cast::<usize>();
                                                                    let len66 = l65;
                                                                    let bytes66 = _rt::Vec::from_raw_parts(
                                                                        l64.cast(),
                                                                        len66,
                                                                        len66,
                                                                    );
                                                                    _rt::string_lift(bytes66)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(arg0, 212, 4);
                    let ptr68 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result67 {
                        Ok(e) => {
                            *ptr68.add(0).cast::<u8>() = (0i32) as u8;
                            let super::super::super::super::exports::golem::tts::types::SynthesisResult {
                                audio_data: audio_data69,
                                metadata: metadata69,
                            } = e;
                            let vec70 = (audio_data69).into_boxed_slice();
                            let ptr70 = vec70.as_ptr().cast::<u8>();
                            let len70 = vec70.len();
                            ::core::mem::forget(vec70);
                            *ptr68.add(12).cast::<usize>() = len70;
                            *ptr68.add(8).cast::<*mut u8>() = ptr70.cast_mut();
                            let super::super::super::super::exports::golem::tts::types::SynthesisMetadata {
                                duration_seconds: duration_seconds71,
                                character_count: character_count71,
                                word_count: word_count71,
                                audio_size_bytes: audio_size_bytes71,
                                request_id: request_id71,
                                provider_info: provider_info71,
                            } = metadata69;
                            *ptr68.add(16).cast::<f32>() = _rt::as_f32(
                                duration_seconds71,
                            );
                            *ptr68.add(20).cast::<i32>() = _rt::as_i32(
                                character_count71,
                            );
                            *ptr68.add(24).cast::<i32>() = _rt::as_i32(word_count71);
                            *ptr68.add(28).cast::<i32>() = _rt::as_i32(
                                audio_size_bytes71,
                            );
                            let vec72 = (request_id71.into_bytes()).into_boxed_slice();
                            let ptr72 = vec72.as_ptr().cast::<u8>();
                            let len72 = vec72.len();
                            ::core::mem::forget(vec72);
                            *ptr68.add(36).cast::<usize>() = len72;
                            *ptr68.add(32).cast::<*mut u8>() = ptr72.cast_mut();
                            match provider_info71 {
                                Some(e) => {
                                    *ptr68.add(40).cast::<u8>() = (1i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr68.add(48).cast::<usize>() = len73;
                                    *ptr68.add(44).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                None => {
                                    *ptr68.add(40).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr68.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V91;
                            match e {
                                V91::InvalidText(e) => {
                                    *ptr68.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr68.add(20).cast::<usize>() = len74;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                                V91::TextTooLong(e) => {
                                    *ptr68.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V91::InvalidSsml(e) => {
                                    *ptr68.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *ptr68.add(20).cast::<usize>() = len75;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr75.cast_mut();
                                }
                                V91::UnsupportedLanguage(e) => {
                                    *ptr68.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec76 = (e.into_bytes()).into_boxed_slice();
                                    let ptr76 = vec76.as_ptr().cast::<u8>();
                                    let len76 = vec76.len();
                                    ::core::mem::forget(vec76);
                                    *ptr68.add(20).cast::<usize>() = len76;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr76.cast_mut();
                                }
                                V91::VoiceNotFound(e) => {
                                    *ptr68.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec77 = (e.into_bytes()).into_boxed_slice();
                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                    let len77 = vec77.len();
                                    ::core::mem::forget(vec77);
                                    *ptr68.add(20).cast::<usize>() = len77;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr77.cast_mut();
                                }
                                V91::ModelNotFound(e) => {
                                    *ptr68.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec78 = (e.into_bytes()).into_boxed_slice();
                                    let ptr78 = vec78.as_ptr().cast::<u8>();
                                    let len78 = vec78.len();
                                    ::core::mem::forget(vec78);
                                    *ptr68.add(20).cast::<usize>() = len78;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr78.cast_mut();
                                }
                                V91::VoiceUnavailable(e) => {
                                    *ptr68.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec79 = (e.into_bytes()).into_boxed_slice();
                                    let ptr79 = vec79.as_ptr().cast::<u8>();
                                    let len79 = vec79.len();
                                    ::core::mem::forget(vec79);
                                    *ptr68.add(20).cast::<usize>() = len79;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr79.cast_mut();
                                }
                                V91::Unauthorized(e) => {
                                    *ptr68.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec80 = (e.into_bytes()).into_boxed_slice();
                                    let ptr80 = vec80.as_ptr().cast::<u8>();
                                    let len80 = vec80.len();
                                    ::core::mem::forget(vec80);
                                    *ptr68.add(20).cast::<usize>() = len80;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr80.cast_mut();
                                }
                                V91::AccessDenied(e) => {
                                    *ptr68.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec81 = (e.into_bytes()).into_boxed_slice();
                                    let ptr81 = vec81.as_ptr().cast::<u8>();
                                    let len81 = vec81.len();
                                    ::core::mem::forget(vec81);
                                    *ptr68.add(20).cast::<usize>() = len81;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr81.cast_mut();
                                }
                                V91::QuotaExceeded(e) => {
                                    *ptr68.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used82,
                                        limit: limit82,
                                        reset_time: reset_time82,
                                        unit: unit82,
                                    } = e;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(used82);
                                    *ptr68.add(20).cast::<i32>() = _rt::as_i32(limit82);
                                    *ptr68.add(24).cast::<i64>() = _rt::as_i64(reset_time82);
                                    *ptr68.add(32).cast::<u8>() = (unit82.clone() as i32) as u8;
                                }
                                V91::RateLimited(e) => {
                                    *ptr68.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr68.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V91::InsufficientCredits => {
                                    *ptr68.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V91::SynthesisFailed(e) => {
                                    *ptr68.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec83 = (e.into_bytes()).into_boxed_slice();
                                    let ptr83 = vec83.as_ptr().cast::<u8>();
                                    let len83 = vec83.len();
                                    ::core::mem::forget(vec83);
                                    *ptr68.add(20).cast::<usize>() = len83;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr83.cast_mut();
                                }
                                V91::UnsupportedOperation(e) => {
                                    *ptr68.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec84 = (e.into_bytes()).into_boxed_slice();
                                    let ptr84 = vec84.as_ptr().cast::<u8>();
                                    let len84 = vec84.len();
                                    ::core::mem::forget(vec84);
                                    *ptr68.add(20).cast::<usize>() = len84;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr84.cast_mut();
                                }
                                V91::InvalidConfiguration(e) => {
                                    *ptr68.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec85 = (e.into_bytes()).into_boxed_slice();
                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                    let len85 = vec85.len();
                                    ::core::mem::forget(vec85);
                                    *ptr68.add(20).cast::<usize>() = len85;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr85.cast_mut();
                                }
                                V91::ServiceUnavailable(e) => {
                                    *ptr68.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec86 = (e.into_bytes()).into_boxed_slice();
                                    let ptr86 = vec86.as_ptr().cast::<u8>();
                                    let len86 = vec86.len();
                                    ::core::mem::forget(vec86);
                                    *ptr68.add(20).cast::<usize>() = len86;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr86.cast_mut();
                                }
                                V91::NetworkError(e) => {
                                    *ptr68.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec87 = (e.into_bytes()).into_boxed_slice();
                                    let ptr87 = vec87.as_ptr().cast::<u8>();
                                    let len87 = vec87.len();
                                    ::core::mem::forget(vec87);
                                    *ptr68.add(20).cast::<usize>() = len87;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr87.cast_mut();
                                }
                                V91::InternalError(e) => {
                                    *ptr68.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec88 = (e.into_bytes()).into_boxed_slice();
                                    let ptr88 = vec88.as_ptr().cast::<u8>();
                                    let len88 = vec88.len();
                                    ::core::mem::forget(vec88);
                                    *ptr68.add(20).cast::<usize>() = len88;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr88.cast_mut();
                                }
                                V91::InvalidStorageLocation(e) => {
                                    *ptr68.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec89 = (e.into_bytes()).into_boxed_slice();
                                    let ptr89 = vec89.as_ptr().cast::<u8>();
                                    let len89 = vec89.len();
                                    ::core::mem::forget(vec89);
                                    *ptr68.add(20).cast::<usize>() = len89;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr89.cast_mut();
                                }
                                V91::StorageAccessDenied(e) => {
                                    *ptr68.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec90 = (e.into_bytes()).into_boxed_slice();
                                    let ptr90 = vec90.as_ptr().cast::<u8>();
                                    let len90 = vec90.len();
                                    ::core::mem::forget(vec90);
                                    *ptr68.add(20).cast::<usize>() = len90;
                                    *ptr68.add(16).cast::<*mut u8>() = ptr90.cast_mut();
                                }
                            }
                        }
                    };
                    ptr68
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                            let l4 = *arg0.add(32).cast::<*mut u8>();
                            let l5 = *arg0.add(36).cast::<usize>();
                            _rt::cabi_dealloc(l4, l5, 1);
                            let l6 = i32::from(*arg0.add(40).cast::<u8>());
                            match l6 {
                                0 => {}
                                _ => {
                                    let l7 = *arg0.add(44).cast::<*mut u8>();
                                    let l8 = *arg0.add(48).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                            }
                        }
                        _ => {
                            let l9 = i32::from(*arg0.add(8).cast::<u8>());
                            match l9 {
                                0 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                1 => {}
                                2 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                3 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                4 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                5 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                6 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                7 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                8 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                13 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                14 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                15 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                16 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                17 => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                                18 => {
                                    let l38 = *arg0.add(16).cast::<*mut u8>();
                                    let l39 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l38, l39, 1);
                                }
                                _ => {
                                    let l40 = *arg0.add(16).cast::<*mut u8>();
                                    let l41 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l40, l41, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_batch_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    let base10 = l0;
                    let len10 = l1;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10.add(i * 24);
                        let e10 = {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            let len4 = l3;
                            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                            let l5 = i32::from(*base.add(8).cast::<u8>());
                            let l6 = i32::from(*base.add(12).cast::<u8>());
                            super::super::super::super::exports::golem::tts::types::TextInput {
                                content: _rt::string_lift(bytes4),
                                text_type: super::super::super::super::exports::golem::tts::types::TextType::_lift(
                                    l5 as u8,
                                ),
                                language: match l6 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l7 = *base.add(16).cast::<*mut u8>();
                                            let l8 = *base.add(20).cast::<usize>();
                                            let len9 = l8;
                                            let bytes9 = _rt::Vec::from_raw_parts(
                                                l7.cast(),
                                                len9,
                                                len9,
                                            );
                                            _rt::string_lift(bytes9)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                            }
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(base10, len10 * 24, 4);
                    let l11 = *arg0.add(8).cast::<i32>();
                    let l12 = i32::from(*arg0.add(12).cast::<u8>());
                    let result70 = T::synthesize_batch(
                        result10,
                        VoiceBorrow::lift(l11 as u32 as usize),
                        match l12 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l13 = i32::from(*arg0.add(16).cast::<u8>());
                                    let l21 = i32::from(*arg0.add(44).cast::<u8>());
                                    let l34 = i32::from(*arg0.add(96).cast::<u8>());
                                    let l39 = i32::from(*arg0.add(108).cast::<u8>());
                                    let l41 = i32::from(*arg0.add(110).cast::<u8>());
                                    let l43 = i32::from(*arg0.add(112).cast::<u8>());
                                    let l45 = i32::from(*arg0.add(120).cast::<u8>());
                                    let l49 = i32::from(*arg0.add(132).cast::<u8>());
                                    SynthesisOptions {
                                        audio_config: match l13 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l14 = i32::from(*arg0.add(20).cast::<u8>());
                                                    let l15 = i32::from(*arg0.add(24).cast::<u8>());
                                                    let l17 = i32::from(*arg0.add(32).cast::<u8>());
                                                    let l19 = i32::from(*arg0.add(40).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::exports::golem::tts::types::AudioFormat::_lift(
                                                            l14 as u8,
                                                        ),
                                                        sample_rate: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0.add(28).cast::<i32>();
                                                                    l16 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0.add(36).cast::<i32>();
                                                                    l18 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = i32::from(*arg0.add(41).cast::<u8>());
                                                                    l20 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l21 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l22 = i32::from(*arg0.add(48).cast::<u8>());
                                                    let l24 = i32::from(*arg0.add(56).cast::<u8>());
                                                    let l26 = i32::from(*arg0.add(64).cast::<u8>());
                                                    let l28 = i32::from(*arg0.add(72).cast::<u8>());
                                                    let l30 = i32::from(*arg0.add(80).cast::<u8>());
                                                    let l32 = i32::from(*arg0.add(88).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceSettings {
                                                        speed: match l22 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l23 = *arg0.add(52).cast::<f32>();
                                                                    l23
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l24 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l25 = *arg0.add(60).cast::<f32>();
                                                                    l25
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l26 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l27 = *arg0.add(68).cast::<f32>();
                                                                    l27
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l28 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l29 = *arg0.add(76).cast::<f32>();
                                                                    l29
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l30 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l31 = *arg0.add(84).cast::<f32>();
                                                                    l31
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l32 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l33 = *arg0.add(92).cast::<f32>();
                                                                    l33
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l34 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l35 = *arg0.add(100).cast::<*mut u8>();
                                                    let l36 = *arg0.add(104).cast::<usize>();
                                                    let base38 = l35;
                                                    let len38 = l36;
                                                    let mut result38 = _rt::Vec::with_capacity(len38);
                                                    for i in 0..len38 {
                                                        let base = base38.add(i * 1);
                                                        let e38 = {
                                                            let l37 = i32::from(*base.add(0).cast::<u8>());
                                                            super::super::super::super::exports::golem::tts::types::AudioEffects::_lift(
                                                                l37 as u8,
                                                            )
                                                        };
                                                        result38.push(e38);
                                                    }
                                                    _rt::cabi_dealloc(base38, len38 * 1, 1);
                                                    result38
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l39 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l40 = i32::from(*arg0.add(109).cast::<u8>());
                                                    _rt::bool_lift(l40 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l41 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l42 = i32::from(*arg0.add(111).cast::<u8>());
                                                    _rt::bool_lift(l42 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l43 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l44 = *arg0.add(116).cast::<i32>();
                                                    l44 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l45 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l46 = *arg0.add(124).cast::<*mut u8>();
                                                    let l47 = *arg0.add(128).cast::<usize>();
                                                    let len48 = l47;
                                                    let bytes48 = _rt::Vec::from_raw_parts(
                                                        l46.cast(),
                                                        len48,
                                                        len48,
                                                    );
                                                    _rt::string_lift(bytes48)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l49 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l50 = i32::from(*arg0.add(136).cast::<u8>());
                                                    let l54 = i32::from(*arg0.add(148).cast::<u8>());
                                                    let l58 = i32::from(*arg0.add(160).cast::<u8>());
                                                    let l62 = i32::from(*arg0.add(172).cast::<u8>());
                                                    let l66 = i32::from(*arg0.add(184).cast::<u8>());
                                                    SynthesisContext {
                                                        previous_text: match l50 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l51 = *arg0.add(140).cast::<*mut u8>();
                                                                    let l52 = *arg0.add(144).cast::<usize>();
                                                                    let len53 = l52;
                                                                    let bytes53 = _rt::Vec::from_raw_parts(
                                                                        l51.cast(),
                                                                        len53,
                                                                        len53,
                                                                    );
                                                                    _rt::string_lift(bytes53)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l54 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l55 = *arg0.add(152).cast::<*mut u8>();
                                                                    let l56 = *arg0.add(156).cast::<usize>();
                                                                    let len57 = l56;
                                                                    let bytes57 = _rt::Vec::from_raw_parts(
                                                                        l55.cast(),
                                                                        len57,
                                                                        len57,
                                                                    );
                                                                    _rt::string_lift(bytes57)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l58 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l59 = *arg0.add(164).cast::<*mut u8>();
                                                                    let l60 = *arg0.add(168).cast::<usize>();
                                                                    let len61 = l60;
                                                                    let bytes61 = _rt::Vec::from_raw_parts(
                                                                        l59.cast(),
                                                                        len61,
                                                                        len61,
                                                                    );
                                                                    _rt::string_lift(bytes61)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l62 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l63 = *arg0.add(176).cast::<*mut u8>();
                                                                    let l64 = *arg0.add(180).cast::<usize>();
                                                                    let len65 = l64;
                                                                    let bytes65 = _rt::Vec::from_raw_parts(
                                                                        l63.cast(),
                                                                        len65,
                                                                        len65,
                                                                    );
                                                                    _rt::string_lift(bytes65)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l66 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l67 = *arg0.add(188).cast::<*mut u8>();
                                                                    let l68 = *arg0.add(192).cast::<usize>();
                                                                    let len69 = l68;
                                                                    let bytes69 = _rt::Vec::from_raw_parts(
                                                                        l67.cast(),
                                                                        len69,
                                                                        len69,
                                                                    );
                                                                    _rt::string_lift(bytes69)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(arg0, 196, 4);
                    let ptr71 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result70 {
                        Ok(e) => {
                            *ptr71.add(0).cast::<u8>() = (0i32) as u8;
                            let vec77 = e;
                            let len77 = vec77.len();
                            let layout77 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec77.len() * 44,
                                4,
                            );
                            let result77 = if layout77.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout77).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout77);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec77.into_iter().enumerate() {
                                let base = result77.add(i * 44);
                                {
                                    let super::super::super::super::exports::golem::tts::types::SynthesisResult {
                                        audio_data: audio_data72,
                                        metadata: metadata72,
                                    } = e;
                                    let vec73 = (audio_data72).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *base.add(4).cast::<usize>() = len73;
                                    *base.add(0).cast::<*mut u8>() = ptr73.cast_mut();
                                    let super::super::super::super::exports::golem::tts::types::SynthesisMetadata {
                                        duration_seconds: duration_seconds74,
                                        character_count: character_count74,
                                        word_count: word_count74,
                                        audio_size_bytes: audio_size_bytes74,
                                        request_id: request_id74,
                                        provider_info: provider_info74,
                                    } = metadata72;
                                    *base.add(8).cast::<f32>() = _rt::as_f32(
                                        duration_seconds74,
                                    );
                                    *base.add(12).cast::<i32>() = _rt::as_i32(
                                        character_count74,
                                    );
                                    *base.add(16).cast::<i32>() = _rt::as_i32(word_count74);
                                    *base.add(20).cast::<i32>() = _rt::as_i32(
                                        audio_size_bytes74,
                                    );
                                    let vec75 = (request_id74.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *base.add(28).cast::<usize>() = len75;
                                    *base.add(24).cast::<*mut u8>() = ptr75.cast_mut();
                                    match provider_info74 {
                                        Some(e) => {
                                            *base.add(32).cast::<u8>() = (1i32) as u8;
                                            let vec76 = (e.into_bytes()).into_boxed_slice();
                                            let ptr76 = vec76.as_ptr().cast::<u8>();
                                            let len76 = vec76.len();
                                            ::core::mem::forget(vec76);
                                            *base.add(40).cast::<usize>() = len76;
                                            *base.add(36).cast::<*mut u8>() = ptr76.cast_mut();
                                        }
                                        None => {
                                            *base.add(32).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            *ptr71.add(12).cast::<usize>() = len77;
                            *ptr71.add(8).cast::<*mut u8>() = result77;
                        }
                        Err(e) => {
                            *ptr71.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V95;
                            match e {
                                V95::InvalidText(e) => {
                                    *ptr71.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec78 = (e.into_bytes()).into_boxed_slice();
                                    let ptr78 = vec78.as_ptr().cast::<u8>();
                                    let len78 = vec78.len();
                                    ::core::mem::forget(vec78);
                                    *ptr71.add(20).cast::<usize>() = len78;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr78.cast_mut();
                                }
                                V95::TextTooLong(e) => {
                                    *ptr71.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr71.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V95::InvalidSsml(e) => {
                                    *ptr71.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec79 = (e.into_bytes()).into_boxed_slice();
                                    let ptr79 = vec79.as_ptr().cast::<u8>();
                                    let len79 = vec79.len();
                                    ::core::mem::forget(vec79);
                                    *ptr71.add(20).cast::<usize>() = len79;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr79.cast_mut();
                                }
                                V95::UnsupportedLanguage(e) => {
                                    *ptr71.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec80 = (e.into_bytes()).into_boxed_slice();
                                    let ptr80 = vec80.as_ptr().cast::<u8>();
                                    let len80 = vec80.len();
                                    ::core::mem::forget(vec80);
                                    *ptr71.add(20).cast::<usize>() = len80;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr80.cast_mut();
                                }
                                V95::VoiceNotFound(e) => {
                                    *ptr71.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec81 = (e.into_bytes()).into_boxed_slice();
                                    let ptr81 = vec81.as_ptr().cast::<u8>();
                                    let len81 = vec81.len();
                                    ::core::mem::forget(vec81);
                                    *ptr71.add(20).cast::<usize>() = len81;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr81.cast_mut();
                                }
                                V95::ModelNotFound(e) => {
                                    *ptr71.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec82 = (e.into_bytes()).into_boxed_slice();
                                    let ptr82 = vec82.as_ptr().cast::<u8>();
                                    let len82 = vec82.len();
                                    ::core::mem::forget(vec82);
                                    *ptr71.add(20).cast::<usize>() = len82;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr82.cast_mut();
                                }
                                V95::VoiceUnavailable(e) => {
                                    *ptr71.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec83 = (e.into_bytes()).into_boxed_slice();
                                    let ptr83 = vec83.as_ptr().cast::<u8>();
                                    let len83 = vec83.len();
                                    ::core::mem::forget(vec83);
                                    *ptr71.add(20).cast::<usize>() = len83;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr83.cast_mut();
                                }
                                V95::Unauthorized(e) => {
                                    *ptr71.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec84 = (e.into_bytes()).into_boxed_slice();
                                    let ptr84 = vec84.as_ptr().cast::<u8>();
                                    let len84 = vec84.len();
                                    ::core::mem::forget(vec84);
                                    *ptr71.add(20).cast::<usize>() = len84;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr84.cast_mut();
                                }
                                V95::AccessDenied(e) => {
                                    *ptr71.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec85 = (e.into_bytes()).into_boxed_slice();
                                    let ptr85 = vec85.as_ptr().cast::<u8>();
                                    let len85 = vec85.len();
                                    ::core::mem::forget(vec85);
                                    *ptr71.add(20).cast::<usize>() = len85;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr85.cast_mut();
                                }
                                V95::QuotaExceeded(e) => {
                                    *ptr71.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used86,
                                        limit: limit86,
                                        reset_time: reset_time86,
                                        unit: unit86,
                                    } = e;
                                    *ptr71.add(16).cast::<i32>() = _rt::as_i32(used86);
                                    *ptr71.add(20).cast::<i32>() = _rt::as_i32(limit86);
                                    *ptr71.add(24).cast::<i64>() = _rt::as_i64(reset_time86);
                                    *ptr71.add(32).cast::<u8>() = (unit86.clone() as i32) as u8;
                                }
                                V95::RateLimited(e) => {
                                    *ptr71.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr71.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V95::InsufficientCredits => {
                                    *ptr71.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V95::SynthesisFailed(e) => {
                                    *ptr71.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec87 = (e.into_bytes()).into_boxed_slice();
                                    let ptr87 = vec87.as_ptr().cast::<u8>();
                                    let len87 = vec87.len();
                                    ::core::mem::forget(vec87);
                                    *ptr71.add(20).cast::<usize>() = len87;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr87.cast_mut();
                                }
                                V95::UnsupportedOperation(e) => {
                                    *ptr71.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec88 = (e.into_bytes()).into_boxed_slice();
                                    let ptr88 = vec88.as_ptr().cast::<u8>();
                                    let len88 = vec88.len();
                                    ::core::mem::forget(vec88);
                                    *ptr71.add(20).cast::<usize>() = len88;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr88.cast_mut();
                                }
                                V95::InvalidConfiguration(e) => {
                                    *ptr71.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec89 = (e.into_bytes()).into_boxed_slice();
                                    let ptr89 = vec89.as_ptr().cast::<u8>();
                                    let len89 = vec89.len();
                                    ::core::mem::forget(vec89);
                                    *ptr71.add(20).cast::<usize>() = len89;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr89.cast_mut();
                                }
                                V95::ServiceUnavailable(e) => {
                                    *ptr71.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec90 = (e.into_bytes()).into_boxed_slice();
                                    let ptr90 = vec90.as_ptr().cast::<u8>();
                                    let len90 = vec90.len();
                                    ::core::mem::forget(vec90);
                                    *ptr71.add(20).cast::<usize>() = len90;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr90.cast_mut();
                                }
                                V95::NetworkError(e) => {
                                    *ptr71.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec91 = (e.into_bytes()).into_boxed_slice();
                                    let ptr91 = vec91.as_ptr().cast::<u8>();
                                    let len91 = vec91.len();
                                    ::core::mem::forget(vec91);
                                    *ptr71.add(20).cast::<usize>() = len91;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr91.cast_mut();
                                }
                                V95::InternalError(e) => {
                                    *ptr71.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec92 = (e.into_bytes()).into_boxed_slice();
                                    let ptr92 = vec92.as_ptr().cast::<u8>();
                                    let len92 = vec92.len();
                                    ::core::mem::forget(vec92);
                                    *ptr71.add(20).cast::<usize>() = len92;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr92.cast_mut();
                                }
                                V95::InvalidStorageLocation(e) => {
                                    *ptr71.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec93 = (e.into_bytes()).into_boxed_slice();
                                    let ptr93 = vec93.as_ptr().cast::<u8>();
                                    let len93 = vec93.len();
                                    ::core::mem::forget(vec93);
                                    *ptr71.add(20).cast::<usize>() = len93;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr93.cast_mut();
                                }
                                V95::StorageAccessDenied(e) => {
                                    *ptr71.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec94 = (e.into_bytes()).into_boxed_slice();
                                    let ptr94 = vec94.as_ptr().cast::<u8>();
                                    let len94 = vec94.len();
                                    ::core::mem::forget(vec94);
                                    *ptr71.add(20).cast::<usize>() = len94;
                                    *ptr71.add(16).cast::<*mut u8>() = ptr94.cast_mut();
                                }
                            }
                        }
                    };
                    ptr71
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize_batch<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base11 = l1;
                            let len11 = l2;
                            for i in 0..len11 {
                                let base = base11.add(i * 44);
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base.add(4).cast::<usize>();
                                    let base5 = l3;
                                    let len5 = l4;
                                    _rt::cabi_dealloc(base5, len5 * 1, 1);
                                    let l6 = *base.add(24).cast::<*mut u8>();
                                    let l7 = *base.add(28).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                    let l8 = i32::from(*base.add(32).cast::<u8>());
                                    match l8 {
                                        0 => {}
                                        _ => {
                                            let l9 = *base.add(36).cast::<*mut u8>();
                                            let l10 = *base.add(40).cast::<usize>();
                                            _rt::cabi_dealloc(l9, l10, 1);
                                        }
                                    }
                                }
                            }
                            _rt::cabi_dealloc(base11, len11 * 44, 4);
                        }
                        _ => {
                            let l12 = i32::from(*arg0.add(8).cast::<u8>());
                            match l12 {
                                0 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                1 => {}
                                2 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                3 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                4 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                5 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                6 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                7 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                8 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                13 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                14 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                15 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                16 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                17 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                18 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                _ => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_get_timing_marks_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result2 = T::get_timing_marks(
                        super::super::super::super::exports::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::exports::golem::tts::types::TextType::_lift(
                                arg2 as u8,
                            ),
                            language: match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg5;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg4.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        VoiceBorrow::lift(arg6 as u32 as usize),
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let vec5 = e;
                            let len5 = vec5.len();
                            let layout5 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec5.len() * 24,
                                4,
                            );
                            let result5 = if layout5.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout5).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout5);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec5.into_iter().enumerate() {
                                let base = result5.add(i * 24);
                                {
                                    let super::super::super::super::exports::golem::tts::types::TimingInfo {
                                        start_time_seconds: start_time_seconds4,
                                        end_time_seconds: end_time_seconds4,
                                        text_offset: text_offset4,
                                        mark_type: mark_type4,
                                    } = e;
                                    *base.add(0).cast::<f32>() = _rt::as_f32(
                                        start_time_seconds4,
                                    );
                                    match end_time_seconds4 {
                                        Some(e) => {
                                            *base.add(4).cast::<u8>() = (1i32) as u8;
                                            *base.add(8).cast::<f32>() = _rt::as_f32(e);
                                        }
                                        None => {
                                            *base.add(4).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match text_offset4 {
                                        Some(e) => {
                                            *base.add(12).cast::<u8>() = (1i32) as u8;
                                            *base.add(16).cast::<i32>() = _rt::as_i32(e);
                                        }
                                        None => {
                                            *base.add(12).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                    match mark_type4 {
                                        Some(e) => {
                                            *base.add(20).cast::<u8>() = (1i32) as u8;
                                            *base.add(21).cast::<u8>() = (e.clone() as i32) as u8;
                                        }
                                        None => {
                                            *base.add(20).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                            }
                            *ptr3.add(12).cast::<usize>() = len5;
                            *ptr3.add(8).cast::<*mut u8>() = result5;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V23;
                            match e {
                                V23::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3.add(20).cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V23::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V23::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3.add(20).cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V23::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3.add(20).cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V23::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3.add(20).cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V23::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3.add(20).cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V23::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3.add(20).cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V23::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr3.add(20).cast::<usize>() = len12;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V23::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3.add(20).cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V23::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used14,
                                        limit: limit14,
                                        reset_time: reset_time14,
                                        unit: unit14,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used14);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit14);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time14);
                                    *ptr3.add(32).cast::<u8>() = (unit14.clone() as i32) as u8;
                                }
                                V23::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V23::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V23::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3.add(20).cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V23::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3.add(20).cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V23::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3.add(20).cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V23::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3.add(20).cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V23::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3.add(20).cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V23::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3.add(20).cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V23::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr3.add(20).cast::<usize>() = len21;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V23::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr3.add(20).cast::<usize>() = len22;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_get_timing_marks<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 24, 4);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_validate_input_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result2 = T::validate_input(
                        super::super::super::super::exports::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::exports::golem::tts::types::TextType::_lift(
                                arg2 as u8,
                            ),
                            language: match arg3 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg5;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg4.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                        VoiceBorrow::lift(arg6 as u32 as usize),
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result2 {
                        Ok(e) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                            let ValidationResult {
                                is_valid: is_valid4,
                                character_count: character_count4,
                                estimated_duration: estimated_duration4,
                                warnings: warnings4,
                                errors: errors4,
                            } = e;
                            *ptr3.add(8).cast::<u8>() = (match is_valid4 {
                                true => 1,
                                false => 0,
                            }) as u8;
                            *ptr3.add(12).cast::<i32>() = _rt::as_i32(character_count4);
                            match estimated_duration4 {
                                Some(e) => {
                                    *ptr3.add(16).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(20).cast::<f32>() = _rt::as_f32(e);
                                }
                                None => {
                                    *ptr3.add(16).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let vec6 = warnings4;
                            let len6 = vec6.len();
                            let layout6 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec6.len() * 8,
                                4,
                            );
                            let result6 = if layout6.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout6).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout6);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec6.into_iter().enumerate() {
                                let base = result6.add(i * 8);
                                {
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *base.add(4).cast::<usize>() = len5;
                                    *base.add(0).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                            }
                            *ptr3.add(28).cast::<usize>() = len6;
                            *ptr3.add(24).cast::<*mut u8>() = result6;
                            let vec8 = errors4;
                            let len8 = vec8.len();
                            let layout8 = _rt::alloc::Layout::from_size_align_unchecked(
                                vec8.len() * 8,
                                4,
                            );
                            let result8 = if layout8.size() != 0 {
                                let ptr = _rt::alloc::alloc(layout8).cast::<u8>();
                                if ptr.is_null() {
                                    _rt::alloc::handle_alloc_error(layout8);
                                }
                                ptr
                            } else {
                                ::core::ptr::null_mut()
                            };
                            for (i, e) in vec8.into_iter().enumerate() {
                                let base = result8.add(i * 8);
                                {
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *base.add(4).cast::<usize>() = len7;
                                    *base.add(0).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                            }
                            *ptr3.add(36).cast::<usize>() = len8;
                            *ptr3.add(32).cast::<*mut u8>() = result8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V26;
                            match e {
                                V26::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3.add(20).cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V26::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3.add(20).cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V26::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3.add(20).cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V26::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr3.add(20).cast::<usize>() = len12;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V26::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3.add(20).cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V26::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3.add(20).cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V26::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3.add(20).cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V26::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3.add(20).cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V26::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used17,
                                        limit: limit17,
                                        reset_time: reset_time17,
                                        unit: unit17,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used17);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit17);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time17);
                                    *ptr3.add(32).cast::<u8>() = (unit17.clone() as i32) as u8;
                                }
                                V26::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V26::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3.add(20).cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V26::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3.add(20).cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V26::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3.add(20).cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V26::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr3.add(20).cast::<usize>() = len21;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V26::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr3.add(20).cast::<usize>() = len22;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V26::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr3.add(20).cast::<usize>() = len23;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V26::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr3.add(20).cast::<usize>() = len24;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V26::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr3.add(20).cast::<usize>() = len25;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_validate_input<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(24).cast::<*mut u8>();
                            let l2 = *arg0.add(28).cast::<usize>();
                            let base5 = l1;
                            let len5 = l2;
                            for i in 0..len5 {
                                let base = base5.add(i * 8);
                                {
                                    let l3 = *base.add(0).cast::<*mut u8>();
                                    let l4 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l3, l4, 1);
                                }
                            }
                            _rt::cabi_dealloc(base5, len5 * 8, 4);
                            let l6 = *arg0.add(32).cast::<*mut u8>();
                            let l7 = *arg0.add(36).cast::<usize>();
                            let base10 = l6;
                            let len10 = l7;
                            for i in 0..len10 {
                                let base = base10.add(i * 8);
                                {
                                    let l8 = *base.add(0).cast::<*mut u8>();
                                    let l9 = *base.add(4).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                            }
                            _rt::cabi_dealloc(base10, len10 * 8, 4);
                        }
                        _ => {
                            let l11 = i32::from(*arg0.add(8).cast::<u8>());
                            match l11 {
                                0 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                1 => {}
                                2 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                3 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                4 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                5 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                6 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                7 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                8 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                13 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                14 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                15 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                16 => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                                17 => {
                                    let l38 = *arg0.add(16).cast::<*mut u8>();
                                    let l39 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l38, l39, 1);
                                }
                                18 => {
                                    let l40 = *arg0.add(16).cast::<*mut u8>();
                                    let l41 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l40, l41, 1);
                                }
                                _ => {
                                    let l42 = *arg0.add(16).cast::<*mut u8>();
                                    let l43 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l42, l43, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    /// Convert text to speech (removed async)
                    fn synthesize(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<SynthesisResult, TtsError>;
                    /// Batch synthesis for multiple inputs (removed async)
                    fn synthesize_batch(
                        inputs: _rt::Vec<TextInput>,
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<_rt::Vec<SynthesisResult>, TtsError>;
                    /// Get timing information without audio synthesis
                    fn get_timing_marks(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                    ) -> Result<_rt::Vec<TimingInfo>, TtsError>;
                    /// Validate text before synthesis
                    fn validate_input(
                        input: TextInput,
                        voice: VoiceBorrow<'_>,
                    ) -> Result<ValidationResult, TtsError>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_synthesis_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "golem:tts/synthesis@1.0.0#synthesize"] unsafe extern "C" fn
                        export_synthesize(arg0 : * mut u8,) -> * mut u8 {
                        $($path_to_types)*:: _export_synthesize_cabi::<$ty > (arg0) }
                        #[export_name = "cabi_post_golem:tts/synthesis@1.0.0#synthesize"]
                        unsafe extern "C" fn _post_return_synthesize(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_synthesize::<$ty > (arg0) }
                        #[export_name = "golem:tts/synthesis@1.0.0#synthesize-batch"]
                        unsafe extern "C" fn export_synthesize_batch(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_synthesize_batch_cabi::<$ty > (arg0) } #[export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#synthesize-batch"] unsafe
                        extern "C" fn _post_return_synthesize_batch(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_synthesize_batch::<$ty >
                        (arg0) } #[export_name =
                        "golem:tts/synthesis@1.0.0#get-timing-marks"] unsafe extern "C"
                        fn export_get_timing_marks(arg0 : * mut u8, arg1 : usize, arg2 :
                        i32, arg3 : i32, arg4 : * mut u8, arg5 : usize, arg6 : i32,) -> *
                        mut u8 { $($path_to_types)*:: _export_get_timing_marks_cabi::<$ty
                        > (arg0, arg1, arg2, arg3, arg4, arg5, arg6) } #[export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#get-timing-marks"] unsafe
                        extern "C" fn _post_return_get_timing_marks(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_get_timing_marks::<$ty >
                        (arg0) } #[export_name =
                        "golem:tts/synthesis@1.0.0#validate-input"] unsafe extern "C" fn
                        export_validate_input(arg0 : * mut u8, arg1 : usize, arg2 : i32,
                        arg3 : i32, arg4 : * mut u8, arg5 : usize, arg6 : i32,) -> * mut
                        u8 { $($path_to_types)*:: _export_validate_input_cabi::<$ty >
                        (arg0, arg1, arg2, arg3, arg4, arg5, arg6) } #[export_name =
                        "cabi_post_golem:tts/synthesis@1.0.0#validate-input"] unsafe
                        extern "C" fn _post_return_validate_input(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_validate_input::<$ty > (arg0)
                        } };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_synthesis_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 56]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 56],
                );
            }
            /// Real-time streaming synthesis
            #[allow(dead_code, clippy::all)]
            pub mod streaming {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TextInput = super::super::super::super::exports::golem::tts::types::TextInput;
                pub type AudioConfig = super::super::super::super::exports::golem::tts::types::AudioConfig;
                pub type VoiceSettings = super::super::super::super::exports::golem::tts::types::VoiceSettings;
                pub type AudioChunk = super::super::super::super::exports::golem::tts::types::AudioChunk;
                pub type TtsError = super::super::super::super::exports::golem::tts::types::TtsError;
                pub type TimingInfo = super::super::super::super::exports::golem::tts::types::TimingInfo;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                pub type SynthesisOptions = super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions;
                /// Streaming synthesis session
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SynthesisStream {
                    handle: _rt::Resource<SynthesisStream>,
                }
                type _SynthesisStreamRep<T> = Option<T>;
                impl SynthesisStream {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `SynthesisStream`.
                    pub fn new<T: GuestSynthesisStream>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _SynthesisStreamRep<T> = Some(val);
                        let ptr: *mut _SynthesisStreamRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestSynthesisStream>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestSynthesisStream>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestSynthesisStream>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(
                            handle as *mut _SynthesisStreamRep<T>,
                        );
                    }
                    fn as_ptr<T: GuestSynthesisStream>(
                        &self,
                    ) -> *mut _SynthesisStreamRep<T> {
                        SynthesisStream::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`SynthesisStream`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct SynthesisStreamBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a SynthesisStream>,
                }
                impl<'a> SynthesisStreamBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestSynthesisStream>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _SynthesisStreamRep<T> {
                        SynthesisStream::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for SynthesisStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]synthesis-stream"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum StreamStatus {
                    Ready,
                    Processing,
                    Finished,
                    Error,
                    Closed,
                }
                impl ::core::fmt::Debug for StreamStatus {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            StreamStatus::Ready => {
                                f.debug_tuple("StreamStatus::Ready").finish()
                            }
                            StreamStatus::Processing => {
                                f.debug_tuple("StreamStatus::Processing").finish()
                            }
                            StreamStatus::Finished => {
                                f.debug_tuple("StreamStatus::Finished").finish()
                            }
                            StreamStatus::Error => {
                                f.debug_tuple("StreamStatus::Error").finish()
                            }
                            StreamStatus::Closed => {
                                f.debug_tuple("StreamStatus::Closed").finish()
                            }
                        }
                    }
                }
                impl StreamStatus {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> StreamStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => StreamStatus::Ready,
                            1 => StreamStatus::Processing,
                            2 => StreamStatus::Finished,
                            3 => StreamStatus::Error,
                            4 => StreamStatus::Closed,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceConversionStream {
                    handle: _rt::Resource<VoiceConversionStream>,
                }
                type _VoiceConversionStreamRep<T> = Option<T>;
                impl VoiceConversionStream {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `VoiceConversionStream`.
                    pub fn new<T: GuestVoiceConversionStream>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _VoiceConversionStreamRep<T> = Some(val);
                        let ptr: *mut _VoiceConversionStreamRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestVoiceConversionStream>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestVoiceConversionStream>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestVoiceConversionStream>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(
                            handle as *mut _VoiceConversionStreamRep<T>,
                        );
                    }
                    fn as_ptr<T: GuestVoiceConversionStream>(
                        &self,
                    ) -> *mut _VoiceConversionStreamRep<T> {
                        VoiceConversionStream::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`VoiceConversionStream`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct VoiceConversionStreamBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a VoiceConversionStream>,
                }
                impl<'a> VoiceConversionStreamBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestVoiceConversionStream>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _VoiceConversionStreamRep<T> {
                        VoiceConversionStream::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for VoiceConversionStream {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]voice-conversion-stream"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_send_text_cabi<
                    T: GuestSynthesisStream,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: i32,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result2 = T::send_text(
                        SynthesisStreamBorrow::lift(arg0 as u32 as usize).get(),
                        super::super::super::super::exports::golem::tts::types::TextInput {
                            content: _rt::string_lift(bytes0),
                            text_type: super::super::super::super::exports::golem::tts::types::TextType::_lift(
                                arg3 as u8,
                            ),
                            language: match arg4 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len1 = arg6;
                                        let bytes1 = _rt::Vec::from_raw_parts(
                                            arg5.cast(),
                                            len1,
                                            len1,
                                        );
                                        _rt::string_lift(bytes1)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result2 {
                        Ok(_) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr3.add(20).cast::<usize>() = len4;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3.add(20).cast::<usize>() = len5;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3.add(20).cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3.add(20).cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3.add(20).cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3.add(20).cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3.add(20).cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3.add(20).cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr3.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3.add(20).cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3.add(20).cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3.add(20).cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3.add(20).cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3.add(20).cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3.add(20).cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3.add(20).cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3.add(20).cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_send_text<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_finish_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::finish(
                        SynthesisStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_finish<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_receive_chunk_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::receive_chunk(
                        SynthesisStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::AudioChunk {
                                        data: data2,
                                        sequence_number: sequence_number2,
                                        is_final: is_final2,
                                        timing_info: timing_info2,
                                    } = e;
                                    let vec3 = (data2).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(16).cast::<usize>() = len3;
                                    *ptr1.add(12).cast::<*mut u8>() = ptr3.cast_mut();
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(sequence_number2);
                                    *ptr1.add(24).cast::<u8>() = (match is_final2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match timing_info2 {
                                        Some(e) => {
                                            *ptr1.add(28).cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::exports::golem::tts::types::TimingInfo {
                                                start_time_seconds: start_time_seconds4,
                                                end_time_seconds: end_time_seconds4,
                                                text_offset: text_offset4,
                                                mark_type: mark_type4,
                                            } = e;
                                            *ptr1.add(32).cast::<f32>() = _rt::as_f32(
                                                start_time_seconds4,
                                            );
                                            match end_time_seconds4 {
                                                Some(e) => {
                                                    *ptr1.add(36).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(40).cast::<f32>() = _rt::as_f32(e);
                                                }
                                                None => {
                                                    *ptr1.add(36).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match text_offset4 {
                                                Some(e) => {
                                                    *ptr1.add(44).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(48).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *ptr1.add(44).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match mark_type4 {
                                                Some(e) => {
                                                    *ptr1.add(52).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(53).cast::<u8>() = (e.clone() as i32) as u8;
                                                }
                                                None => {
                                                    *ptr1.add(52).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        None => {
                                            *ptr1.add(28).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1.add(20).cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr1.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1.add(20).cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1.add(20).cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_synthesis_stream_receive_chunk<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0.add(12).cast::<*mut u8>();
                                    let l3 = *arg0.add(16).cast::<usize>();
                                    let base4 = l2;
                                    let len4 = l3;
                                    _rt::cabi_dealloc(base4, len4 * 1, 1);
                                }
                            }
                        }
                        _ => {
                            let l5 = i32::from(*arg0.add(8).cast::<u8>());
                            match l5 {
                                0 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                1 => {}
                                2 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                3 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                4 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                5 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                6 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                7 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                8 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                13 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                14 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                15 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                16 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                17 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                18 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                _ => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_has_pending_audio_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::has_pending_audio(
                        SynthesisStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    match result0 {
                        true => 1,
                        false => 0,
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_get_status_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_status(
                        SynthesisStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_synthesis_stream_close_cabi<
                    T: GuestSynthesisStream,
                >(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::close(SynthesisStreamBorrow::lift(arg0 as u32 as usize).get());
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_stream_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<i32>();
                    let l1 = i32::from(*arg0.add(4).cast::<u8>());
                    let result59 = T::create_stream(
                        VoiceBorrow::lift(l0 as u32 as usize),
                        match l1 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l2 = i32::from(*arg0.add(8).cast::<u8>());
                                    let l10 = i32::from(*arg0.add(36).cast::<u8>());
                                    let l23 = i32::from(*arg0.add(88).cast::<u8>());
                                    let l28 = i32::from(*arg0.add(100).cast::<u8>());
                                    let l30 = i32::from(*arg0.add(102).cast::<u8>());
                                    let l32 = i32::from(*arg0.add(104).cast::<u8>());
                                    let l34 = i32::from(*arg0.add(112).cast::<u8>());
                                    let l38 = i32::from(*arg0.add(124).cast::<u8>());
                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions {
                                        audio_config: match l2 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l3 = i32::from(*arg0.add(12).cast::<u8>());
                                                    let l4 = i32::from(*arg0.add(16).cast::<u8>());
                                                    let l6 = i32::from(*arg0.add(24).cast::<u8>());
                                                    let l8 = i32::from(*arg0.add(32).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::exports::golem::tts::types::AudioFormat::_lift(
                                                            l3 as u8,
                                                        ),
                                                        sample_rate: match l4 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l5 = *arg0.add(20).cast::<i32>();
                                                                    l5 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l6 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l7 = *arg0.add(28).cast::<i32>();
                                                                    l7 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l8 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l9 = i32::from(*arg0.add(33).cast::<u8>());
                                                                    l9 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(*arg0.add(40).cast::<u8>());
                                                    let l13 = i32::from(*arg0.add(48).cast::<u8>());
                                                    let l15 = i32::from(*arg0.add(56).cast::<u8>());
                                                    let l17 = i32::from(*arg0.add(64).cast::<u8>());
                                                    let l19 = i32::from(*arg0.add(72).cast::<u8>());
                                                    let l21 = i32::from(*arg0.add(80).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceSettings {
                                                        speed: match l11 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l12 = *arg0.add(44).cast::<f32>();
                                                                    l12
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l13 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l14 = *arg0.add(52).cast::<f32>();
                                                                    l14
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0.add(60).cast::<f32>();
                                                                    l16
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0.add(68).cast::<f32>();
                                                                    l18
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0.add(76).cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0.add(84).cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l23 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l24 = *arg0.add(92).cast::<*mut u8>();
                                                    let l25 = *arg0.add(96).cast::<usize>();
                                                    let base27 = l24;
                                                    let len27 = l25;
                                                    let mut result27 = _rt::Vec::with_capacity(len27);
                                                    for i in 0..len27 {
                                                        let base = base27.add(i * 1);
                                                        let e27 = {
                                                            let l26 = i32::from(*base.add(0).cast::<u8>());
                                                            super::super::super::super::exports::golem::tts::types::AudioEffects::_lift(
                                                                l26 as u8,
                                                            )
                                                        };
                                                        result27.push(e27);
                                                    }
                                                    _rt::cabi_dealloc(base27, len27 * 1, 1);
                                                    result27
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l28 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l29 = i32::from(*arg0.add(101).cast::<u8>());
                                                    _rt::bool_lift(l29 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l30 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l31 = i32::from(*arg0.add(103).cast::<u8>());
                                                    _rt::bool_lift(l31 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l32 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l33 = *arg0.add(108).cast::<i32>();
                                                    l33 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l34 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l35 = *arg0.add(116).cast::<*mut u8>();
                                                    let l36 = *arg0.add(120).cast::<usize>();
                                                    let len37 = l36;
                                                    let bytes37 = _rt::Vec::from_raw_parts(
                                                        l35.cast(),
                                                        len37,
                                                        len37,
                                                    );
                                                    _rt::string_lift(bytes37)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l38 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l39 = i32::from(*arg0.add(128).cast::<u8>());
                                                    let l43 = i32::from(*arg0.add(140).cast::<u8>());
                                                    let l47 = i32::from(*arg0.add(152).cast::<u8>());
                                                    let l51 = i32::from(*arg0.add(164).cast::<u8>());
                                                    let l55 = i32::from(*arg0.add(176).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisContext {
                                                        previous_text: match l39 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l40 = *arg0.add(132).cast::<*mut u8>();
                                                                    let l41 = *arg0.add(136).cast::<usize>();
                                                                    let len42 = l41;
                                                                    let bytes42 = _rt::Vec::from_raw_parts(
                                                                        l40.cast(),
                                                                        len42,
                                                                        len42,
                                                                    );
                                                                    _rt::string_lift(bytes42)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l43 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l44 = *arg0.add(144).cast::<*mut u8>();
                                                                    let l45 = *arg0.add(148).cast::<usize>();
                                                                    let len46 = l45;
                                                                    let bytes46 = _rt::Vec::from_raw_parts(
                                                                        l44.cast(),
                                                                        len46,
                                                                        len46,
                                                                    );
                                                                    _rt::string_lift(bytes46)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l47 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l48 = *arg0.add(156).cast::<*mut u8>();
                                                                    let l49 = *arg0.add(160).cast::<usize>();
                                                                    let len50 = l49;
                                                                    let bytes50 = _rt::Vec::from_raw_parts(
                                                                        l48.cast(),
                                                                        len50,
                                                                        len50,
                                                                    );
                                                                    _rt::string_lift(bytes50)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l51 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l52 = *arg0.add(168).cast::<*mut u8>();
                                                                    let l53 = *arg0.add(172).cast::<usize>();
                                                                    let len54 = l53;
                                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                                        l52.cast(),
                                                                        len54,
                                                                        len54,
                                                                    );
                                                                    _rt::string_lift(bytes54)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l55 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l56 = *arg0.add(180).cast::<*mut u8>();
                                                                    let l57 = *arg0.add(184).cast::<usize>();
                                                                    let len58 = l57;
                                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                                        l56.cast(),
                                                                        len58,
                                                                        len58,
                                                                    );
                                                                    _rt::string_lift(bytes58)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(arg0, 188, 4);
                    let ptr60 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result59 {
                        Ok(e) => {
                            *ptr60.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr60.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr60.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V78;
                            match e {
                                V78::InvalidText(e) => {
                                    *ptr60.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec61 = (e.into_bytes()).into_boxed_slice();
                                    let ptr61 = vec61.as_ptr().cast::<u8>();
                                    let len61 = vec61.len();
                                    ::core::mem::forget(vec61);
                                    *ptr60.add(20).cast::<usize>() = len61;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr61.cast_mut();
                                }
                                V78::TextTooLong(e) => {
                                    *ptr60.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V78::InvalidSsml(e) => {
                                    *ptr60.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec62 = (e.into_bytes()).into_boxed_slice();
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    ::core::mem::forget(vec62);
                                    *ptr60.add(20).cast::<usize>() = len62;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                V78::UnsupportedLanguage(e) => {
                                    *ptr60.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec63 = (e.into_bytes()).into_boxed_slice();
                                    let ptr63 = vec63.as_ptr().cast::<u8>();
                                    let len63 = vec63.len();
                                    ::core::mem::forget(vec63);
                                    *ptr60.add(20).cast::<usize>() = len63;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr63.cast_mut();
                                }
                                V78::VoiceNotFound(e) => {
                                    *ptr60.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec64 = (e.into_bytes()).into_boxed_slice();
                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                    let len64 = vec64.len();
                                    ::core::mem::forget(vec64);
                                    *ptr60.add(20).cast::<usize>() = len64;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr64.cast_mut();
                                }
                                V78::ModelNotFound(e) => {
                                    *ptr60.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec65 = (e.into_bytes()).into_boxed_slice();
                                    let ptr65 = vec65.as_ptr().cast::<u8>();
                                    let len65 = vec65.len();
                                    ::core::mem::forget(vec65);
                                    *ptr60.add(20).cast::<usize>() = len65;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr65.cast_mut();
                                }
                                V78::VoiceUnavailable(e) => {
                                    *ptr60.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec66 = (e.into_bytes()).into_boxed_slice();
                                    let ptr66 = vec66.as_ptr().cast::<u8>();
                                    let len66 = vec66.len();
                                    ::core::mem::forget(vec66);
                                    *ptr60.add(20).cast::<usize>() = len66;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr66.cast_mut();
                                }
                                V78::Unauthorized(e) => {
                                    *ptr60.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec67 = (e.into_bytes()).into_boxed_slice();
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    ::core::mem::forget(vec67);
                                    *ptr60.add(20).cast::<usize>() = len67;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr67.cast_mut();
                                }
                                V78::AccessDenied(e) => {
                                    *ptr60.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec68 = (e.into_bytes()).into_boxed_slice();
                                    let ptr68 = vec68.as_ptr().cast::<u8>();
                                    let len68 = vec68.len();
                                    ::core::mem::forget(vec68);
                                    *ptr60.add(20).cast::<usize>() = len68;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr68.cast_mut();
                                }
                                V78::QuotaExceeded(e) => {
                                    *ptr60.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used69,
                                        limit: limit69,
                                        reset_time: reset_time69,
                                        unit: unit69,
                                    } = e;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(used69);
                                    *ptr60.add(20).cast::<i32>() = _rt::as_i32(limit69);
                                    *ptr60.add(24).cast::<i64>() = _rt::as_i64(reset_time69);
                                    *ptr60.add(32).cast::<u8>() = (unit69.clone() as i32) as u8;
                                }
                                V78::RateLimited(e) => {
                                    *ptr60.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V78::InsufficientCredits => {
                                    *ptr60.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V78::SynthesisFailed(e) => {
                                    *ptr60.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec70 = (e.into_bytes()).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *ptr60.add(20).cast::<usize>() = len70;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr70.cast_mut();
                                }
                                V78::UnsupportedOperation(e) => {
                                    *ptr60.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec71 = (e.into_bytes()).into_boxed_slice();
                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                    let len71 = vec71.len();
                                    ::core::mem::forget(vec71);
                                    *ptr60.add(20).cast::<usize>() = len71;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr71.cast_mut();
                                }
                                V78::InvalidConfiguration(e) => {
                                    *ptr60.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec72 = (e.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *ptr60.add(20).cast::<usize>() = len72;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr72.cast_mut();
                                }
                                V78::ServiceUnavailable(e) => {
                                    *ptr60.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr60.add(20).cast::<usize>() = len73;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                V78::NetworkError(e) => {
                                    *ptr60.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr60.add(20).cast::<usize>() = len74;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                                V78::InternalError(e) => {
                                    *ptr60.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *ptr60.add(20).cast::<usize>() = len75;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr75.cast_mut();
                                }
                                V78::InvalidStorageLocation(e) => {
                                    *ptr60.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec76 = (e.into_bytes()).into_boxed_slice();
                                    let ptr76 = vec76.as_ptr().cast::<u8>();
                                    let len76 = vec76.len();
                                    ::core::mem::forget(vec76);
                                    *ptr60.add(20).cast::<usize>() = len76;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr76.cast_mut();
                                }
                                V78::StorageAccessDenied(e) => {
                                    *ptr60.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec77 = (e.into_bytes()).into_boxed_slice();
                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                    let len77 = vec77.len();
                                    ::core::mem::forget(vec77);
                                    *ptr60.add(20).cast::<usize>() = len77;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr77.cast_mut();
                                }
                            }
                        }
                    };
                    ptr60
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_stream<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_voice_conversion_stream_cabi<T: Guest>(
                    arg0: *mut u8,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let l0 = *arg0.add(0).cast::<i32>();
                    let l1 = i32::from(*arg0.add(4).cast::<u8>());
                    let result59 = T::create_voice_conversion_stream(
                        VoiceBorrow::lift(l0 as u32 as usize),
                        match l1 {
                            0 => None,
                            1 => {
                                let e = {
                                    let l2 = i32::from(*arg0.add(8).cast::<u8>());
                                    let l10 = i32::from(*arg0.add(36).cast::<u8>());
                                    let l23 = i32::from(*arg0.add(88).cast::<u8>());
                                    let l28 = i32::from(*arg0.add(100).cast::<u8>());
                                    let l30 = i32::from(*arg0.add(102).cast::<u8>());
                                    let l32 = i32::from(*arg0.add(104).cast::<u8>());
                                    let l34 = i32::from(*arg0.add(112).cast::<u8>());
                                    let l38 = i32::from(*arg0.add(124).cast::<u8>());
                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisOptions {
                                        audio_config: match l2 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l3 = i32::from(*arg0.add(12).cast::<u8>());
                                                    let l4 = i32::from(*arg0.add(16).cast::<u8>());
                                                    let l6 = i32::from(*arg0.add(24).cast::<u8>());
                                                    let l8 = i32::from(*arg0.add(32).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::AudioConfig {
                                                        format: super::super::super::super::exports::golem::tts::types::AudioFormat::_lift(
                                                            l3 as u8,
                                                        ),
                                                        sample_rate: match l4 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l5 = *arg0.add(20).cast::<i32>();
                                                                    l5 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        bit_rate: match l6 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l7 = *arg0.add(28).cast::<i32>();
                                                                    l7 as u32
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        channels: match l8 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l9 = i32::from(*arg0.add(33).cast::<u8>());
                                                                    l9 as u8
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        voice_settings: match l10 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l11 = i32::from(*arg0.add(40).cast::<u8>());
                                                    let l13 = i32::from(*arg0.add(48).cast::<u8>());
                                                    let l15 = i32::from(*arg0.add(56).cast::<u8>());
                                                    let l17 = i32::from(*arg0.add(64).cast::<u8>());
                                                    let l19 = i32::from(*arg0.add(72).cast::<u8>());
                                                    let l21 = i32::from(*arg0.add(80).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::types::VoiceSettings {
                                                        speed: match l11 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l12 = *arg0.add(44).cast::<f32>();
                                                                    l12
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        pitch: match l13 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l14 = *arg0.add(52).cast::<f32>();
                                                                    l14
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        volume: match l15 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l16 = *arg0.add(60).cast::<f32>();
                                                                    l16
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        stability: match l17 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l18 = *arg0.add(68).cast::<f32>();
                                                                    l18
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        similarity: match l19 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l20 = *arg0.add(76).cast::<f32>();
                                                                    l20
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        style: match l21 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l22 = *arg0.add(84).cast::<f32>();
                                                                    l22
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        audio_effects: match l23 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l24 = *arg0.add(92).cast::<*mut u8>();
                                                    let l25 = *arg0.add(96).cast::<usize>();
                                                    let base27 = l24;
                                                    let len27 = l25;
                                                    let mut result27 = _rt::Vec::with_capacity(len27);
                                                    for i in 0..len27 {
                                                        let base = base27.add(i * 1);
                                                        let e27 = {
                                                            let l26 = i32::from(*base.add(0).cast::<u8>());
                                                            super::super::super::super::exports::golem::tts::types::AudioEffects::_lift(
                                                                l26 as u8,
                                                            )
                                                        };
                                                        result27.push(e27);
                                                    }
                                                    _rt::cabi_dealloc(base27, len27 * 1, 1);
                                                    result27
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_timing: match l28 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l29 = i32::from(*arg0.add(101).cast::<u8>());
                                                    _rt::bool_lift(l29 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        enable_word_timing: match l30 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l31 = i32::from(*arg0.add(103).cast::<u8>());
                                                    _rt::bool_lift(l31 as u8)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        seed: match l32 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l33 = *arg0.add(108).cast::<i32>();
                                                    l33 as u32
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        model_version: match l34 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l35 = *arg0.add(116).cast::<*mut u8>();
                                                    let l36 = *arg0.add(120).cast::<usize>();
                                                    let len37 = l36;
                                                    let bytes37 = _rt::Vec::from_raw_parts(
                                                        l35.cast(),
                                                        len37,
                                                        len37,
                                                    );
                                                    _rt::string_lift(bytes37)
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                        context: match l38 {
                                            0 => None,
                                            1 => {
                                                let e = {
                                                    let l39 = i32::from(*arg0.add(128).cast::<u8>());
                                                    let l43 = i32::from(*arg0.add(140).cast::<u8>());
                                                    let l47 = i32::from(*arg0.add(152).cast::<u8>());
                                                    let l51 = i32::from(*arg0.add(164).cast::<u8>());
                                                    let l55 = i32::from(*arg0.add(176).cast::<u8>());
                                                    super::super::super::super::exports::golem::tts::synthesis::SynthesisContext {
                                                        previous_text: match l39 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l40 = *arg0.add(132).cast::<*mut u8>();
                                                                    let l41 = *arg0.add(136).cast::<usize>();
                                                                    let len42 = l41;
                                                                    let bytes42 = _rt::Vec::from_raw_parts(
                                                                        l40.cast(),
                                                                        len42,
                                                                        len42,
                                                                    );
                                                                    _rt::string_lift(bytes42)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        next_text: match l43 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l44 = *arg0.add(144).cast::<*mut u8>();
                                                                    let l45 = *arg0.add(148).cast::<usize>();
                                                                    let len46 = l45;
                                                                    let bytes46 = _rt::Vec::from_raw_parts(
                                                                        l44.cast(),
                                                                        len46,
                                                                        len46,
                                                                    );
                                                                    _rt::string_lift(bytes46)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        topic: match l47 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l48 = *arg0.add(156).cast::<*mut u8>();
                                                                    let l49 = *arg0.add(160).cast::<usize>();
                                                                    let len50 = l49;
                                                                    let bytes50 = _rt::Vec::from_raw_parts(
                                                                        l48.cast(),
                                                                        len50,
                                                                        len50,
                                                                    );
                                                                    _rt::string_lift(bytes50)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        emotion: match l51 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l52 = *arg0.add(168).cast::<*mut u8>();
                                                                    let l53 = *arg0.add(172).cast::<usize>();
                                                                    let len54 = l53;
                                                                    let bytes54 = _rt::Vec::from_raw_parts(
                                                                        l52.cast(),
                                                                        len54,
                                                                        len54,
                                                                    );
                                                                    _rt::string_lift(bytes54)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                        speaking_style: match l55 {
                                                            0 => None,
                                                            1 => {
                                                                let e = {
                                                                    let l56 = *arg0.add(180).cast::<*mut u8>();
                                                                    let l57 = *arg0.add(184).cast::<usize>();
                                                                    let len58 = l57;
                                                                    let bytes58 = _rt::Vec::from_raw_parts(
                                                                        l56.cast(),
                                                                        len58,
                                                                        len58,
                                                                    );
                                                                    _rt::string_lift(bytes58)
                                                                };
                                                                Some(e)
                                                            }
                                                            _ => _rt::invalid_enum_discriminant(),
                                                        },
                                                    }
                                                };
                                                Some(e)
                                            }
                                            _ => _rt::invalid_enum_discriminant(),
                                        },
                                    }
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    _rt::cabi_dealloc(arg0, 188, 4);
                    let ptr60 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result59 {
                        Ok(e) => {
                            *ptr60.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr60.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr60.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V78;
                            match e {
                                V78::InvalidText(e) => {
                                    *ptr60.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec61 = (e.into_bytes()).into_boxed_slice();
                                    let ptr61 = vec61.as_ptr().cast::<u8>();
                                    let len61 = vec61.len();
                                    ::core::mem::forget(vec61);
                                    *ptr60.add(20).cast::<usize>() = len61;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr61.cast_mut();
                                }
                                V78::TextTooLong(e) => {
                                    *ptr60.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V78::InvalidSsml(e) => {
                                    *ptr60.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec62 = (e.into_bytes()).into_boxed_slice();
                                    let ptr62 = vec62.as_ptr().cast::<u8>();
                                    let len62 = vec62.len();
                                    ::core::mem::forget(vec62);
                                    *ptr60.add(20).cast::<usize>() = len62;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr62.cast_mut();
                                }
                                V78::UnsupportedLanguage(e) => {
                                    *ptr60.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec63 = (e.into_bytes()).into_boxed_slice();
                                    let ptr63 = vec63.as_ptr().cast::<u8>();
                                    let len63 = vec63.len();
                                    ::core::mem::forget(vec63);
                                    *ptr60.add(20).cast::<usize>() = len63;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr63.cast_mut();
                                }
                                V78::VoiceNotFound(e) => {
                                    *ptr60.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec64 = (e.into_bytes()).into_boxed_slice();
                                    let ptr64 = vec64.as_ptr().cast::<u8>();
                                    let len64 = vec64.len();
                                    ::core::mem::forget(vec64);
                                    *ptr60.add(20).cast::<usize>() = len64;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr64.cast_mut();
                                }
                                V78::ModelNotFound(e) => {
                                    *ptr60.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec65 = (e.into_bytes()).into_boxed_slice();
                                    let ptr65 = vec65.as_ptr().cast::<u8>();
                                    let len65 = vec65.len();
                                    ::core::mem::forget(vec65);
                                    *ptr60.add(20).cast::<usize>() = len65;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr65.cast_mut();
                                }
                                V78::VoiceUnavailable(e) => {
                                    *ptr60.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec66 = (e.into_bytes()).into_boxed_slice();
                                    let ptr66 = vec66.as_ptr().cast::<u8>();
                                    let len66 = vec66.len();
                                    ::core::mem::forget(vec66);
                                    *ptr60.add(20).cast::<usize>() = len66;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr66.cast_mut();
                                }
                                V78::Unauthorized(e) => {
                                    *ptr60.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec67 = (e.into_bytes()).into_boxed_slice();
                                    let ptr67 = vec67.as_ptr().cast::<u8>();
                                    let len67 = vec67.len();
                                    ::core::mem::forget(vec67);
                                    *ptr60.add(20).cast::<usize>() = len67;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr67.cast_mut();
                                }
                                V78::AccessDenied(e) => {
                                    *ptr60.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec68 = (e.into_bytes()).into_boxed_slice();
                                    let ptr68 = vec68.as_ptr().cast::<u8>();
                                    let len68 = vec68.len();
                                    ::core::mem::forget(vec68);
                                    *ptr60.add(20).cast::<usize>() = len68;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr68.cast_mut();
                                }
                                V78::QuotaExceeded(e) => {
                                    *ptr60.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used69,
                                        limit: limit69,
                                        reset_time: reset_time69,
                                        unit: unit69,
                                    } = e;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(used69);
                                    *ptr60.add(20).cast::<i32>() = _rt::as_i32(limit69);
                                    *ptr60.add(24).cast::<i64>() = _rt::as_i64(reset_time69);
                                    *ptr60.add(32).cast::<u8>() = (unit69.clone() as i32) as u8;
                                }
                                V78::RateLimited(e) => {
                                    *ptr60.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr60.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V78::InsufficientCredits => {
                                    *ptr60.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V78::SynthesisFailed(e) => {
                                    *ptr60.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec70 = (e.into_bytes()).into_boxed_slice();
                                    let ptr70 = vec70.as_ptr().cast::<u8>();
                                    let len70 = vec70.len();
                                    ::core::mem::forget(vec70);
                                    *ptr60.add(20).cast::<usize>() = len70;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr70.cast_mut();
                                }
                                V78::UnsupportedOperation(e) => {
                                    *ptr60.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec71 = (e.into_bytes()).into_boxed_slice();
                                    let ptr71 = vec71.as_ptr().cast::<u8>();
                                    let len71 = vec71.len();
                                    ::core::mem::forget(vec71);
                                    *ptr60.add(20).cast::<usize>() = len71;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr71.cast_mut();
                                }
                                V78::InvalidConfiguration(e) => {
                                    *ptr60.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec72 = (e.into_bytes()).into_boxed_slice();
                                    let ptr72 = vec72.as_ptr().cast::<u8>();
                                    let len72 = vec72.len();
                                    ::core::mem::forget(vec72);
                                    *ptr60.add(20).cast::<usize>() = len72;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr72.cast_mut();
                                }
                                V78::ServiceUnavailable(e) => {
                                    *ptr60.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec73 = (e.into_bytes()).into_boxed_slice();
                                    let ptr73 = vec73.as_ptr().cast::<u8>();
                                    let len73 = vec73.len();
                                    ::core::mem::forget(vec73);
                                    *ptr60.add(20).cast::<usize>() = len73;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr73.cast_mut();
                                }
                                V78::NetworkError(e) => {
                                    *ptr60.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec74 = (e.into_bytes()).into_boxed_slice();
                                    let ptr74 = vec74.as_ptr().cast::<u8>();
                                    let len74 = vec74.len();
                                    ::core::mem::forget(vec74);
                                    *ptr60.add(20).cast::<usize>() = len74;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr74.cast_mut();
                                }
                                V78::InternalError(e) => {
                                    *ptr60.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec75 = (e.into_bytes()).into_boxed_slice();
                                    let ptr75 = vec75.as_ptr().cast::<u8>();
                                    let len75 = vec75.len();
                                    ::core::mem::forget(vec75);
                                    *ptr60.add(20).cast::<usize>() = len75;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr75.cast_mut();
                                }
                                V78::InvalidStorageLocation(e) => {
                                    *ptr60.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec76 = (e.into_bytes()).into_boxed_slice();
                                    let ptr76 = vec76.as_ptr().cast::<u8>();
                                    let len76 = vec76.len();
                                    ::core::mem::forget(vec76);
                                    *ptr60.add(20).cast::<usize>() = len76;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr76.cast_mut();
                                }
                                V78::StorageAccessDenied(e) => {
                                    *ptr60.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec77 = (e.into_bytes()).into_boxed_slice();
                                    let ptr77 = vec77.as_ptr().cast::<u8>();
                                    let len77 = vec77.len();
                                    ::core::mem::forget(vec77);
                                    *ptr60.add(20).cast::<usize>() = len77;
                                    *ptr60.add(16).cast::<*mut u8>() = ptr77.cast_mut();
                                }
                            }
                        }
                    };
                    ptr60
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_voice_conversion_stream<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_send_audio_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8, arg1: *mut u8, arg2: usize) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let result1 = T::send_audio(
                        VoiceConversionStreamBorrow::lift(arg0 as u32 as usize).get(),
                        _rt::Vec::from_raw_parts(arg1.cast(), len0, len0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2.add(20).cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2.add(20).cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_send_audio<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_receive_converted_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::receive_converted(
                        VoiceConversionStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            match e {
                                Some(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::AudioChunk {
                                        data: data2,
                                        sequence_number: sequence_number2,
                                        is_final: is_final2,
                                        timing_info: timing_info2,
                                    } = e;
                                    let vec3 = (data2).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(16).cast::<usize>() = len3;
                                    *ptr1.add(12).cast::<*mut u8>() = ptr3.cast_mut();
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(sequence_number2);
                                    *ptr1.add(24).cast::<u8>() = (match is_final2 {
                                        true => 1,
                                        false => 0,
                                    }) as u8;
                                    match timing_info2 {
                                        Some(e) => {
                                            *ptr1.add(28).cast::<u8>() = (1i32) as u8;
                                            let super::super::super::super::exports::golem::tts::types::TimingInfo {
                                                start_time_seconds: start_time_seconds4,
                                                end_time_seconds: end_time_seconds4,
                                                text_offset: text_offset4,
                                                mark_type: mark_type4,
                                            } = e;
                                            *ptr1.add(32).cast::<f32>() = _rt::as_f32(
                                                start_time_seconds4,
                                            );
                                            match end_time_seconds4 {
                                                Some(e) => {
                                                    *ptr1.add(36).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(40).cast::<f32>() = _rt::as_f32(e);
                                                }
                                                None => {
                                                    *ptr1.add(36).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match text_offset4 {
                                                Some(e) => {
                                                    *ptr1.add(44).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(48).cast::<i32>() = _rt::as_i32(e);
                                                }
                                                None => {
                                                    *ptr1.add(44).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                            match mark_type4 {
                                                Some(e) => {
                                                    *ptr1.add(52).cast::<u8>() = (1i32) as u8;
                                                    *ptr1.add(53).cast::<u8>() = (e.clone() as i32) as u8;
                                                }
                                                None => {
                                                    *ptr1.add(52).cast::<u8>() = (0i32) as u8;
                                                }
                                            };
                                        }
                                        None => {
                                            *ptr1.add(28).cast::<u8>() = (0i32) as u8;
                                        }
                                    };
                                }
                                None => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1.add(20).cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr1.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1.add(20).cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1.add(20).cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_receive_converted<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {}
                                _ => {
                                    let l2 = *arg0.add(12).cast::<*mut u8>();
                                    let l3 = *arg0.add(16).cast::<usize>();
                                    let base4 = l2;
                                    let len4 = l3;
                                    _rt::cabi_dealloc(base4, len4 * 1, 1);
                                }
                            }
                        }
                        _ => {
                            let l5 = i32::from(*arg0.add(8).cast::<u8>());
                            match l5 {
                                0 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                1 => {}
                                2 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                3 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                4 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                5 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                6 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                7 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                8 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                13 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                14 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                15 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                16 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                17 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                18 => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                                _ => {
                                    let l36 = *arg0.add(16).cast::<*mut u8>();
                                    let l37 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l36, l37, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_finish_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::finish(
                        VoiceConversionStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_voice_conversion_stream_finish<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_voice_conversion_stream_close_cabi<
                    T: GuestVoiceConversionStream,
                >(arg0: *mut u8) {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    T::close(
                        VoiceConversionStreamBorrow::lift(arg0 as u32 as usize).get(),
                    );
                }
                pub trait Guest {
                    type SynthesisStream: GuestSynthesisStream;
                    type VoiceConversionStream: GuestVoiceConversionStream;
                    /// Create streaming synthesis session
                    fn create_stream(
                        voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<SynthesisStream, TtsError>;
                    /// Real-time voice conversion streaming
                    fn create_voice_conversion_stream(
                        target_voice: VoiceBorrow<'_>,
                        options: Option<SynthesisOptions>,
                    ) -> Result<VoiceConversionStream, TtsError>;
                }
                pub trait GuestSynthesisStream: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]synthesis-stream"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]synthesis-stream"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Send text for synthesis (can be called multiple times)
                    fn send_text(&self, input: TextInput) -> Result<(), TtsError>;
                    /// Signal end of input and flush remaining audio
                    fn finish(&self) -> Result<(), TtsError>;
                    /// Receive next audio chunk (non-blocking)
                    fn receive_chunk(&self) -> Result<Option<AudioChunk>, TtsError>;
                    /// Check if more chunks are available
                    fn has_pending_audio(&self) -> bool;
                    /// Get current stream status
                    fn get_status(&self) -> StreamStatus;
                    /// Close stream and clean up resources
                    fn close(&self);
                }
                pub trait GuestVoiceConversionStream: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]voice-conversion-stream"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/streaming@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]voice-conversion-stream"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    /// Send input audio chunks
                    fn send_audio(
                        &self,
                        audio_data: _rt::Vec<u8>,
                    ) -> Result<(), TtsError>;
                    /// Receive converted audio chunks
                    fn receive_converted(&self) -> Result<Option<AudioChunk>, TtsError>;
                    fn finish(&self) -> Result<(), TtsError>;
                    fn close(&self);
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_streaming_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.send-text"]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_send_text(arg0 : * mut u8, arg1 :
                        * mut u8, arg2 : usize, arg3 : i32, arg4 : i32, arg5 : * mut u8,
                        arg6 : usize,) -> * mut u8 { $($path_to_types)*::
                        _export_method_synthesis_stream_send_text_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0, arg1,
                        arg2, arg3, arg4, arg5, arg6) } #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.send-text"]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_send_text(arg0 : * mut u8,)
                        { $($path_to_types)*::
                        __post_return_method_synthesis_stream_send_text::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.finish"]
                        unsafe extern "C" fn export_method_synthesis_stream_finish(arg0 :
                        * mut u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_synthesis_stream_finish_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.finish"]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_finish(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_method_synthesis_stream_finish::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.receive-chunk"]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_receive_chunk(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_synthesis_stream_receive_chunk_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]synthesis-stream.receive-chunk"]
                        unsafe extern "C" fn
                        _post_return_method_synthesis_stream_receive_chunk(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_synthesis_stream_receive_chunk::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.has-pending-audio"]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_has_pending_audio(arg0 : * mut
                        u8,) -> i32 { $($path_to_types)*::
                        _export_method_synthesis_stream_has_pending_audio_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.get-status"]
                        unsafe extern "C" fn
                        export_method_synthesis_stream_get_status(arg0 : * mut u8,) ->
                        i32 { $($path_to_types)*::
                        _export_method_synthesis_stream_get_status_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]synthesis-stream.close"]
                        unsafe extern "C" fn export_method_synthesis_stream_close(arg0 :
                        * mut u8,) { $($path_to_types)*::
                        _export_method_synthesis_stream_close_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (arg0) }
                        #[export_name = "golem:tts/streaming@1.0.0#create-stream"] unsafe
                        extern "C" fn export_create_stream(arg0 : * mut u8,) -> * mut u8
                        { $($path_to_types)*:: _export_create_stream_cabi::<$ty > (arg0)
                        } #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#create-stream"] unsafe
                        extern "C" fn _post_return_create_stream(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_create_stream::<$ty > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#create-voice-conversion-stream"]
                        unsafe extern "C" fn export_create_voice_conversion_stream(arg0 :
                        * mut u8,) -> * mut u8 { $($path_to_types)*::
                        _export_create_voice_conversion_stream_cabi::<$ty > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#create-voice-conversion-stream"]
                        unsafe extern "C" fn
                        _post_return_create_voice_conversion_stream(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        __post_return_create_voice_conversion_stream::<$ty > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.send-audio"]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_send_audio(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize,) -> * mut u8 {
                        $($path_to_types)*::
                        _export_method_voice_conversion_stream_send_audio_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0,
                        arg1, arg2) } #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.send-audio"]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_send_audio(arg0 : *
                        mut u8,) { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_send_audio::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.receive-converted"]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_receive_converted(arg0 : *
                        mut u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_voice_conversion_stream_receive_converted_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.receive-converted"]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_receive_converted(arg0
                        : * mut u8,) { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_receive_converted::<<$ty
                        as $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.finish"]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_finish(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_voice_conversion_stream_finish_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/streaming@1.0.0#[method]voice-conversion-stream.finish"]
                        unsafe extern "C" fn
                        _post_return_method_voice_conversion_stream_finish(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_voice_conversion_stream_finish::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        #[export_name =
                        "golem:tts/streaming@1.0.0#[method]voice-conversion-stream.close"]
                        unsafe extern "C" fn
                        export_method_voice_conversion_stream_close(arg0 : * mut u8,) {
                        $($path_to_types)*::
                        _export_method_voice_conversion_stream_close_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (arg0) }
                        const _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/streaming@1.0.0#[dtor]synthesis-stream"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: SynthesisStream::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::SynthesisStream > (rep) } }; const
                        _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/streaming@1.0.0#[dtor]voice-conversion-stream"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: VoiceConversionStream::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::VoiceConversionStream > (rep) } };
                        };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_streaming_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 56]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 56],
                );
            }
            /// Advanced TTS features and voice manipulation
            #[allow(dead_code, clippy::all)]
            pub mod advanced {
                #[used]
                #[doc(hidden)]
                static __FORCE_SECTION_REF: fn() = super::super::super::super::__link_custom_section_describing_imports;
                use super::super::super::super::_rt;
                pub type TtsError = super::super::super::super::exports::golem::tts::types::TtsError;
                pub type AudioConfig = super::super::super::super::exports::golem::tts::types::AudioConfig;
                pub type LanguageCode = super::super::super::super::exports::golem::tts::types::LanguageCode;
                pub type VoiceGender = super::super::super::super::exports::golem::tts::types::VoiceGender;
                pub type SynthesisMetadata = super::super::super::super::exports::golem::tts::types::SynthesisMetadata;
                pub type Voice = super::super::super::super::exports::golem::tts::voices::Voice;
                pub type VoiceBorrow<'a> = super::super::super::super::exports::golem::tts::voices::VoiceBorrow<
                    'a,
                >;
                #[derive(Clone)]
                pub struct AudioSample {
                    pub data: _rt::Vec<u8>,
                    pub transcript: Option<_rt::String>,
                    pub quality_rating: Option<u8>,
                }
                impl ::core::fmt::Debug for AudioSample {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("AudioSample")
                            .field("data", &self.data)
                            .field("transcript", &self.transcript)
                            .field("quality-rating", &self.quality_rating)
                            .finish()
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum AgeCategory {
                    Child,
                    YoungAdult,
                    MiddleAged,
                    Elderly,
                }
                impl ::core::fmt::Debug for AgeCategory {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            AgeCategory::Child => {
                                f.debug_tuple("AgeCategory::Child").finish()
                            }
                            AgeCategory::YoungAdult => {
                                f.debug_tuple("AgeCategory::YoungAdult").finish()
                            }
                            AgeCategory::MiddleAged => {
                                f.debug_tuple("AgeCategory::MiddleAged").finish()
                            }
                            AgeCategory::Elderly => {
                                f.debug_tuple("AgeCategory::Elderly").finish()
                            }
                        }
                    }
                }
                impl AgeCategory {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> AgeCategory {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => AgeCategory::Child,
                            1 => AgeCategory::YoungAdult,
                            2 => AgeCategory::MiddleAged,
                            3 => AgeCategory::Elderly,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct VoiceDesignParams {
                    pub gender: VoiceGender,
                    pub age_category: AgeCategory,
                    pub accent: _rt::String,
                    pub personality_traits: _rt::Vec<_rt::String>,
                    pub reference_voice: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for VoiceDesignParams {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("VoiceDesignParams")
                            .field("gender", &self.gender)
                            .field("age-category", &self.age_category)
                            .field("accent", &self.accent)
                            .field("personality-traits", &self.personality_traits)
                            .field("reference-voice", &self.reference_voice)
                            .finish()
                    }
                }
                /// Custom pronunciation management
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct PronunciationLexicon {
                    handle: _rt::Resource<PronunciationLexicon>,
                }
                type _PronunciationLexiconRep<T> = Option<T>;
                impl PronunciationLexicon {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `PronunciationLexicon`.
                    pub fn new<T: GuestPronunciationLexicon>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _PronunciationLexiconRep<T> = Some(val);
                        let ptr: *mut _PronunciationLexiconRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestPronunciationLexicon>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestPronunciationLexicon>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestPronunciationLexicon>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(
                            handle as *mut _PronunciationLexiconRep<T>,
                        );
                    }
                    fn as_ptr<T: GuestPronunciationLexicon>(
                        &self,
                    ) -> *mut _PronunciationLexiconRep<T> {
                        PronunciationLexicon::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`PronunciationLexicon`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct PronunciationLexiconBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a PronunciationLexicon>,
                }
                impl<'a> PronunciationLexiconBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestPronunciationLexicon>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _PronunciationLexiconRep<T> {
                        PronunciationLexicon::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for PronunciationLexicon {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]pronunciation-lexicon"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[derive(Clone)]
                pub struct PronunciationEntry {
                    pub word: _rt::String,
                    pub pronunciation: _rt::String,
                    pub part_of_speech: Option<_rt::String>,
                }
                impl ::core::fmt::Debug for PronunciationEntry {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("PronunciationEntry")
                            .field("word", &self.word)
                            .field("pronunciation", &self.pronunciation)
                            .field("part-of-speech", &self.part_of_speech)
                            .finish()
                    }
                }
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct LongFormOperation {
                    handle: _rt::Resource<LongFormOperation>,
                }
                type _LongFormOperationRep<T> = Option<T>;
                impl LongFormOperation {
                    /// Creates a new resource from the specified representation.
                    ///
                    /// This function will create a new resource handle by moving `val` onto
                    /// the heap and then passing that heap pointer to the component model to
                    /// create a handle. The owned handle is then returned as `LongFormOperation`.
                    pub fn new<T: GuestLongFormOperation>(val: T) -> Self {
                        Self::type_guard::<T>();
                        let val: _LongFormOperationRep<T> = Some(val);
                        let ptr: *mut _LongFormOperationRep<T> = _rt::Box::into_raw(
                            _rt::Box::new(val),
                        );
                        unsafe { Self::from_handle(T::_resource_new(ptr.cast())) }
                    }
                    /// Gets access to the underlying `T` which represents this resource.
                    pub fn get<T: GuestLongFormOperation>(&self) -> &T {
                        let ptr = unsafe { &*self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    /// Gets mutable access to the underlying `T` which represents this
                    /// resource.
                    pub fn get_mut<T: GuestLongFormOperation>(&mut self) -> &mut T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_mut().unwrap()
                    }
                    /// Consumes this resource and returns the underlying `T`.
                    pub fn into_inner<T: GuestLongFormOperation>(self) -> T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.take().unwrap()
                    }
                    #[doc(hidden)]
                    pub unsafe fn from_handle(handle: u32) -> Self {
                        Self {
                            handle: _rt::Resource::from_handle(handle),
                        }
                    }
                    #[doc(hidden)]
                    pub fn take_handle(&self) -> u32 {
                        _rt::Resource::take_handle(&self.handle)
                    }
                    #[doc(hidden)]
                    pub fn handle(&self) -> u32 {
                        _rt::Resource::handle(&self.handle)
                    }
                    #[doc(hidden)]
                    fn type_guard<T: 'static>() {
                        use core::any::TypeId;
                        static mut LAST_TYPE: Option<TypeId> = None;
                        unsafe {
                            assert!(! cfg!(target_feature = "atomics"));
                            let id = TypeId::of::<T>();
                            match LAST_TYPE {
                                Some(ty) => {
                                    assert!(
                                        ty == id, "cannot use two types with this resource type"
                                    )
                                }
                                None => LAST_TYPE = Some(id),
                            }
                        }
                    }
                    #[doc(hidden)]
                    pub unsafe fn dtor<T: 'static>(handle: *mut u8) {
                        Self::type_guard::<T>();
                        let _ = _rt::Box::from_raw(
                            handle as *mut _LongFormOperationRep<T>,
                        );
                    }
                    fn as_ptr<T: GuestLongFormOperation>(
                        &self,
                    ) -> *mut _LongFormOperationRep<T> {
                        LongFormOperation::type_guard::<T>();
                        T::_resource_rep(self.handle()).cast()
                    }
                }
                /// A borrowed version of [`LongFormOperation`] which represents a borrowed value
                /// with the lifetime `'a`.
                #[derive(Debug)]
                #[repr(transparent)]
                pub struct LongFormOperationBorrow<'a> {
                    rep: *mut u8,
                    _marker: core::marker::PhantomData<&'a LongFormOperation>,
                }
                impl<'a> LongFormOperationBorrow<'a> {
                    #[doc(hidden)]
                    pub unsafe fn lift(rep: usize) -> Self {
                        Self {
                            rep: rep as *mut u8,
                            _marker: core::marker::PhantomData,
                        }
                    }
                    /// Gets access to the underlying `T` in this resource.
                    pub fn get<T: GuestLongFormOperation>(&self) -> &T {
                        let ptr = unsafe { &mut *self.as_ptr::<T>() };
                        ptr.as_ref().unwrap()
                    }
                    fn as_ptr<T: 'static>(&self) -> *mut _LongFormOperationRep<T> {
                        LongFormOperation::type_guard::<T>();
                        self.rep.cast()
                    }
                }
                unsafe impl _rt::WasmResource for LongFormOperation {
                    #[inline]
                    unsafe fn drop(_handle: u32) {
                        #[cfg(not(target_arch = "wasm32"))]
                        unreachable!();
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-drop]long-form-operation"]
                                fn drop(_: u32);
                            }
                            drop(_handle);
                        }
                    }
                }
                #[repr(u8)]
                #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
                pub enum OperationStatus {
                    Pending,
                    Processing,
                    Completed,
                    Failed,
                    Cancelled,
                }
                impl ::core::fmt::Debug for OperationStatus {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        match self {
                            OperationStatus::Pending => {
                                f.debug_tuple("OperationStatus::Pending").finish()
                            }
                            OperationStatus::Processing => {
                                f.debug_tuple("OperationStatus::Processing").finish()
                            }
                            OperationStatus::Completed => {
                                f.debug_tuple("OperationStatus::Completed").finish()
                            }
                            OperationStatus::Failed => {
                                f.debug_tuple("OperationStatus::Failed").finish()
                            }
                            OperationStatus::Cancelled => {
                                f.debug_tuple("OperationStatus::Cancelled").finish()
                            }
                        }
                    }
                }
                impl OperationStatus {
                    #[doc(hidden)]
                    pub unsafe fn _lift(val: u8) -> OperationStatus {
                        if !cfg!(debug_assertions) {
                            return ::core::mem::transmute(val);
                        }
                        match val {
                            0 => OperationStatus::Pending,
                            1 => OperationStatus::Processing,
                            2 => OperationStatus::Completed,
                            3 => OperationStatus::Failed,
                            4 => OperationStatus::Cancelled,
                            _ => panic!("invalid enum discriminant"),
                        }
                    }
                }
                #[derive(Clone)]
                pub struct LongFormResult {
                    pub output_location: _rt::String,
                    pub total_duration: f32,
                    pub chapter_durations: Option<_rt::Vec<f32>>,
                    pub metadata: SynthesisMetadata,
                }
                impl ::core::fmt::Debug for LongFormResult {
                    fn fmt(
                        &self,
                        f: &mut ::core::fmt::Formatter<'_>,
                    ) -> ::core::fmt::Result {
                        f.debug_struct("LongFormResult")
                            .field("output-location", &self.output_location)
                            .field("total-duration", &self.total_duration)
                            .field("chapter-durations", &self.chapter_durations)
                            .field("metadata", &self.metadata)
                            .finish()
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_voice_clone_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let base10 = arg2;
                    let len10 = arg3;
                    let mut result10 = _rt::Vec::with_capacity(len10);
                    for i in 0..len10 {
                        let base = base10.add(i * 24);
                        let e10 = {
                            let l1 = *base.add(0).cast::<*mut u8>();
                            let l2 = *base.add(4).cast::<usize>();
                            let len3 = l2;
                            let l4 = i32::from(*base.add(8).cast::<u8>());
                            let l8 = i32::from(*base.add(20).cast::<u8>());
                            AudioSample {
                                data: _rt::Vec::from_raw_parts(l1.cast(), len3, len3),
                                transcript: match l4 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l5 = *base.add(12).cast::<*mut u8>();
                                            let l6 = *base.add(16).cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            _rt::string_lift(bytes7)
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                                quality_rating: match l8 {
                                    0 => None,
                                    1 => {
                                        let e = {
                                            let l9 = i32::from(*base.add(21).cast::<u8>());
                                            l9 as u8
                                        };
                                        Some(e)
                                    }
                                    _ => _rt::invalid_enum_discriminant(),
                                },
                            }
                        };
                        result10.push(e10);
                    }
                    _rt::cabi_dealloc(base10, len10 * 24, 4);
                    let result12 = T::create_voice_clone(
                        _rt::string_lift(bytes0),
                        result10,
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len11 = arg6;
                                    let bytes11 = _rt::Vec::from_raw_parts(
                                        arg5.cast(),
                                        len11,
                                        len11,
                                    );
                                    _rt::string_lift(bytes11)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr13 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result12 {
                        Ok(e) => {
                            *ptr13.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr13.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr13.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V31;
                            match e {
                                V31::InvalidText(e) => {
                                    *ptr13.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr13.add(20).cast::<usize>() = len14;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V31::TextTooLong(e) => {
                                    *ptr13.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InvalidSsml(e) => {
                                    *ptr13.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr13.add(20).cast::<usize>() = len15;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V31::UnsupportedLanguage(e) => {
                                    *ptr13.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr13.add(20).cast::<usize>() = len16;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V31::VoiceNotFound(e) => {
                                    *ptr13.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr13.add(20).cast::<usize>() = len17;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V31::ModelNotFound(e) => {
                                    *ptr13.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr13.add(20).cast::<usize>() = len18;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V31::VoiceUnavailable(e) => {
                                    *ptr13.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr13.add(20).cast::<usize>() = len19;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V31::Unauthorized(e) => {
                                    *ptr13.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr13.add(20).cast::<usize>() = len20;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V31::AccessDenied(e) => {
                                    *ptr13.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr13.add(20).cast::<usize>() = len21;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V31::QuotaExceeded(e) => {
                                    *ptr13.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used22,
                                        limit: limit22,
                                        reset_time: reset_time22,
                                        unit: unit22,
                                    } = e;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(used22);
                                    *ptr13.add(20).cast::<i32>() = _rt::as_i32(limit22);
                                    *ptr13.add(24).cast::<i64>() = _rt::as_i64(reset_time22);
                                    *ptr13.add(32).cast::<u8>() = (unit22.clone() as i32) as u8;
                                }
                                V31::RateLimited(e) => {
                                    *ptr13.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr13.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V31::InsufficientCredits => {
                                    *ptr13.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V31::SynthesisFailed(e) => {
                                    *ptr13.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr13.add(20).cast::<usize>() = len23;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V31::UnsupportedOperation(e) => {
                                    *ptr13.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr13.add(20).cast::<usize>() = len24;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V31::InvalidConfiguration(e) => {
                                    *ptr13.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr13.add(20).cast::<usize>() = len25;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V31::ServiceUnavailable(e) => {
                                    *ptr13.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr13.add(20).cast::<usize>() = len26;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V31::NetworkError(e) => {
                                    *ptr13.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr13.add(20).cast::<usize>() = len27;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V31::InternalError(e) => {
                                    *ptr13.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr13.add(20).cast::<usize>() = len28;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V31::InvalidStorageLocation(e) => {
                                    *ptr13.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr13.add(20).cast::<usize>() = len29;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V31::StorageAccessDenied(e) => {
                                    *ptr13.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr13.add(20).cast::<usize>() = len30;
                                    *ptr13.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                            }
                        }
                    };
                    ptr13
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_voice_clone<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_design_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: *mut u8,
                    arg5: usize,
                    arg6: *mut u8,
                    arg7: usize,
                    arg8: i32,
                    arg9: *mut u8,
                    arg10: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg5;
                    let bytes1 = _rt::Vec::from_raw_parts(arg4.cast(), len1, len1);
                    let base5 = arg6;
                    let len5 = arg7;
                    let mut result5 = _rt::Vec::with_capacity(len5);
                    for i in 0..len5 {
                        let base = base5.add(i * 8);
                        let e5 = {
                            let l2 = *base.add(0).cast::<*mut u8>();
                            let l3 = *base.add(4).cast::<usize>();
                            let len4 = l3;
                            let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);
                            _rt::string_lift(bytes4)
                        };
                        result5.push(e5);
                    }
                    _rt::cabi_dealloc(base5, len5 * 8, 4);
                    let result7 = T::design_voice(
                        _rt::string_lift(bytes0),
                        VoiceDesignParams {
                            gender: super::super::super::super::exports::golem::tts::types::VoiceGender::_lift(
                                arg2 as u8,
                            ),
                            age_category: AgeCategory::_lift(arg3 as u8),
                            accent: _rt::string_lift(bytes1),
                            personality_traits: result5,
                            reference_voice: match arg8 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let len6 = arg10;
                                        let bytes6 = _rt::Vec::from_raw_parts(
                                            arg9.cast(),
                                            len6,
                                            len6,
                                        );
                                        _rt::string_lift(bytes6)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                        },
                    );
                    let ptr8 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result7 {
                        Ok(e) => {
                            *ptr8.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr8.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr8.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V26;
                            match e {
                                V26::InvalidText(e) => {
                                    *ptr8.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr8.add(20).cast::<usize>() = len9;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V26::TextTooLong(e) => {
                                    *ptr8.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InvalidSsml(e) => {
                                    *ptr8.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr8.add(20).cast::<usize>() = len10;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V26::UnsupportedLanguage(e) => {
                                    *ptr8.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr8.add(20).cast::<usize>() = len11;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V26::VoiceNotFound(e) => {
                                    *ptr8.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr8.add(20).cast::<usize>() = len12;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V26::ModelNotFound(e) => {
                                    *ptr8.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr8.add(20).cast::<usize>() = len13;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V26::VoiceUnavailable(e) => {
                                    *ptr8.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr8.add(20).cast::<usize>() = len14;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V26::Unauthorized(e) => {
                                    *ptr8.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr8.add(20).cast::<usize>() = len15;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V26::AccessDenied(e) => {
                                    *ptr8.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr8.add(20).cast::<usize>() = len16;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V26::QuotaExceeded(e) => {
                                    *ptr8.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used17,
                                        limit: limit17,
                                        reset_time: reset_time17,
                                        unit: unit17,
                                    } = e;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(used17);
                                    *ptr8.add(20).cast::<i32>() = _rt::as_i32(limit17);
                                    *ptr8.add(24).cast::<i64>() = _rt::as_i64(reset_time17);
                                    *ptr8.add(32).cast::<u8>() = (unit17.clone() as i32) as u8;
                                }
                                V26::RateLimited(e) => {
                                    *ptr8.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr8.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V26::InsufficientCredits => {
                                    *ptr8.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V26::SynthesisFailed(e) => {
                                    *ptr8.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr8.add(20).cast::<usize>() = len18;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V26::UnsupportedOperation(e) => {
                                    *ptr8.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr8.add(20).cast::<usize>() = len19;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V26::InvalidConfiguration(e) => {
                                    *ptr8.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr8.add(20).cast::<usize>() = len20;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V26::ServiceUnavailable(e) => {
                                    *ptr8.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr8.add(20).cast::<usize>() = len21;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V26::NetworkError(e) => {
                                    *ptr8.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr8.add(20).cast::<usize>() = len22;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V26::InternalError(e) => {
                                    *ptr8.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr8.add(20).cast::<usize>() = len23;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V26::InvalidStorageLocation(e) => {
                                    *ptr8.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr8.add(20).cast::<usize>() = len24;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V26::StorageAccessDenied(e) => {
                                    *ptr8.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr8.add(20).cast::<usize>() = len25;
                                    *ptr8.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                            }
                        }
                    };
                    ptr8
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_design_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_convert_voice_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: i32,
                    arg4: i32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let result1 = T::convert_voice(
                        _rt::Vec::from_raw_parts(arg0.cast(), len0, len0),
                        VoiceBorrow::lift(arg2 as u32 as usize),
                        match arg3 {
                            0 => None,
                            1 => {
                                let e = _rt::bool_lift(arg4 as u8);
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2.add(12).cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2.add(20).cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2.add(20).cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_convert_voice<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_generate_sound_effect_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: f32,
                    arg4: i32,
                    arg5: f32,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let result1 = T::generate_sound_effect(
                        _rt::string_lift(bytes0),
                        match arg2 {
                            0 => None,
                            1 => {
                                let e = arg3;
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = arg5;
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(e) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                            let vec3 = (e).into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr2.add(12).cast::<usize>() = len3;
                            *ptr2.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr2.add(20).cast::<usize>() = len11;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr2.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr2.add(20).cast::<usize>() = len20;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_generate_sound_effect<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            let base3 = l1;
                            let len3 = l2;
                            _rt::cabi_dealloc(base3, len3 * 1, 1);
                        }
                        _ => {
                            let l4 = i32::from(*arg0.add(8).cast::<u8>());
                            match l4 {
                                0 => {
                                    let l5 = *arg0.add(16).cast::<*mut u8>();
                                    let l6 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l5, l6, 1);
                                }
                                1 => {}
                                2 => {
                                    let l7 = *arg0.add(16).cast::<*mut u8>();
                                    let l8 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l7, l8, 1);
                                }
                                3 => {
                                    let l9 = *arg0.add(16).cast::<*mut u8>();
                                    let l10 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l9, l10, 1);
                                }
                                4 => {
                                    let l11 = *arg0.add(16).cast::<*mut u8>();
                                    let l12 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l11, l12, 1);
                                }
                                5 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                6 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                7 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                8 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                13 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                14 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                15 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                16 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                17 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                18 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                _ => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_name_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_name(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_get_name<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_language_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_language(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    let vec2 = (result0.into_bytes()).into_boxed_slice();
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    ::core::mem::forget(vec2);
                    *ptr1.add(4).cast::<usize>() = len2;
                    *ptr1.add(0).cast::<*mut u8>() = ptr2.cast_mut();
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_get_language<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = *arg0.add(0).cast::<*mut u8>();
                    let l1 = *arg0.add(4).cast::<usize>();
                    _rt::cabi_dealloc(l0, l1, 1);
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_get_entry_count_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_entry_count(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    _rt::as_i32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_add_entry_cabi<
                    T: GuestPronunciationLexicon,
                >(
                    arg0: *mut u8,
                    arg1: *mut u8,
                    arg2: usize,
                    arg3: *mut u8,
                    arg4: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let len1 = arg4;
                    let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);
                    let result2 = T::add_entry(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                    );
                    let ptr3 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result2 {
                        Ok(_) => {
                            *ptr3.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr3.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V21;
                            match e {
                                V21::InvalidText(e) => {
                                    *ptr3.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr3.add(20).cast::<usize>() = len4;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V21::TextTooLong(e) => {
                                    *ptr3.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InvalidSsml(e) => {
                                    *ptr3.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr3.add(20).cast::<usize>() = len5;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V21::UnsupportedLanguage(e) => {
                                    *ptr3.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr3.add(20).cast::<usize>() = len6;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V21::VoiceNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr3.add(20).cast::<usize>() = len7;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V21::ModelNotFound(e) => {
                                    *ptr3.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr3.add(20).cast::<usize>() = len8;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V21::VoiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr3.add(20).cast::<usize>() = len9;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V21::Unauthorized(e) => {
                                    *ptr3.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr3.add(20).cast::<usize>() = len10;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V21::AccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr3.add(20).cast::<usize>() = len11;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V21::QuotaExceeded(e) => {
                                    *ptr3.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used12,
                                        limit: limit12,
                                        reset_time: reset_time12,
                                        unit: unit12,
                                    } = e;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(used12);
                                    *ptr3.add(20).cast::<i32>() = _rt::as_i32(limit12);
                                    *ptr3.add(24).cast::<i64>() = _rt::as_i64(reset_time12);
                                    *ptr3.add(32).cast::<u8>() = (unit12.clone() as i32) as u8;
                                }
                                V21::RateLimited(e) => {
                                    *ptr3.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr3.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V21::InsufficientCredits => {
                                    *ptr3.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V21::SynthesisFailed(e) => {
                                    *ptr3.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr3.add(20).cast::<usize>() = len13;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V21::UnsupportedOperation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr3.add(20).cast::<usize>() = len14;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V21::InvalidConfiguration(e) => {
                                    *ptr3.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr3.add(20).cast::<usize>() = len15;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V21::ServiceUnavailable(e) => {
                                    *ptr3.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr3.add(20).cast::<usize>() = len16;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V21::NetworkError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr3.add(20).cast::<usize>() = len17;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V21::InternalError(e) => {
                                    *ptr3.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr3.add(20).cast::<usize>() = len18;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V21::InvalidStorageLocation(e) => {
                                    *ptr3.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr3.add(20).cast::<usize>() = len19;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V21::StorageAccessDenied(e) => {
                                    *ptr3.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr3.add(20).cast::<usize>() = len20;
                                    *ptr3.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                            }
                        }
                    };
                    ptr3
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_add_entry<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_remove_entry_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8, arg1: *mut u8, arg2: usize) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg2;
                    let bytes0 = _rt::Vec::from_raw_parts(arg1.cast(), len0, len0);
                    let result1 = T::remove_entry(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                        _rt::string_lift(bytes0),
                    );
                    let ptr2 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result1 {
                        Ok(_) => {
                            *ptr2.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr2.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr2.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr2.add(20).cast::<usize>() = len3;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr2.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr2.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr2.add(20).cast::<usize>() = len4;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr2.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr2.add(20).cast::<usize>() = len5;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr2.add(20).cast::<usize>() = len6;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr2.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr2.add(20).cast::<usize>() = len7;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr2.add(20).cast::<usize>() = len8;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr2.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr2.add(20).cast::<usize>() = len9;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr2.add(20).cast::<usize>() = len10;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr2.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr2.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr2.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr2.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr2.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr2.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr2.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr2.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr2.add(20).cast::<usize>() = len12;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr2.add(20).cast::<usize>() = len13;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr2.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr2.add(20).cast::<usize>() = len14;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr2.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr2.add(20).cast::<usize>() = len15;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr2.add(20).cast::<usize>() = len16;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr2.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr2.add(20).cast::<usize>() = len17;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr2.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr2.add(20).cast::<usize>() = len18;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr2.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr2.add(20).cast::<usize>() = len19;
                                    *ptr2.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr2
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_remove_entry<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_pronunciation_lexicon_export_content_cabi<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::export_content(
                        PronunciationLexiconBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let vec2 = (e.into_bytes()).into_boxed_slice();
                            let ptr2 = vec2.as_ptr().cast::<u8>();
                            let len2 = vec2.len();
                            ::core::mem::forget(vec2);
                            *ptr1.add(12).cast::<usize>() = len2;
                            *ptr1.add(8).cast::<*mut u8>() = ptr2.cast_mut();
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V20;
                            match e {
                                V20::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V20::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V20::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V20::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V20::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V20::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V20::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V20::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1.add(20).cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V20::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used11,
                                        limit: limit11,
                                        reset_time: reset_time11,
                                        unit: unit11,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used11);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit11);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time11);
                                    *ptr1.add(32).cast::<u8>() = (unit11.clone() as i32) as u8;
                                }
                                V20::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V20::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V20::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V20::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V20::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V20::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V20::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V20::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V20::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V20::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_pronunciation_lexicon_export_content<
                    T: GuestPronunciationLexicon,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                        }
                        _ => {
                            let l3 = i32::from(*arg0.add(8).cast::<u8>());
                            match l3 {
                                0 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                1 => {}
                                2 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                3 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                4 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                5 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                6 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                7 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                8 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                13 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                14 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                15 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                16 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                17 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                18 => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                                _ => {
                                    let l34 = *arg0.add(16).cast::<*mut u8>();
                                    let l35 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l34, l35, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_create_lexicon_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: *mut u8,
                    arg3: usize,
                    arg4: i32,
                    arg5: *mut u8,
                    arg6: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg3;
                    let bytes1 = _rt::Vec::from_raw_parts(arg2.cast(), len1, len1);
                    let result13 = T::create_lexicon(
                        _rt::string_lift(bytes0),
                        _rt::string_lift(bytes1),
                        match arg4 {
                            0 => None,
                            1 => {
                                let e = {
                                    let base12 = arg5;
                                    let len12 = arg6;
                                    let mut result12 = _rt::Vec::with_capacity(len12);
                                    for i in 0..len12 {
                                        let base = base12.add(i * 28);
                                        let e12 = {
                                            let l2 = *base.add(0).cast::<*mut u8>();
                                            let l3 = *base.add(4).cast::<usize>();
                                            let len4 = l3;
                                            let bytes4 = _rt::Vec::from_raw_parts(
                                                l2.cast(),
                                                len4,
                                                len4,
                                            );
                                            let l5 = *base.add(8).cast::<*mut u8>();
                                            let l6 = *base.add(12).cast::<usize>();
                                            let len7 = l6;
                                            let bytes7 = _rt::Vec::from_raw_parts(
                                                l5.cast(),
                                                len7,
                                                len7,
                                            );
                                            let l8 = i32::from(*base.add(16).cast::<u8>());
                                            PronunciationEntry {
                                                word: _rt::string_lift(bytes4),
                                                pronunciation: _rt::string_lift(bytes7),
                                                part_of_speech: match l8 {
                                                    0 => None,
                                                    1 => {
                                                        let e = {
                                                            let l9 = *base.add(20).cast::<*mut u8>();
                                                            let l10 = *base.add(24).cast::<usize>();
                                                            let len11 = l10;
                                                            let bytes11 = _rt::Vec::from_raw_parts(
                                                                l9.cast(),
                                                                len11,
                                                                len11,
                                                            );
                                                            _rt::string_lift(bytes11)
                                                        };
                                                        Some(e)
                                                    }
                                                    _ => _rt::invalid_enum_discriminant(),
                                                },
                                            }
                                        };
                                        result12.push(e12);
                                    }
                                    _rt::cabi_dealloc(base12, len12 * 28, 4);
                                    result12
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr14 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result13 {
                        Ok(e) => {
                            *ptr14.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr14.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr14.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V32;
                            match e {
                                V32::InvalidText(e) => {
                                    *ptr14.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr14.add(20).cast::<usize>() = len15;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V32::TextTooLong(e) => {
                                    *ptr14.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V32::InvalidSsml(e) => {
                                    *ptr14.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr14.add(20).cast::<usize>() = len16;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V32::UnsupportedLanguage(e) => {
                                    *ptr14.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr14.add(20).cast::<usize>() = len17;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V32::VoiceNotFound(e) => {
                                    *ptr14.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr14.add(20).cast::<usize>() = len18;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V32::ModelNotFound(e) => {
                                    *ptr14.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr14.add(20).cast::<usize>() = len19;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V32::VoiceUnavailable(e) => {
                                    *ptr14.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr14.add(20).cast::<usize>() = len20;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V32::Unauthorized(e) => {
                                    *ptr14.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr14.add(20).cast::<usize>() = len21;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V32::AccessDenied(e) => {
                                    *ptr14.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr14.add(20).cast::<usize>() = len22;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V32::QuotaExceeded(e) => {
                                    *ptr14.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used23,
                                        limit: limit23,
                                        reset_time: reset_time23,
                                        unit: unit23,
                                    } = e;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(used23);
                                    *ptr14.add(20).cast::<i32>() = _rt::as_i32(limit23);
                                    *ptr14.add(24).cast::<i64>() = _rt::as_i64(reset_time23);
                                    *ptr14.add(32).cast::<u8>() = (unit23.clone() as i32) as u8;
                                }
                                V32::RateLimited(e) => {
                                    *ptr14.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr14.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V32::InsufficientCredits => {
                                    *ptr14.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V32::SynthesisFailed(e) => {
                                    *ptr14.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr14.add(20).cast::<usize>() = len24;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                                V32::UnsupportedOperation(e) => {
                                    *ptr14.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec25 = (e.into_bytes()).into_boxed_slice();
                                    let ptr25 = vec25.as_ptr().cast::<u8>();
                                    let len25 = vec25.len();
                                    ::core::mem::forget(vec25);
                                    *ptr14.add(20).cast::<usize>() = len25;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr25.cast_mut();
                                }
                                V32::InvalidConfiguration(e) => {
                                    *ptr14.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec26 = (e.into_bytes()).into_boxed_slice();
                                    let ptr26 = vec26.as_ptr().cast::<u8>();
                                    let len26 = vec26.len();
                                    ::core::mem::forget(vec26);
                                    *ptr14.add(20).cast::<usize>() = len26;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr26.cast_mut();
                                }
                                V32::ServiceUnavailable(e) => {
                                    *ptr14.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec27 = (e.into_bytes()).into_boxed_slice();
                                    let ptr27 = vec27.as_ptr().cast::<u8>();
                                    let len27 = vec27.len();
                                    ::core::mem::forget(vec27);
                                    *ptr14.add(20).cast::<usize>() = len27;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr27.cast_mut();
                                }
                                V32::NetworkError(e) => {
                                    *ptr14.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec28 = (e.into_bytes()).into_boxed_slice();
                                    let ptr28 = vec28.as_ptr().cast::<u8>();
                                    let len28 = vec28.len();
                                    ::core::mem::forget(vec28);
                                    *ptr14.add(20).cast::<usize>() = len28;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr28.cast_mut();
                                }
                                V32::InternalError(e) => {
                                    *ptr14.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec29 = (e.into_bytes()).into_boxed_slice();
                                    let ptr29 = vec29.as_ptr().cast::<u8>();
                                    let len29 = vec29.len();
                                    ::core::mem::forget(vec29);
                                    *ptr14.add(20).cast::<usize>() = len29;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr29.cast_mut();
                                }
                                V32::InvalidStorageLocation(e) => {
                                    *ptr14.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec30 = (e.into_bytes()).into_boxed_slice();
                                    let ptr30 = vec30.as_ptr().cast::<u8>();
                                    let len30 = vec30.len();
                                    ::core::mem::forget(vec30);
                                    *ptr14.add(20).cast::<usize>() = len30;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr30.cast_mut();
                                }
                                V32::StorageAccessDenied(e) => {
                                    *ptr14.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec31 = (e.into_bytes()).into_boxed_slice();
                                    let ptr31 = vec31.as_ptr().cast::<u8>();
                                    let len31 = vec31.len();
                                    ::core::mem::forget(vec31);
                                    *ptr14.add(20).cast::<usize>() = len31;
                                    *ptr14.add(16).cast::<*mut u8>() = ptr31.cast_mut();
                                }
                            }
                        }
                    };
                    ptr14
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_create_lexicon<T: Guest>(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_synthesize_long_form_cabi<T: Guest>(
                    arg0: *mut u8,
                    arg1: usize,
                    arg2: i32,
                    arg3: *mut u8,
                    arg4: usize,
                    arg5: i32,
                    arg6: *mut u8,
                    arg7: usize,
                ) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let len0 = arg1;
                    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
                    let len1 = arg4;
                    let bytes1 = _rt::Vec::from_raw_parts(arg3.cast(), len1, len1);
                    let result3 = T::synthesize_long_form(
                        _rt::string_lift(bytes0),
                        VoiceBorrow::lift(arg2 as u32 as usize),
                        _rt::string_lift(bytes1),
                        match arg5 {
                            0 => None,
                            1 => {
                                let e = {
                                    let len2 = arg7;
                                    _rt::Vec::from_raw_parts(arg6.cast(), len2, len2)
                                };
                                Some(e)
                            }
                            _ => _rt::invalid_enum_discriminant(),
                        },
                    );
                    let ptr4 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result3 {
                        Ok(e) => {
                            *ptr4.add(0).cast::<u8>() = (0i32) as u8;
                            *ptr4.add(8).cast::<i32>() = (e).take_handle() as i32;
                        }
                        Err(e) => {
                            *ptr4.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V22;
                            match e {
                                V22::InvalidText(e) => {
                                    *ptr4.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr4.add(20).cast::<usize>() = len5;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V22::TextTooLong(e) => {
                                    *ptr4.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InvalidSsml(e) => {
                                    *ptr4.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr4.add(20).cast::<usize>() = len6;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V22::UnsupportedLanguage(e) => {
                                    *ptr4.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr4.add(20).cast::<usize>() = len7;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V22::VoiceNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr4.add(20).cast::<usize>() = len8;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V22::ModelNotFound(e) => {
                                    *ptr4.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr4.add(20).cast::<usize>() = len9;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V22::VoiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr4.add(20).cast::<usize>() = len10;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V22::Unauthorized(e) => {
                                    *ptr4.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr4.add(20).cast::<usize>() = len11;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V22::AccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr4.add(20).cast::<usize>() = len12;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V22::QuotaExceeded(e) => {
                                    *ptr4.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used13,
                                        limit: limit13,
                                        reset_time: reset_time13,
                                        unit: unit13,
                                    } = e;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(used13);
                                    *ptr4.add(20).cast::<i32>() = _rt::as_i32(limit13);
                                    *ptr4.add(24).cast::<i64>() = _rt::as_i64(reset_time13);
                                    *ptr4.add(32).cast::<u8>() = (unit13.clone() as i32) as u8;
                                }
                                V22::RateLimited(e) => {
                                    *ptr4.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr4.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V22::InsufficientCredits => {
                                    *ptr4.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V22::SynthesisFailed(e) => {
                                    *ptr4.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr4.add(20).cast::<usize>() = len14;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V22::UnsupportedOperation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr4.add(20).cast::<usize>() = len15;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V22::InvalidConfiguration(e) => {
                                    *ptr4.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr4.add(20).cast::<usize>() = len16;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V22::ServiceUnavailable(e) => {
                                    *ptr4.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr4.add(20).cast::<usize>() = len17;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V22::NetworkError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr4.add(20).cast::<usize>() = len18;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V22::InternalError(e) => {
                                    *ptr4.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr4.add(20).cast::<usize>() = len19;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V22::InvalidStorageLocation(e) => {
                                    *ptr4.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr4.add(20).cast::<usize>() = len20;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V22::StorageAccessDenied(e) => {
                                    *ptr4.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr4.add(20).cast::<usize>() = len21;
                                    *ptr4.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                            }
                        }
                    };
                    ptr4
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_synthesize_long_form<T: Guest>(
                    arg0: *mut u8,
                ) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_status_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> i32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_status(
                        LongFormOperationBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    result0.clone() as i32
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_progress_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> f32 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_progress(
                        LongFormOperationBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    _rt::as_f32(result0)
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_cancel_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::cancel(
                        LongFormOperationBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(_) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V19;
                            match e {
                                V19::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec2 = (e.into_bytes()).into_boxed_slice();
                                    let ptr2 = vec2.as_ptr().cast::<u8>();
                                    let len2 = vec2.len();
                                    ::core::mem::forget(vec2);
                                    *ptr1.add(20).cast::<usize>() = len2;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr2.cast_mut();
                                }
                                V19::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec3 = (e.into_bytes()).into_boxed_slice();
                                    let ptr3 = vec3.as_ptr().cast::<u8>();
                                    let len3 = vec3.len();
                                    ::core::mem::forget(vec3);
                                    *ptr1.add(20).cast::<usize>() = len3;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr3.cast_mut();
                                }
                                V19::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec4 = (e.into_bytes()).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(20).cast::<usize>() = len4;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                V19::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec5 = (e.into_bytes()).into_boxed_slice();
                                    let ptr5 = vec5.as_ptr().cast::<u8>();
                                    let len5 = vec5.len();
                                    ::core::mem::forget(vec5);
                                    *ptr1.add(20).cast::<usize>() = len5;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr5.cast_mut();
                                }
                                V19::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec6 = (e.into_bytes()).into_boxed_slice();
                                    let ptr6 = vec6.as_ptr().cast::<u8>();
                                    let len6 = vec6.len();
                                    ::core::mem::forget(vec6);
                                    *ptr1.add(20).cast::<usize>() = len6;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr6.cast_mut();
                                }
                                V19::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(20).cast::<usize>() = len7;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                V19::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V19::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V19::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used10,
                                        limit: limit10,
                                        reset_time: reset_time10,
                                        unit: unit10,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used10);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit10);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time10);
                                    *ptr1.add(32).cast::<u8>() = (unit10.clone() as i32) as u8;
                                }
                                V19::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V19::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V19::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V19::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V19::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V19::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V19::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V19::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec16 = (e.into_bytes()).into_boxed_slice();
                                    let ptr16 = vec16.as_ptr().cast::<u8>();
                                    let len16 = vec16.len();
                                    ::core::mem::forget(vec16);
                                    *ptr1.add(20).cast::<usize>() = len16;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr16.cast_mut();
                                }
                                V19::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V19::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_long_form_operation_cancel<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {}
                        _ => {
                            let l1 = i32::from(*arg0.add(8).cast::<u8>());
                            match l1 {
                                0 => {
                                    let l2 = *arg0.add(16).cast::<*mut u8>();
                                    let l3 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l2, l3, 1);
                                }
                                1 => {}
                                2 => {
                                    let l4 = *arg0.add(16).cast::<*mut u8>();
                                    let l5 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l4, l5, 1);
                                }
                                3 => {
                                    let l6 = *arg0.add(16).cast::<*mut u8>();
                                    let l7 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l6, l7, 1);
                                }
                                4 => {
                                    let l8 = *arg0.add(16).cast::<*mut u8>();
                                    let l9 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l8, l9, 1);
                                }
                                5 => {
                                    let l10 = *arg0.add(16).cast::<*mut u8>();
                                    let l11 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                                6 => {
                                    let l12 = *arg0.add(16).cast::<*mut u8>();
                                    let l13 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l12, l13, 1);
                                }
                                7 => {
                                    let l14 = *arg0.add(16).cast::<*mut u8>();
                                    let l15 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l14, l15, 1);
                                }
                                8 => {
                                    let l16 = *arg0.add(16).cast::<*mut u8>();
                                    let l17 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l16, l17, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l18 = *arg0.add(16).cast::<*mut u8>();
                                    let l19 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l18, l19, 1);
                                }
                                13 => {
                                    let l20 = *arg0.add(16).cast::<*mut u8>();
                                    let l21 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l20, l21, 1);
                                }
                                14 => {
                                    let l22 = *arg0.add(16).cast::<*mut u8>();
                                    let l23 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l22, l23, 1);
                                }
                                15 => {
                                    let l24 = *arg0.add(16).cast::<*mut u8>();
                                    let l25 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l24, l25, 1);
                                }
                                16 => {
                                    let l26 = *arg0.add(16).cast::<*mut u8>();
                                    let l27 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l26, l27, 1);
                                }
                                17 => {
                                    let l28 = *arg0.add(16).cast::<*mut u8>();
                                    let l29 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l28, l29, 1);
                                }
                                18 => {
                                    let l30 = *arg0.add(16).cast::<*mut u8>();
                                    let l31 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l30, l31, 1);
                                }
                                _ => {
                                    let l32 = *arg0.add(16).cast::<*mut u8>();
                                    let l33 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l32, l33, 1);
                                }
                            }
                        }
                    }
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn _export_method_long_form_operation_get_result_cabi<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) -> *mut u8 {
                    #[cfg(target_arch = "wasm32")] _rt::run_ctors_once();
                    let result0 = T::get_result(
                        LongFormOperationBorrow::lift(arg0 as u32 as usize).get(),
                    );
                    let ptr1 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
                    match result0 {
                        Ok(e) => {
                            *ptr1.add(0).cast::<u8>() = (0i32) as u8;
                            let LongFormResult {
                                output_location: output_location2,
                                total_duration: total_duration2,
                                chapter_durations: chapter_durations2,
                                metadata: metadata2,
                            } = e;
                            let vec3 = (output_location2.into_bytes())
                                .into_boxed_slice();
                            let ptr3 = vec3.as_ptr().cast::<u8>();
                            let len3 = vec3.len();
                            ::core::mem::forget(vec3);
                            *ptr1.add(12).cast::<usize>() = len3;
                            *ptr1.add(8).cast::<*mut u8>() = ptr3.cast_mut();
                            *ptr1.add(16).cast::<f32>() = _rt::as_f32(total_duration2);
                            match chapter_durations2 {
                                Some(e) => {
                                    *ptr1.add(20).cast::<u8>() = (1i32) as u8;
                                    let vec4 = (e).into_boxed_slice();
                                    let ptr4 = vec4.as_ptr().cast::<u8>();
                                    let len4 = vec4.len();
                                    ::core::mem::forget(vec4);
                                    *ptr1.add(28).cast::<usize>() = len4;
                                    *ptr1.add(24).cast::<*mut u8>() = ptr4.cast_mut();
                                }
                                None => {
                                    *ptr1.add(20).cast::<u8>() = (0i32) as u8;
                                }
                            };
                            let super::super::super::super::exports::golem::tts::types::SynthesisMetadata {
                                duration_seconds: duration_seconds5,
                                character_count: character_count5,
                                word_count: word_count5,
                                audio_size_bytes: audio_size_bytes5,
                                request_id: request_id5,
                                provider_info: provider_info5,
                            } = metadata2;
                            *ptr1.add(32).cast::<f32>() = _rt::as_f32(duration_seconds5);
                            *ptr1.add(36).cast::<i32>() = _rt::as_i32(character_count5);
                            *ptr1.add(40).cast::<i32>() = _rt::as_i32(word_count5);
                            *ptr1.add(44).cast::<i32>() = _rt::as_i32(audio_size_bytes5);
                            let vec6 = (request_id5.into_bytes()).into_boxed_slice();
                            let ptr6 = vec6.as_ptr().cast::<u8>();
                            let len6 = vec6.len();
                            ::core::mem::forget(vec6);
                            *ptr1.add(52).cast::<usize>() = len6;
                            *ptr1.add(48).cast::<*mut u8>() = ptr6.cast_mut();
                            match provider_info5 {
                                Some(e) => {
                                    *ptr1.add(56).cast::<u8>() = (1i32) as u8;
                                    let vec7 = (e.into_bytes()).into_boxed_slice();
                                    let ptr7 = vec7.as_ptr().cast::<u8>();
                                    let len7 = vec7.len();
                                    ::core::mem::forget(vec7);
                                    *ptr1.add(64).cast::<usize>() = len7;
                                    *ptr1.add(60).cast::<*mut u8>() = ptr7.cast_mut();
                                }
                                None => {
                                    *ptr1.add(56).cast::<u8>() = (0i32) as u8;
                                }
                            };
                        }
                        Err(e) => {
                            *ptr1.add(0).cast::<u8>() = (1i32) as u8;
                            use super::super::super::super::exports::golem::tts::types::TtsError as V25;
                            match e {
                                V25::InvalidText(e) => {
                                    *ptr1.add(8).cast::<u8>() = (0i32) as u8;
                                    let vec8 = (e.into_bytes()).into_boxed_slice();
                                    let ptr8 = vec8.as_ptr().cast::<u8>();
                                    let len8 = vec8.len();
                                    ::core::mem::forget(vec8);
                                    *ptr1.add(20).cast::<usize>() = len8;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr8.cast_mut();
                                }
                                V25::TextTooLong(e) => {
                                    *ptr1.add(8).cast::<u8>() = (1i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V25::InvalidSsml(e) => {
                                    *ptr1.add(8).cast::<u8>() = (2i32) as u8;
                                    let vec9 = (e.into_bytes()).into_boxed_slice();
                                    let ptr9 = vec9.as_ptr().cast::<u8>();
                                    let len9 = vec9.len();
                                    ::core::mem::forget(vec9);
                                    *ptr1.add(20).cast::<usize>() = len9;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr9.cast_mut();
                                }
                                V25::UnsupportedLanguage(e) => {
                                    *ptr1.add(8).cast::<u8>() = (3i32) as u8;
                                    let vec10 = (e.into_bytes()).into_boxed_slice();
                                    let ptr10 = vec10.as_ptr().cast::<u8>();
                                    let len10 = vec10.len();
                                    ::core::mem::forget(vec10);
                                    *ptr1.add(20).cast::<usize>() = len10;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr10.cast_mut();
                                }
                                V25::VoiceNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (4i32) as u8;
                                    let vec11 = (e.into_bytes()).into_boxed_slice();
                                    let ptr11 = vec11.as_ptr().cast::<u8>();
                                    let len11 = vec11.len();
                                    ::core::mem::forget(vec11);
                                    *ptr1.add(20).cast::<usize>() = len11;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr11.cast_mut();
                                }
                                V25::ModelNotFound(e) => {
                                    *ptr1.add(8).cast::<u8>() = (5i32) as u8;
                                    let vec12 = (e.into_bytes()).into_boxed_slice();
                                    let ptr12 = vec12.as_ptr().cast::<u8>();
                                    let len12 = vec12.len();
                                    ::core::mem::forget(vec12);
                                    *ptr1.add(20).cast::<usize>() = len12;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr12.cast_mut();
                                }
                                V25::VoiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (6i32) as u8;
                                    let vec13 = (e.into_bytes()).into_boxed_slice();
                                    let ptr13 = vec13.as_ptr().cast::<u8>();
                                    let len13 = vec13.len();
                                    ::core::mem::forget(vec13);
                                    *ptr1.add(20).cast::<usize>() = len13;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr13.cast_mut();
                                }
                                V25::Unauthorized(e) => {
                                    *ptr1.add(8).cast::<u8>() = (7i32) as u8;
                                    let vec14 = (e.into_bytes()).into_boxed_slice();
                                    let ptr14 = vec14.as_ptr().cast::<u8>();
                                    let len14 = vec14.len();
                                    ::core::mem::forget(vec14);
                                    *ptr1.add(20).cast::<usize>() = len14;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr14.cast_mut();
                                }
                                V25::AccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (8i32) as u8;
                                    let vec15 = (e.into_bytes()).into_boxed_slice();
                                    let ptr15 = vec15.as_ptr().cast::<u8>();
                                    let len15 = vec15.len();
                                    ::core::mem::forget(vec15);
                                    *ptr1.add(20).cast::<usize>() = len15;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr15.cast_mut();
                                }
                                V25::QuotaExceeded(e) => {
                                    *ptr1.add(8).cast::<u8>() = (9i32) as u8;
                                    let super::super::super::super::exports::golem::tts::types::QuotaInfo {
                                        used: used16,
                                        limit: limit16,
                                        reset_time: reset_time16,
                                        unit: unit16,
                                    } = e;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(used16);
                                    *ptr1.add(20).cast::<i32>() = _rt::as_i32(limit16);
                                    *ptr1.add(24).cast::<i64>() = _rt::as_i64(reset_time16);
                                    *ptr1.add(32).cast::<u8>() = (unit16.clone() as i32) as u8;
                                }
                                V25::RateLimited(e) => {
                                    *ptr1.add(8).cast::<u8>() = (10i32) as u8;
                                    *ptr1.add(16).cast::<i32>() = _rt::as_i32(e);
                                }
                                V25::InsufficientCredits => {
                                    *ptr1.add(8).cast::<u8>() = (11i32) as u8;
                                }
                                V25::SynthesisFailed(e) => {
                                    *ptr1.add(8).cast::<u8>() = (12i32) as u8;
                                    let vec17 = (e.into_bytes()).into_boxed_slice();
                                    let ptr17 = vec17.as_ptr().cast::<u8>();
                                    let len17 = vec17.len();
                                    ::core::mem::forget(vec17);
                                    *ptr1.add(20).cast::<usize>() = len17;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr17.cast_mut();
                                }
                                V25::UnsupportedOperation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (13i32) as u8;
                                    let vec18 = (e.into_bytes()).into_boxed_slice();
                                    let ptr18 = vec18.as_ptr().cast::<u8>();
                                    let len18 = vec18.len();
                                    ::core::mem::forget(vec18);
                                    *ptr1.add(20).cast::<usize>() = len18;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr18.cast_mut();
                                }
                                V25::InvalidConfiguration(e) => {
                                    *ptr1.add(8).cast::<u8>() = (14i32) as u8;
                                    let vec19 = (e.into_bytes()).into_boxed_slice();
                                    let ptr19 = vec19.as_ptr().cast::<u8>();
                                    let len19 = vec19.len();
                                    ::core::mem::forget(vec19);
                                    *ptr1.add(20).cast::<usize>() = len19;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr19.cast_mut();
                                }
                                V25::ServiceUnavailable(e) => {
                                    *ptr1.add(8).cast::<u8>() = (15i32) as u8;
                                    let vec20 = (e.into_bytes()).into_boxed_slice();
                                    let ptr20 = vec20.as_ptr().cast::<u8>();
                                    let len20 = vec20.len();
                                    ::core::mem::forget(vec20);
                                    *ptr1.add(20).cast::<usize>() = len20;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr20.cast_mut();
                                }
                                V25::NetworkError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (16i32) as u8;
                                    let vec21 = (e.into_bytes()).into_boxed_slice();
                                    let ptr21 = vec21.as_ptr().cast::<u8>();
                                    let len21 = vec21.len();
                                    ::core::mem::forget(vec21);
                                    *ptr1.add(20).cast::<usize>() = len21;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr21.cast_mut();
                                }
                                V25::InternalError(e) => {
                                    *ptr1.add(8).cast::<u8>() = (17i32) as u8;
                                    let vec22 = (e.into_bytes()).into_boxed_slice();
                                    let ptr22 = vec22.as_ptr().cast::<u8>();
                                    let len22 = vec22.len();
                                    ::core::mem::forget(vec22);
                                    *ptr1.add(20).cast::<usize>() = len22;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr22.cast_mut();
                                }
                                V25::InvalidStorageLocation(e) => {
                                    *ptr1.add(8).cast::<u8>() = (18i32) as u8;
                                    let vec23 = (e.into_bytes()).into_boxed_slice();
                                    let ptr23 = vec23.as_ptr().cast::<u8>();
                                    let len23 = vec23.len();
                                    ::core::mem::forget(vec23);
                                    *ptr1.add(20).cast::<usize>() = len23;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr23.cast_mut();
                                }
                                V25::StorageAccessDenied(e) => {
                                    *ptr1.add(8).cast::<u8>() = (19i32) as u8;
                                    let vec24 = (e.into_bytes()).into_boxed_slice();
                                    let ptr24 = vec24.as_ptr().cast::<u8>();
                                    let len24 = vec24.len();
                                    ::core::mem::forget(vec24);
                                    *ptr1.add(20).cast::<usize>() = len24;
                                    *ptr1.add(16).cast::<*mut u8>() = ptr24.cast_mut();
                                }
                            }
                        }
                    };
                    ptr1
                }
                #[doc(hidden)]
                #[allow(non_snake_case)]
                pub unsafe fn __post_return_method_long_form_operation_get_result<
                    T: GuestLongFormOperation,
                >(arg0: *mut u8) {
                    let l0 = i32::from(*arg0.add(0).cast::<u8>());
                    match l0 {
                        0 => {
                            let l1 = *arg0.add(8).cast::<*mut u8>();
                            let l2 = *arg0.add(12).cast::<usize>();
                            _rt::cabi_dealloc(l1, l2, 1);
                            let l3 = i32::from(*arg0.add(20).cast::<u8>());
                            match l3 {
                                0 => {}
                                _ => {
                                    let l4 = *arg0.add(24).cast::<*mut u8>();
                                    let l5 = *arg0.add(28).cast::<usize>();
                                    let base6 = l4;
                                    let len6 = l5;
                                    _rt::cabi_dealloc(base6, len6 * 4, 4);
                                }
                            }
                            let l7 = *arg0.add(48).cast::<*mut u8>();
                            let l8 = *arg0.add(52).cast::<usize>();
                            _rt::cabi_dealloc(l7, l8, 1);
                            let l9 = i32::from(*arg0.add(56).cast::<u8>());
                            match l9 {
                                0 => {}
                                _ => {
                                    let l10 = *arg0.add(60).cast::<*mut u8>();
                                    let l11 = *arg0.add(64).cast::<usize>();
                                    _rt::cabi_dealloc(l10, l11, 1);
                                }
                            }
                        }
                        _ => {
                            let l12 = i32::from(*arg0.add(8).cast::<u8>());
                            match l12 {
                                0 => {
                                    let l13 = *arg0.add(16).cast::<*mut u8>();
                                    let l14 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l13, l14, 1);
                                }
                                1 => {}
                                2 => {
                                    let l15 = *arg0.add(16).cast::<*mut u8>();
                                    let l16 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l15, l16, 1);
                                }
                                3 => {
                                    let l17 = *arg0.add(16).cast::<*mut u8>();
                                    let l18 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l17, l18, 1);
                                }
                                4 => {
                                    let l19 = *arg0.add(16).cast::<*mut u8>();
                                    let l20 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l19, l20, 1);
                                }
                                5 => {
                                    let l21 = *arg0.add(16).cast::<*mut u8>();
                                    let l22 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l21, l22, 1);
                                }
                                6 => {
                                    let l23 = *arg0.add(16).cast::<*mut u8>();
                                    let l24 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l23, l24, 1);
                                }
                                7 => {
                                    let l25 = *arg0.add(16).cast::<*mut u8>();
                                    let l26 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l25, l26, 1);
                                }
                                8 => {
                                    let l27 = *arg0.add(16).cast::<*mut u8>();
                                    let l28 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l27, l28, 1);
                                }
                                9 => {}
                                10 => {}
                                11 => {}
                                12 => {
                                    let l29 = *arg0.add(16).cast::<*mut u8>();
                                    let l30 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l29, l30, 1);
                                }
                                13 => {
                                    let l31 = *arg0.add(16).cast::<*mut u8>();
                                    let l32 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l31, l32, 1);
                                }
                                14 => {
                                    let l33 = *arg0.add(16).cast::<*mut u8>();
                                    let l34 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l33, l34, 1);
                                }
                                15 => {
                                    let l35 = *arg0.add(16).cast::<*mut u8>();
                                    let l36 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l35, l36, 1);
                                }
                                16 => {
                                    let l37 = *arg0.add(16).cast::<*mut u8>();
                                    let l38 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l37, l38, 1);
                                }
                                17 => {
                                    let l39 = *arg0.add(16).cast::<*mut u8>();
                                    let l40 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l39, l40, 1);
                                }
                                18 => {
                                    let l41 = *arg0.add(16).cast::<*mut u8>();
                                    let l42 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l41, l42, 1);
                                }
                                _ => {
                                    let l43 = *arg0.add(16).cast::<*mut u8>();
                                    let l44 = *arg0.add(20).cast::<usize>();
                                    _rt::cabi_dealloc(l43, l44, 1);
                                }
                            }
                        }
                    }
                }
                pub trait Guest {
                    type PronunciationLexicon: GuestPronunciationLexicon;
                    type LongFormOperation: GuestLongFormOperation;
                    /// Voice cloning and creation (removed async)
                    fn create_voice_clone(
                        name: _rt::String,
                        audio_samples: _rt::Vec<AudioSample>,
                        description: Option<_rt::String>,
                    ) -> Result<Voice, TtsError>;
                    /// Design synthetic voice (removed async)
                    fn design_voice(
                        name: _rt::String,
                        characteristics: VoiceDesignParams,
                    ) -> Result<Voice, TtsError>;
                    /// Voice-to-voice conversion (removed async)
                    fn convert_voice(
                        input_audio: _rt::Vec<u8>,
                        target_voice: VoiceBorrow<'_>,
                        preserve_timing: Option<bool>,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                    /// Generate sound effects from text description (removed async)
                    fn generate_sound_effect(
                        description: _rt::String,
                        duration_seconds: Option<f32>,
                        style_influence: Option<f32>,
                    ) -> Result<_rt::Vec<u8>, TtsError>;
                    /// Create custom pronunciation lexicon
                    fn create_lexicon(
                        name: _rt::String,
                        language: LanguageCode,
                        entries: Option<_rt::Vec<PronunciationEntry>>,
                    ) -> Result<PronunciationLexicon, TtsError>;
                    /// Long-form content synthesis with optimization (removed async)
                    fn synthesize_long_form(
                        content: _rt::String,
                        voice: VoiceBorrow<'_>,
                        output_location: _rt::String,
                        chapter_breaks: Option<_rt::Vec<u32>>,
                    ) -> Result<LongFormOperation, TtsError>;
                }
                pub trait GuestPronunciationLexicon: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]pronunciation-lexicon"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]pronunciation-lexicon"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn get_name(&self) -> _rt::String;
                    fn get_language(&self) -> LanguageCode;
                    fn get_entry_count(&self) -> u32;
                    /// Add pronunciation rule
                    fn add_entry(
                        &self,
                        word: _rt::String,
                        pronunciation: _rt::String,
                    ) -> Result<(), TtsError>;
                    /// Remove pronunciation rule
                    fn remove_entry(&self, word: _rt::String) -> Result<(), TtsError>;
                    /// Export lexicon content
                    fn export_content(&self) -> Result<_rt::String, TtsError>;
                }
                pub trait GuestLongFormOperation: 'static {
                    #[doc(hidden)]
                    unsafe fn _resource_new(val: *mut u8) -> u32
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = val;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-new]long-form-operation"]
                                fn new(_: *mut u8) -> u32;
                            }
                            new(val)
                        }
                    }
                    #[doc(hidden)]
                    fn _resource_rep(handle: u32) -> *mut u8
                    where
                        Self: Sized,
                    {
                        #[cfg(not(target_arch = "wasm32"))]
                        {
                            let _ = handle;
                            unreachable!();
                        }
                        #[cfg(target_arch = "wasm32")]
                        {
                            #[link(
                                wasm_import_module = "[export]golem:tts/advanced@1.0.0"
                            )]
                            extern "C" {
                                #[link_name = "[resource-rep]long-form-operation"]
                                fn rep(_: u32) -> *mut u8;
                            }
                            unsafe { rep(handle) }
                        }
                    }
                    fn get_status(&self) -> OperationStatus;
                    fn get_progress(&self) -> f32;
                    fn cancel(&self) -> Result<(), TtsError>;
                    fn get_result(&self) -> Result<LongFormResult, TtsError>;
                }
                #[doc(hidden)]
                macro_rules! __export_golem_tts_advanced_1_0_0_cabi {
                    ($ty:ident with_types_in $($path_to_types:tt)*) => {
                        const _ : () = { #[export_name =
                        "golem:tts/advanced@1.0.0#create-voice-clone"] unsafe extern "C"
                        fn export_create_voice_clone(arg0 : * mut u8, arg1 : usize, arg2
                        : * mut u8, arg3 : usize, arg4 : i32, arg5 : * mut u8, arg6 :
                        usize,) -> * mut u8 { $($path_to_types)*::
                        _export_create_voice_clone_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#create-voice-clone"] unsafe
                        extern "C" fn _post_return_create_voice_clone(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_create_voice_clone::<$ty >
                        (arg0) } #[export_name = "golem:tts/advanced@1.0.0#design-voice"]
                        unsafe extern "C" fn export_design_voice(arg0 : * mut u8, arg1 :
                        usize, arg2 : i32, arg3 : i32, arg4 : * mut u8, arg5 : usize,
                        arg6 : * mut u8, arg7 : usize, arg8 : i32, arg9 : * mut u8, arg10
                        : usize,) -> * mut u8 { $($path_to_types)*::
                        _export_design_voice_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4,
                        arg5, arg6, arg7, arg8, arg9, arg10) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#design-voice"] unsafe extern
                        "C" fn _post_return_design_voice(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_design_voice::<$ty > (arg0) }
                        #[export_name = "golem:tts/advanced@1.0.0#convert-voice"] unsafe
                        extern "C" fn export_convert_voice(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32, arg3 : i32, arg4 : i32,) -> * mut u8 {
                        $($path_to_types)*:: _export_convert_voice_cabi::<$ty > (arg0,
                        arg1, arg2, arg3, arg4) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#convert-voice"] unsafe extern
                        "C" fn _post_return_convert_voice(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_convert_voice::<$ty > (arg0) }
                        #[export_name = "golem:tts/advanced@1.0.0#generate-sound-effect"]
                        unsafe extern "C" fn export_generate_sound_effect(arg0 : * mut
                        u8, arg1 : usize, arg2 : i32, arg3 : f32, arg4 : i32, arg5 :
                        f32,) -> * mut u8 { $($path_to_types)*::
                        _export_generate_sound_effect_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#generate-sound-effect"]
                        unsafe extern "C" fn _post_return_generate_sound_effect(arg0 : *
                        mut u8,) { $($path_to_types)*::
                        __post_return_generate_sound_effect::<$ty > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-name"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_name(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_name_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-name"]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_get_name(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_get_name::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-language"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_language(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_language_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-language"]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_get_language(arg0 : *
                        mut u8,) { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_get_language::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.get-entry-count"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_get_entry_count(arg0 : * mut
                        u8,) -> i32 { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_get_entry_count_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.add-entry"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_add_entry(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize, arg3 : * mut u8, arg4 : usize,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_add_entry_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0, arg1,
                        arg2, arg3, arg4) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.add-entry"]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_add_entry(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_add_entry::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.remove-entry"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_remove_entry(arg0 : * mut u8,
                        arg1 : * mut u8, arg2 : usize,) -> * mut u8 {
                        $($path_to_types)*::
                        _export_method_pronunciation_lexicon_remove_entry_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0, arg1,
                        arg2) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.remove-entry"]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_remove_entry(arg0 : *
                        mut u8,) { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_remove_entry::<<$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.export-content"]
                        unsafe extern "C" fn
                        export_method_pronunciation_lexicon_export_content(arg0 : * mut
                        u8,) -> * mut u8 { $($path_to_types)*::
                        _export_method_pronunciation_lexicon_export_content_cabi::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]pronunciation-lexicon.export-content"]
                        unsafe extern "C" fn
                        _post_return_method_pronunciation_lexicon_export_content(arg0 : *
                        mut u8,) { $($path_to_types)*::
                        __post_return_method_pronunciation_lexicon_export_content::<<$ty
                        as $($path_to_types)*:: Guest >::PronunciationLexicon > (arg0) }
                        #[export_name = "golem:tts/advanced@1.0.0#create-lexicon"] unsafe
                        extern "C" fn export_create_lexicon(arg0 : * mut u8, arg1 :
                        usize, arg2 : * mut u8, arg3 : usize, arg4 : i32, arg5 : * mut
                        u8, arg6 : usize,) -> * mut u8 { $($path_to_types)*::
                        _export_create_lexicon_cabi::<$ty > (arg0, arg1, arg2, arg3,
                        arg4, arg5, arg6) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#create-lexicon"] unsafe
                        extern "C" fn _post_return_create_lexicon(arg0 : * mut u8,) {
                        $($path_to_types)*:: __post_return_create_lexicon::<$ty > (arg0)
                        } #[export_name =
                        "golem:tts/advanced@1.0.0#synthesize-long-form"] unsafe extern
                        "C" fn export_synthesize_long_form(arg0 : * mut u8, arg1 : usize,
                        arg2 : i32, arg3 : * mut u8, arg4 : usize, arg5 : i32, arg6 : *
                        mut u8, arg7 : usize,) -> * mut u8 { $($path_to_types)*::
                        _export_synthesize_long_form_cabi::<$ty > (arg0, arg1, arg2,
                        arg3, arg4, arg5, arg6, arg7) } #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#synthesize-long-form"] unsafe
                        extern "C" fn _post_return_synthesize_long_form(arg0 : * mut u8,)
                        { $($path_to_types)*:: __post_return_synthesize_long_form::<$ty >
                        (arg0) } #[export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-status"]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_status(arg0 : * mut u8,) ->
                        i32 { $($path_to_types)*::
                        _export_method_long_form_operation_get_status_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-progress"]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_progress(arg0 : * mut u8,)
                        -> f32 { $($path_to_types)*::
                        _export_method_long_form_operation_get_progress_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.cancel"]
                        unsafe extern "C" fn
                        export_method_long_form_operation_cancel(arg0 : * mut u8,) -> *
                        mut u8 { $($path_to_types)*::
                        _export_method_long_form_operation_cancel_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]long-form-operation.cancel"]
                        unsafe extern "C" fn
                        _post_return_method_long_form_operation_cancel(arg0 : * mut u8,)
                        { $($path_to_types)*::
                        __post_return_method_long_form_operation_cancel::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) }
                        #[export_name =
                        "golem:tts/advanced@1.0.0#[method]long-form-operation.get-result"]
                        unsafe extern "C" fn
                        export_method_long_form_operation_get_result(arg0 : * mut u8,) ->
                        * mut u8 { $($path_to_types)*::
                        _export_method_long_form_operation_get_result_cabi::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) }
                        #[export_name =
                        "cabi_post_golem:tts/advanced@1.0.0#[method]long-form-operation.get-result"]
                        unsafe extern "C" fn
                        _post_return_method_long_form_operation_get_result(arg0 : * mut
                        u8,) { $($path_to_types)*::
                        __post_return_method_long_form_operation_get_result::<<$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (arg0) } const
                        _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/advanced@1.0.0#[dtor]pronunciation-lexicon"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: PronunciationLexicon::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::PronunciationLexicon > (rep) } };
                        const _ : () = { #[doc(hidden)] #[export_name =
                        "golem:tts/advanced@1.0.0#[dtor]long-form-operation"]
                        #[allow(non_snake_case)] unsafe extern "C" fn dtor(rep : * mut
                        u8) { $($path_to_types)*:: LongFormOperation::dtor::< <$ty as
                        $($path_to_types)*:: Guest >::LongFormOperation > (rep) } }; };
                    };
                }
                #[doc(hidden)]
                pub(crate) use __export_golem_tts_advanced_1_0_0_cabi;
                #[repr(align(8))]
                struct _RetArea([::core::mem::MaybeUninit<u8>; 72]);
                static mut _RET_AREA: _RetArea = _RetArea(
                    [::core::mem::MaybeUninit::uninit(); 72],
                );
            }
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    use core::fmt;
    use core::marker;
    use core::sync::atomic::{AtomicU32, Ordering::Relaxed};
    /// A type which represents a component model resource, either imported or
    /// exported into this component.
    ///
    /// This is a low-level wrapper which handles the lifetime of the resource
    /// (namely this has a destructor). The `T` provided defines the component model
    /// intrinsics that this wrapper uses.
    ///
    /// One of the chief purposes of this type is to provide `Deref` implementations
    /// to access the underlying data when it is owned.
    ///
    /// This type is primarily used in generated code for exported and imported
    /// resources.
    #[repr(transparent)]
    pub struct Resource<T: WasmResource> {
        handle: AtomicU32,
        _marker: marker::PhantomData<T>,
    }
    /// A trait which all wasm resources implement, namely providing the ability to
    /// drop a resource.
    ///
    /// This generally is implemented by generated code, not user-facing code.
    #[allow(clippy::missing_safety_doc)]
    pub unsafe trait WasmResource {
        /// Invokes the `[resource-drop]...` intrinsic.
        unsafe fn drop(handle: u32);
    }
    impl<T: WasmResource> Resource<T> {
        #[doc(hidden)]
        pub unsafe fn from_handle(handle: u32) -> Self {
            debug_assert!(handle != u32::MAX);
            Self {
                handle: AtomicU32::new(handle),
                _marker: marker::PhantomData,
            }
        }
        /// Takes ownership of the handle owned by `resource`.
        ///
        /// Note that this ideally would be `into_handle` taking `Resource<T>` by
        /// ownership. The code generator does not enable that in all situations,
        /// unfortunately, so this is provided instead.
        ///
        /// Also note that `take_handle` is in theory only ever called on values
        /// owned by a generated function. For example a generated function might
        /// take `Resource<T>` as an argument but then call `take_handle` on a
        /// reference to that argument. In that sense the dynamic nature of
        /// `take_handle` should only be exposed internally to generated code, not
        /// to user code.
        #[doc(hidden)]
        pub fn take_handle(resource: &Resource<T>) -> u32 {
            resource.handle.swap(u32::MAX, Relaxed)
        }
        #[doc(hidden)]
        pub fn handle(resource: &Resource<T>) -> u32 {
            resource.handle.load(Relaxed)
        }
    }
    impl<T: WasmResource> fmt::Debug for Resource<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Resource").field("handle", &self.handle).finish()
        }
    }
    impl<T: WasmResource> Drop for Resource<T> {
        fn drop(&mut self) {
            unsafe {
                match self.handle.load(Relaxed) {
                    u32::MAX => {}
                    other => T::drop(other),
                }
            }
        }
    }
    pub use alloc_crate::boxed::Box;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub use alloc_crate::alloc;
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }
    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }
    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }
    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub fn as_i64<T: AsI64>(t: T) -> i64 {
        t.as_i64()
    }
    pub trait AsI64 {
        fn as_i64(self) -> i64;
    }
    impl<'a, T: Copy + AsI64> AsI64 for &'a T {
        fn as_i64(self) -> i64 {
            (*self).as_i64()
        }
    }
    impl AsI64 for i64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    impl AsI64 for u64 {
        #[inline]
        fn as_i64(self) -> i64 {
            self as i64
        }
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub fn as_f32<T: AsF32>(t: T) -> f32 {
        t.as_f32()
    }
    pub trait AsF32 {
        fn as_f32(self) -> f32;
    }
    impl<'a, T: Copy + AsF32> AsF32 for &'a T {
        fn as_f32(self) -> f32 {
            (*self).as_f32()
        }
    }
    impl AsF32 for f32 {
        #[inline]
        fn as_f32(self) -> f32 {
            self as f32
        }
    }
    extern crate alloc as alloc_crate;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_tts_library_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*::
        exports::golem::tts::types::__export_golem_tts_types_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::types);
        $($path_to_types_root)*::
        exports::golem::tts::voices::__export_golem_tts_voices_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::voices);
        $($path_to_types_root)*::
        exports::golem::tts::synthesis::__export_golem_tts_synthesis_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::synthesis);
        $($path_to_types_root)*::
        exports::golem::tts::streaming::__export_golem_tts_streaming_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::streaming);
        $($path_to_types_root)*::
        exports::golem::tts::advanced::__export_golem_tts_advanced_1_0_0_cabi!($ty
        with_types_in $($path_to_types_root)*:: exports::golem::tts::advanced);
    };
}
#[doc(inline)]
pub(crate) use __export_tts_library_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:golem:tts-elevenlabs@1.0.0:tts-library:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 6919] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x855\x01A\x02\x01A\x19\
\x01B*\x01m\x04\x0acharacters\x08requests\x07seconds\x07credits\x04\0\x0aquota-u\
nit\x03\0\0\x01r\x04\x04usedy\x05limity\x0areset-timew\x04unit\x01\x04\0\x0aquot\
a-info\x03\0\x02\x01q\x14\x0cinvalid-text\x01s\0\x0dtext-too-long\x01y\0\x0cinva\
lid-ssml\x01s\0\x14unsupported-language\x01s\0\x0fvoice-not-found\x01s\0\x0fmode\
l-not-found\x01s\0\x11voice-unavailable\x01s\0\x0cunauthorized\x01s\0\x0daccess-\
denied\x01s\0\x0equota-exceeded\x01\x03\0\x0crate-limited\x01y\0\x14insufficient\
-credits\0\0\x10synthesis-failed\x01s\0\x15unsupported-operation\x01s\0\x15inval\
id-configuration\x01s\0\x13service-unavailable\x01s\0\x0dnetwork-error\x01s\0\x0e\
internal-error\x01s\0\x18invalid-storage-location\x01s\0\x15storage-access-denie\
d\x01s\0\x04\0\x09tts-error\x03\0\x04\x01s\x04\0\x0dlanguage-code\x03\0\x06\x01m\
\x03\x04male\x06female\x07neutral\x04\0\x0cvoice-gender\x03\0\x08\x01m\x04\x08st\
andard\x07premium\x06neural\x06studio\x04\0\x0dvoice-quality\x03\0\x0a\x01m\x02\x05\
plain\x04ssml\x04\0\x09text-type\x03\0\x0c\x01m\x08\x03mp3\x03wav\x03pcm\x08ogg-\
opus\x03aac\x04flac\x05mulaw\x04alaw\x04\0\x0caudio-format\x03\0\x0e\x01ky\x01k}\
\x01r\x04\x06format\x0f\x0bsample-rate\x10\x08bit-rate\x10\x08channels\x11\x04\0\
\x0caudio-config\x03\0\x12\x01kv\x01r\x06\x05speed\x14\x05pitch\x14\x06volume\x14\
\x09stability\x14\x0asimilarity\x14\x05style\x14\x04\0\x0evoice-settings\x03\0\x15\
\x01m\x07\x11telephone-quality\x13headphone-optimized\x11speaker-optimized\x13ca\
r-audio-optimized\x0fnoise-reduction\x0abass-boost\x0ctreble-boost\x04\0\x0daudi\
o-effects\x03\0\x17\x01k\x07\x01r\x03\x07contents\x09text-type\x0d\x08language\x19\
\x04\0\x0atext-input\x03\0\x1a\x01ks\x01r\x06\x10duration-secondsv\x0fcharacter-\
county\x0aword-county\x10audio-size-bytesy\x0arequest-ids\x0dprovider-info\x1c\x04\
\0\x12synthesis-metadata\x03\0\x1d\x01p}\x01r\x02\x0aaudio-data\x1f\x08metadata\x1e\
\x04\0\x10synthesis-result\x03\0\x20\x01m\x05\x04word\x08sentence\x09paragraph\x09\
ssml-mark\x06viseme\x04\0\x10timing-mark-type\x03\0\"\x01k#\x01r\x04\x12start-ti\
me-secondsv\x10end-time-seconds\x14\x0btext-offset\x10\x09mark-type$\x04\0\x0bti\
ming-info\x03\0%\x01k&\x01r\x04\x04data\x1f\x0fsequence-numbery\x08is-final\x7f\x0b\
timing-info'\x04\0\x0baudio-chunk\x03\0(\x04\0\x15golem:tts/types@1.0.0\x05\0\x02\
\x03\0\0\x09tts-error\x02\x03\0\0\x0dlanguage-code\x02\x03\0\0\x0cvoice-gender\x02\
\x03\0\0\x0dvoice-quality\x02\x03\0\0\x0caudio-format\x02\x03\0\0\x0evoice-setti\
ngs\x01BV\x02\x03\x02\x01\x01\x04\0\x09tts-error\x03\0\0\x02\x03\x02\x01\x02\x04\
\0\x0dlanguage-code\x03\0\x02\x02\x03\x02\x01\x03\x04\0\x0cvoice-gender\x03\0\x04\
\x02\x03\x02\x01\x04\x04\0\x0dvoice-quality\x03\0\x06\x02\x03\x02\x01\x05\x04\0\x0c\
audio-format\x03\0\x08\x02\x03\x02\x01\x06\x04\0\x0evoice-settings\x03\0\x0a\x04\
\0\x05voice\x03\x01\x01k\x03\x01k\x05\x01k\x07\x01k\x7f\x01ks\x01r\x06\x08langua\
ge\x0d\x06gender\x0e\x07quality\x0f\x0dsupports-ssml\x10\x08provider\x11\x0csear\
ch-query\x11\x04\0\x0cvoice-filter\x03\0\x12\x01p\x03\x01ps\x01r\x0d\x02ids\x04n\
ames\x08language\x03\x14additional-languages\x14\x06gender\x05\x07quality\x07\x0b\
description\x11\x08providers\x0bsample-ratey\x09is-custom\x7f\x09is-cloned\x7f\x0b\
preview-url\x11\x09use-cases\x15\x04\0\x0avoice-info\x03\0\x16\x04\0\x0dvoice-re\
sults\x03\x01\x01r\x04\x04code\x03\x04names\x0bnative-names\x0bvoice-county\x04\0\
\x0dlanguage-info\x03\0\x19\x01h\x0c\x01@\x01\x04self\x1b\0s\x04\0\x14[method]vo\
ice.get-id\x01\x1c\x04\0\x16[method]voice.get-name\x01\x1c\x01@\x01\x04self\x1b\0\
\x11\x04\0\x1d[method]voice.get-provider-id\x01\x1d\x01@\x01\x04self\x1b\0\x03\x04\
\0\x1a[method]voice.get-language\x01\x1e\x01@\x01\x04self\x1b\0\x14\x04\0&[metho\
d]voice.get-additional-languages\x01\x1f\x01@\x01\x04self\x1b\0\x05\x04\0\x18[me\
thod]voice.get-gender\x01\x20\x01@\x01\x04self\x1b\0\x07\x04\0\x19[method]voice.\
get-quality\x01!\x04\0\x1d[method]voice.get-description\x01\x1d\x01@\x01\x04self\
\x1b\0\x7f\x04\0\x1b[method]voice.supports-ssml\x01\"\x01py\x01@\x01\x04self\x1b\
\0#\x04\0\x1e[method]voice.get-sample-rates\x01$\x01p\x09\x01@\x01\x04self\x1b\0\
%\x04\0#[method]voice.get-supported-formats\x01&\x01j\0\x01\x01\x01@\x02\x04self\
\x1b\x08settings\x0b\0'\x04\0\x1d[method]voice.update-settings\x01(\x01@\x01\x04\
self\x1b\0'\x04\0\x14[method]voice.delete\x01)\x01i\x0c\x01j\x01*\x01\x01\x01@\x01\
\x04self\x1b\0+\x04\0\x13[method]voice.clone\x01,\x01p}\x01j\x01-\x01\x01\x01@\x02\
\x04self\x1b\x04texts\0.\x04\0\x15[method]voice.preview\x01/\x01h\x18\x01@\x01\x04\
self0\0\x7f\x04\0\x1e[method]voice-results.has-more\x011\x01p\x17\x01j\x012\x01\x01\
\x01@\x01\x04self0\03\x04\0\x1e[method]voice-results.get-next\x014\x01ky\x01@\x01\
\x04self0\05\x04\0%[method]voice-results.get-total-count\x016\x01k\x13\x01i\x18\x01\
j\x018\x01\x01\x01@\x01\x06filter7\09\x04\0\x0blist-voices\x01:\x01@\x01\x08voic\
e-ids\0+\x04\0\x09get-voice\x01;\x01@\x02\x05querys\x06filter7\03\x04\0\x0dsearc\
h-voices\x01<\x01p\x1a\x01j\x01=\x01\x01\x01@\0\0>\x04\0\x0elist-languages\x01?\x04\
\0\x16golem:tts/voices@1.0.0\x05\x07\x02\x03\0\0\x0atext-input\x02\x03\0\0\x0cau\
dio-config\x02\x03\0\0\x0daudio-effects\x02\x03\0\0\x10synthesis-result\x02\x03\0\
\0\x0btiming-info\x02\x03\0\x01\x05voice\x01B1\x02\x03\x02\x01\x08\x04\0\x0atext\
-input\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0caudio-config\x03\0\x02\x02\x03\x02\x01\
\x06\x04\0\x0evoice-settings\x03\0\x04\x02\x03\x02\x01\x0a\x04\0\x0daudio-effect\
s\x03\0\x06\x02\x03\x02\x01\x0b\x04\0\x10synthesis-result\x03\0\x08\x02\x03\x02\x01\
\x01\x04\0\x09tts-error\x03\0\x0a\x02\x03\x02\x01\x0c\x04\0\x0btiming-info\x03\0\
\x0c\x02\x03\x02\x01\x0d\x04\0\x05voice\x03\0\x0e\x01ks\x01r\x05\x0dprevious-tex\
t\x10\x09next-text\x10\x05topic\x10\x07emotion\x10\x0espeaking-style\x10\x04\0\x11\
synthesis-context\x03\0\x11\x01k\x03\x01k\x05\x01p\x07\x01k\x15\x01k\x7f\x01ky\x01\
k\x12\x01r\x08\x0caudio-config\x13\x0evoice-settings\x14\x0daudio-effects\x16\x0d\
enable-timing\x17\x12enable-word-timing\x17\x04seed\x18\x0dmodel-version\x10\x07\
context\x19\x04\0\x11synthesis-options\x03\0\x1a\x01kv\x01ps\x01r\x05\x08is-vali\
d\x7f\x0fcharacter-county\x12estimated-duration\x1c\x08warnings\x1d\x06errors\x1d\
\x04\0\x11validation-result\x03\0\x1e\x01h\x0f\x01k\x1b\x01j\x01\x09\x01\x0b\x01\
@\x03\x05input\x01\x05voice\x20\x07options!\0\"\x04\0\x0asynthesize\x01#\x01p\x01\
\x01p\x09\x01j\x01%\x01\x0b\x01@\x03\x06inputs$\x05voice\x20\x07options!\0&\x04\0\
\x10synthesize-batch\x01'\x01p\x0d\x01j\x01(\x01\x0b\x01@\x02\x05input\x01\x05vo\
ice\x20\0)\x04\0\x10get-timing-marks\x01*\x01j\x01\x1f\x01\x0b\x01@\x02\x05input\
\x01\x05voice\x20\0+\x04\0\x0evalidate-input\x01,\x04\0\x19golem:tts/synthesis@1\
.0.0\x05\x0e\x02\x03\0\0\x0baudio-chunk\x02\x03\0\x02\x11synthesis-options\x01B8\
\x02\x03\x02\x01\x08\x04\0\x0atext-input\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0cau\
dio-config\x03\0\x02\x02\x03\x02\x01\x06\x04\0\x0evoice-settings\x03\0\x04\x02\x03\
\x02\x01\x0f\x04\0\x0baudio-chunk\x03\0\x06\x02\x03\x02\x01\x01\x04\0\x09tts-err\
or\x03\0\x08\x02\x03\x02\x01\x0c\x04\0\x0btiming-info\x03\0\x0a\x02\x03\x02\x01\x0d\
\x04\0\x05voice\x03\0\x0c\x02\x03\x02\x01\x10\x04\0\x11synthesis-options\x03\0\x0e\
\x04\0\x10synthesis-stream\x03\x01\x01m\x05\x05ready\x0aprocessing\x08finished\x05\
error\x06closed\x04\0\x0dstream-status\x03\0\x11\x04\0\x17voice-conversion-strea\
m\x03\x01\x01h\x10\x01j\0\x01\x09\x01@\x02\x04self\x14\x05input\x01\0\x15\x04\0\"\
[method]synthesis-stream.send-text\x01\x16\x01@\x01\x04self\x14\0\x15\x04\0\x1f[\
method]synthesis-stream.finish\x01\x17\x01k\x07\x01j\x01\x18\x01\x09\x01@\x01\x04\
self\x14\0\x19\x04\0&[method]synthesis-stream.receive-chunk\x01\x1a\x01@\x01\x04\
self\x14\0\x7f\x04\0*[method]synthesis-stream.has-pending-audio\x01\x1b\x01@\x01\
\x04self\x14\0\x12\x04\0#[method]synthesis-stream.get-status\x01\x1c\x01@\x01\x04\
self\x14\x01\0\x04\0\x1e[method]synthesis-stream.close\x01\x1d\x01h\x13\x01p}\x01\
@\x02\x04self\x1e\x0aaudio-data\x1f\0\x15\x04\0*[method]voice-conversion-stream.\
send-audio\x01\x20\x01@\x01\x04self\x1e\0\x19\x04\01[method]voice-conversion-str\
eam.receive-converted\x01!\x01@\x01\x04self\x1e\0\x15\x04\0&[method]voice-conver\
sion-stream.finish\x01\"\x01@\x01\x04self\x1e\x01\0\x04\0%[method]voice-conversi\
on-stream.close\x01#\x01h\x0d\x01k\x0f\x01i\x10\x01j\x01&\x01\x09\x01@\x02\x05vo\
ice$\x07options%\0'\x04\0\x0dcreate-stream\x01(\x01i\x13\x01j\x01)\x01\x09\x01@\x02\
\x0ctarget-voice$\x07options%\0*\x04\0\x1ecreate-voice-conversion-stream\x01+\x04\
\0\x19golem:tts/streaming@1.0.0\x05\x11\x02\x03\0\0\x12synthesis-metadata\x01BT\x02\
\x03\x02\x01\x01\x04\0\x09tts-error\x03\0\0\x02\x03\x02\x01\x09\x04\0\x0caudio-c\
onfig\x03\0\x02\x02\x03\x02\x01\x02\x04\0\x0dlanguage-code\x03\0\x04\x02\x03\x02\
\x01\x03\x04\0\x0cvoice-gender\x03\0\x06\x02\x03\x02\x01\x12\x04\0\x12synthesis-\
metadata\x03\0\x08\x02\x03\x02\x01\x0d\x04\0\x05voice\x03\0\x0a\x01p}\x01ks\x01k\
}\x01r\x03\x04data\x0c\x0atranscript\x0d\x0equality-rating\x0e\x04\0\x0caudio-sa\
mple\x03\0\x0f\x01m\x04\x05child\x0byoung-adult\x0bmiddle-aged\x07elderly\x04\0\x0c\
age-category\x03\0\x11\x01ps\x01r\x05\x06gender\x07\x0cage-category\x12\x06accen\
ts\x12personality-traits\x13\x0freference-voice\x0d\x04\0\x13voice-design-params\
\x03\0\x14\x04\0\x15pronunciation-lexicon\x03\x01\x01r\x03\x04words\x0dpronuncia\
tions\x0epart-of-speech\x0d\x04\0\x13pronunciation-entry\x03\0\x17\x04\0\x13long\
-form-operation\x03\x01\x01m\x05\x07pending\x0aprocessing\x09completed\x06failed\
\x09cancelled\x04\0\x10operation-status\x03\0\x1a\x01pv\x01k\x1c\x01r\x04\x0fout\
put-locations\x0etotal-durationv\x11chapter-durations\x1d\x08metadata\x09\x04\0\x10\
long-form-result\x03\0\x1e\x01h\x16\x01@\x01\x04self\x20\0s\x04\0&[method]pronun\
ciation-lexicon.get-name\x01!\x01@\x01\x04self\x20\0\x05\x04\0*[method]pronuncia\
tion-lexicon.get-language\x01\"\x01@\x01\x04self\x20\0y\x04\0-[method]pronunciat\
ion-lexicon.get-entry-count\x01#\x01j\0\x01\x01\x01@\x03\x04self\x20\x04words\x0d\
pronunciations\0$\x04\0'[method]pronunciation-lexicon.add-entry\x01%\x01@\x02\x04\
self\x20\x04words\0$\x04\0*[method]pronunciation-lexicon.remove-entry\x01&\x01j\x01\
s\x01\x01\x01@\x01\x04self\x20\0'\x04\0,[method]pronunciation-lexicon.export-con\
tent\x01(\x01h\x19\x01@\x01\x04self)\0\x1b\x04\0&[method]long-form-operation.get\
-status\x01*\x01@\x01\x04self)\0v\x04\0([method]long-form-operation.get-progress\
\x01+\x01@\x01\x04self)\0$\x04\0\"[method]long-form-operation.cancel\x01,\x01j\x01\
\x1f\x01\x01\x01@\x01\x04self)\0-\x04\0&[method]long-form-operation.get-result\x01\
.\x01p\x10\x01i\x0b\x01j\x010\x01\x01\x01@\x03\x04names\x0daudio-samples/\x0bdes\
cription\x0d\01\x04\0\x12create-voice-clone\x012\x01@\x02\x04names\x0fcharacteri\
stics\x15\01\x04\0\x0cdesign-voice\x013\x01h\x0b\x01k\x7f\x01j\x01\x0c\x01\x01\x01\
@\x03\x0binput-audio\x0c\x0ctarget-voice4\x0fpreserve-timing5\06\x04\0\x0dconver\
t-voice\x017\x01kv\x01@\x03\x0bdescriptions\x10duration-seconds8\x0fstyle-influe\
nce8\06\x04\0\x15generate-sound-effect\x019\x01p\x18\x01k:\x01i\x16\x01j\x01<\x01\
\x01\x01@\x03\x04names\x08language\x05\x07entries;\0=\x04\0\x0ecreate-lexicon\x01\
>\x01py\x01k?\x01i\x19\x01j\x01\xc1\0\x01\x01\x01@\x04\x07contents\x05voice4\x0f\
output-locations\x0echapter-breaks\xc0\0\0\xc2\0\x04\0\x14synthesize-long-form\x01\
C\x04\0\x18golem:tts/advanced@1.0.0\x05\x13\x04\0&golem:tts-elevenlabs/tts-libra\
ry@1.0.0\x04\0\x0b\x11\x01\0\x0btts-library\x03\0\0\0G\x09producers\x01\x0cproce\
ssed-by\x02\x0dwit-component\x070.220.1\x10wit-bindgen-rust\x060.36.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
