#[allow(static_mut_refs)]
mod bindings;

use golem_rust::atomically;
use crate::bindings::exports::test::vector_exports::test_vector_api::*;
use crate::bindings::test::helper_client::test_helper_client::TestHelperApi;
// Re-exported vector interfaces autogenerated from WIT
use crate::bindings::golem::vector::collections;
use crate::bindings::golem::vector::connection;
use crate::bindings::golem::vector::search;
use crate::bindings::golem::vector::types;
use crate::bindings::golem::vector::vectors;
use std::thread;
use std::time::Duration;

const COLLECTION_NAME: &str = "golem_test_vectors";
const BATCH_COLLECTION_NAME: &str = "golem_batch_test";
const SEARCH_COLLECTION_NAME: &str = "golem_search_test";
const POLL_WAIT_SECONDS: u64 = 3;
const DIMENSION: u32 = 3;

struct Component;

impl Guest for Component {
    /// Test connection status and basic provider information
    fn test1() -> String {
        // Test connection status
        match connection::get_connection_status() {
            Ok(status) => {
                let connected = match status {
                    types::ConnectionStatus::Connected => "Connected",
                    types::ConnectionStatus::Disconnected => "Disconnected",
                };
                
                // Test collection creation
                match collections::upsert_collection(
                    COLLECTION_NAME,
                    Some("Basic test collection".into()),
                    DIMENSION,
                    types::DistanceMetric::Cosine,
                    None,
                    None,
                ) {
                    Ok(info) => format!(
                        "Status: {}, Collection '{}' ready (dimension: {}, metric: {:?})",
                        connected, info.name, info.dimension, info.metric
                    ),
                    Err(err) => format!("Status: {}, ERROR creating collection: {:?}", connected, err),
                }
            }
            Err(err) => format!("ERROR: failed to get connection status: {:?}", err),
        }
    }

    /// Test batch vector operations and metadata handling
    fn test2() -> String {
        // Create test collection for batch operations
        if let Err(e) = collections::upsert_collection(
            BATCH_COLLECTION_NAME,
            Some("Batch operations test".into()),
            DIMENSION,
            types::DistanceMetric::Cosine,
            None,
            None,
        ) {
            return format!("ERROR: failed to create batch collection: {:?}", e);
        }
        
        // Prepare batch vectors with metadata
        let mut test_vectors = Vec::new();
        for i in 1..=5 {
            let mut metadata = std::collections::BTreeMap::new();
            metadata.insert("index".to_string(), types::MetadataValue::Number(i as f64));
            metadata.insert("category".to_string(), types::MetadataValue::String(format!("test_{}", i)));
            
            test_vectors.push(types::VectorRecord {
                id: format!("batch_vec_{}", i),
                vector: types::VectorData::Dense(vec![i as f32, (i * 2) as f32, (i * 3) as f32]),
                metadata: Some(metadata),
            });
        }
        
        // Test batch upsert
        match vectors::upsert_vectors(BATCH_COLLECTION_NAME, test_vectors.clone(), None) {
            Ok(result) => {
                if result.failure_count > 0 {
                    return format!("Batch upsert had failures: {}/{} failed", 
                        result.failure_count, test_vectors.len());
                }
                
                // Test batch retrieval
                let ids: Vec<String> = test_vectors.iter().map(|v| v.id.clone()).collect();
                match vectors::get_vectors(BATCH_COLLECTION_NAME, ids, None, Some(true), Some(true)) {
                    Ok(retrieved) => format!(
                        "Batch test success: upserted {}, retrieved {} vectors with metadata",
                        result.success_count, retrieved.len()
                    ),
                    Err(e) => format!("ERROR: batch retrieval failed: {:?}", e),
                }
            }
            Err(e) => format!("ERROR: batch upsert failed: {:?}", e),
        }
    }

    /// Test comprehensive search functionality with filtering
    fn test3() -> String {
        // Create search test collection
        if let Err(e) = collections::upsert_collection(
            SEARCH_COLLECTION_NAME,
            Some("Search operations test".into()),
            DIMENSION,
            types::DistanceMetric::Cosine,
            None,
            None,
        ) {
            return format!("ERROR: failed to create search collection: {:?}", e);
        }
        
        // Insert diverse test vectors for search
        let mut search_vectors = Vec::new();
        let categories = ["red", "blue", "green"];
        for (i, category) in categories.iter().enumerate() {
            for j in 1..=3 {
                let mut metadata = std::collections::BTreeMap::new();
                metadata.insert("color".to_string(), types::MetadataValue::String(category.to_string()));
                metadata.insert("size".to_string(), types::MetadataValue::Number(j as f64));
                
                search_vectors.push(types::VectorRecord {
                    id: format!("{}_{}", category, j),
                    vector: types::VectorData::Dense(vec![
                        (i + 1) as f32 * 0.5, 
                        j as f32 * 0.3, 
                        ((i + j) % 3) as f32 * 0.2
                    ]),
                    metadata: Some(metadata),
                });
            }
        }
        
        // Upsert search vectors
        if let Err(e) = vectors::upsert_vectors(SEARCH_COLLECTION_NAME, search_vectors, None) {
            return format!("ERROR: failed to upsert search vectors: {:?}", e);
        }
        
        // Wait for indexing
        thread::sleep(Duration::from_secs(POLL_WAIT_SECONDS));
        
        // Test similarity search
        let query = types::SearchQuery::Vector(types::VectorData::Dense(vec![0.5, 0.3, 0.2]));
        match search::search_vectors(
            SEARCH_COLLECTION_NAME,
            &query,
            5,
            None,            // no filter
            None,            // no namespace
            Some(true),      // include vectors
            Some(true),      // include metadata
            None,
            None,
            None,
        ) {
            Ok(results) => {
                if results.is_empty() {
                    "No search results found".into()
                } else {
                    let first = &results[0];
                    format!(
                        "Search success: {} results, top match '{}' (score: {:.3}, distance: {:.3})",
                        results.len(), first.id, first.score, first.distance
                    )
                }
            }
            Err(e) => format!("ERROR: search failed: {:?}", e),
        }
    }

    /// Test vector operations (update, delete) and error handling
    fn test4() -> String {
        let test_id = "update_test_vec";
        
        // Insert initial vector
        let initial_vector = types::VectorRecord {
            id: test_id.to_string(),
            vector: types::VectorData::Dense(vec![1.0, 2.0, 3.0]),
            metadata: None,
        };
        
        if let Err(e) = vectors::upsert_vector(
            COLLECTION_NAME,
            test_id,
            initial_vector.vector.clone(),
            initial_vector.metadata.clone(),
            None,
        ) {
            return format!("ERROR: initial upsert failed: {:?}", e);
        }
        
        // Test vector update
        let mut updated_metadata = std::collections::BTreeMap::new();
        updated_metadata.insert("updated".to_string(), types::MetadataValue::Bool(true));
        
        match vectors::update_vector(
            COLLECTION_NAME,
            test_id,
            Some(types::VectorData::Dense(vec![4.0, 5.0, 6.0])),
            Some(updated_metadata),
            None,
            Some(false), // don't merge metadata
        ) {
            Ok(()) => {
                // Verify update
                match vectors::get_vector(COLLECTION_NAME, test_id, None) {
                    Ok(Some(updated)) => {
                        let has_metadata = updated.metadata.is_some();
                        format!("Update test success: vector updated, metadata present: {}", has_metadata)
                    }
                    Ok(None) => "ERROR: vector not found after update".into(),
                    Err(e) => format!("ERROR: failed to retrieve updated vector: {:?}", e),
                }
            }
            Err(e) => format!("ERROR: update failed: {:?}", e),
        }
    }
    
    /// Test durability and crash recovery
    fn test5() -> String {
        // Count vectors before crash simulation
        let initial_count = match vectors::count_vectors(COLLECTION_NAME, None, None) {
            Ok(count) => count,
            Err(e) => return format!("ERROR: failed to count vectors: {:?}", e),
        };
        
        // Simulate durability test: crash once on first execution
        let worker_name = std::env::var("GOLEM_WORKER_NAME").unwrap_or_default();
        atomically(|| {
            let client = TestHelperApi::new(&worker_name);
            if client.blocking_inc_and_get() == 1 {
                panic!("Simulated crash during durability test");
            }
        });
        
        // After recovery, verify data persistence
        match vectors::count_vectors(COLLECTION_NAME, None, None) {
            Ok(final_count) => format!(
                "Durability test success: {} vectors before crash, {} after recovery",
                initial_count, final_count
            ),
            Err(e) => format!("ERROR: failed to count vectors after recovery: {:?}", e),
        }
    }
    
    /// Test collection management and cleanup
    fn test6() -> String {
        // List all collections
        let initial_collections = match collections::list_collections() {
            Ok(cols) => cols,
            Err(e) => return format!("ERROR: failed to list collections: {:?}", e),
        };
        
        let cleanup_collection = "test_cleanup_collection";
        
        // Create temporary collection
        if let Err(e) = collections::upsert_collection(
            cleanup_collection,
            Some("Temporary test collection".into()),
            DIMENSION,
            types::DistanceMetric::Euclidean,
            None,
            None,
        ) {
            return format!("ERROR: failed to create cleanup collection: {:?}", e);
        }
        
        // Verify collection exists
        let exists = match collections::collection_exists(cleanup_collection) {
            Ok(exists) => exists,
            Err(e) => return format!("ERROR: failed to check collection existence: {:?}", e),
        };
        
        if !exists {
            return "ERROR: collection should exist after creation".into();
        }
        
        // Clean up: delete the test collection
        match collections::delete_collection(cleanup_collection) {
            Ok(()) => {
                // Verify deletion
                match collections::collection_exists(cleanup_collection) {
                    Ok(false) => format!(
                        "Collection management test success: created and deleted collection (initial count: {})",
                        initial_collections.len()
                    ),
                    Ok(true) => "ERROR: collection still exists after deletion".into(),
                    Err(e) => format!("ERROR: failed to verify deletion: {:?}", e),
                }
            }
            Err(e) => format!("ERROR: failed to delete collection: {:?}", e),
        }
    }
}

bindings::export!(Component with_types_in bindings);