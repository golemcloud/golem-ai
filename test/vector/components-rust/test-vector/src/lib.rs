#[allow(static_mut_refs)]
mod bindings;

use golem_rust::atomically;
use crate::bindings::exports::test::vector_exports::test_vector_api::*;
use crate::bindings::test::helper_client::test_helper_client::TestHelperApi;
// Re-exported vector interfaces autogenerated from WIT
use crate::bindings::golem::vector::collections;
use crate::bindings::golem::vector::types;
use crate::bindings::golem::vector::vectors;
use crate::bindings::golem::vector::search;
use std::thread;
use std::time::Duration;

const COLLECTION_NAME: &str = "golem_test_vectors";
const POLL_WAIT_SECONDS: u64 = 3;

struct Component;

impl Guest for Component {
    /// Create (or upsert) a simple test collection.
    fn test1() -> String {
        match collections::upsert_collection(
            COLLECTION_NAME,
            Some("Basic test collection".into()),
            3,                                        // dimension
            types::DistanceMetric::Cosine,            // metric
            None,                                     // index config
            None,                                     // metadata
        ) {
            Ok(info) => format!(
                "Collection '{}' ready (vectors: {}, metric: {:?})",
                info.name, info.vector_count, info.metric
            ),
            Err(err) => format!("ERROR: failed to create collection: {:?}", err),
        }
    }

    /// Upsert one fixed vector and read it back.
    fn test2() -> String {
        let id = "vec1".to_string();
        let vec_data = types::VectorData::Dense(vec![1.0f32, 0.0, 1.0]);
        let record = types::VectorRecord {
            id: id.clone(),
            vector: vec_data,
            metadata: None,
        };

        if let Err(e) = vectors::upsert_vectors(COLLECTION_NAME, vec![record], None) {
            return format!("ERROR: upsert failed: {:?}", e);
        }

        match vectors::get_vector(COLLECTION_NAME, &id, None) {
            Ok(Some(v)) => format!("Vector fetched successfully: {} => {:?}", v.id, v.vector),
            Ok(None) => "Vector not found after upsert".into(),
            Err(e) => format!("ERROR: get_vector failed: {:?}", e),
        }
    }

    /// Perform a simple similarity search and simulate durability by crashing once.
    fn test3() -> String {
        // query vector identical to the one inserted in test2
        let query = types::SearchQuery::Vector(types::VectorData::Dense(vec![1.0f32, 0.0, 1.0]));

        // wait a little to ensure collection/index is ready
        thread::sleep(Duration::from_secs(POLL_WAIT_SECONDS));

        let maybe_results = search::search_vectors(
            COLLECTION_NAME,
            &query,
            5,               // limit
            None,            // filter
            None,            // namespace
            Some(false),     // include vectors
            Some(false),     // include metadata
            None,            // min score
            None,            // max distance
            None,            // search params
        );

        match maybe_results {
            Ok(results) => {
                // simulate durability test: crash once on first poll
                let worker_name = std::env::var("GOLEM_WORKER_NAME").unwrap_or_default();
                atomically(|| {
                    let client = TestHelperApi::new(&worker_name);
                    if client.blocking_inc_and_get() == 1 {
                        panic!("Simulated crash during durability test");
                    }
                });

                if results.is_empty() {
                    "No similar vectors found".into()
                } else {
                    format!("Search returned {} result(s). First ID: {}", results.len(), results[0].id)
                }
            }
            Err(e) => format!("ERROR: search failed: {:?}", e),
        }
    }
}

bindings::export!(Component with_types_in bindings);